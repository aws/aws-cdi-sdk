<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: src/cdi/protocol.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_440858bc2ff41f5ef15b020e90223871.html">cdi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">protocol.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The declarations in this header file correspond to the definitions in protcol.c.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cdi__core__api_8h_source.html">cdi_core_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cdi__pool__api_8h_source.html">cdi_pool_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="payload_8h_source.html">payload.h</a>&quot;</code><br />
</div>
<p><a href="protocol_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiProtocolVersionNumber.html">CdiProtocolVersionNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDI header used to identify protocol version number information.  <a href="structCdiProtocolVersionNumber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiDecodedPacketDataOffsetInfo.html">CdiDecodedPacketDataOffsetInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDI decoded header for payload packets that contains a data offset value (payload type is kPayloadTypeDataOffset). Decoded headers are protocol independent.  <a href="structCdiDecodedPacketDataOffsetInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiDecodedPacketNum0Info.html">CdiDecodedPacketNum0Info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDI decoded header for payload packet #0. This packet never uses payload_data_offset, since it is always zero. Decoded headers are protocol independent.  <a href="structCdiDecodedPacketNum0Info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiDecodedPacketHeader.html">CdiDecodedPacketHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of decoded CDI packet headers. Use to reserve memory that can be used to hold any type of decoded CDI packet header. Decoded headers are protocol independent.  <a href="structCdiDecodedPacketHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiRawPacketHeader.html">CdiRawPacketHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of raw CDI packet headers. Use to reserve memory that can be used to hold raw CDI packet headers that do not contain extra data. Each protocol version uses a specific data format and is kept internal. Use PayloadHeaderDecode() to decoded the raw packet header into <a class="el" href="structCdiDecodedPacketHeader.html" title="Union of decoded CDI packet headers. Use to reserve memory that can be used to hold any type of decod...">CdiDecodedPacketHeader</a>, which is protocol independent. Use PayloadHeaderInit() to convert a <a class="el" href="structCdiDecodedPacketHeader.html" title="Union of decoded CDI packet headers. Use to reserve memory that can be used to hold any type of decod...">CdiDecodedPacketHeader</a> into this format.  <a href="structCdiRawPacketHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiRawExtraPacketHeader.html">CdiRawExtraPacketHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of raw CDI extra packet headers. Use to reserve memory that can be used to hold raw CDI packet headers that contain extra data (ie. AVM configuration data). Each protocol version uses a specific data format and is kept internal. Use PayloadHeaderDecode() to decoded the raw packet header into <a class="el" href="structCdiDecodedPacketHeader.html" title="Union of decoded CDI packet headers. Use to reserve memory that can be used to hold any type of decod...">CdiDecodedPacketHeader</a>, which is protocol independent. Use PayloadHeaderInit() to convert a <a class="el" href="structCdiDecodedPacketHeader.html" title="Union of decoded CDI packet headers. Use to reserve memory that can be used to hold any type of decod...">CdiDecodedPacketHeader</a> into this format.  <a href="structCdiRawExtraPacketHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiPacketRxReorderInfo.html">CdiPacketRxReorderInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold packet data used by Rx packet reordering.  <a href="structCdiPacketRxReorderInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiDecodedProbeCommand.html">CdiDecodedProbeCommand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe command packet that is being transmitted.  <a href="structCdiDecodedProbeCommand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiDecodedProbeAck.html">CdiDecodedProbeAck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control ACK packet that is a response for a transmitted command.  <a href="structCdiDecodedProbeAck.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiDecodedProbeHeader.html">CdiDecodedProbeHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of decoded probe headers. Use to reserve memory that can be used to hold any type of decoded CDI probe header. Decoded headers are protocol independent.  <a href="structCdiDecodedProbeHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEfaProbePacket.html">EfaProbePacket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structPacket.html">Packet</a> format used by probe when sending probe packets over the EFA interface.  <a href="structEfaProbePacket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiRawProbeHeader.html">CdiRawProbeHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of raw probe headers. Use to reserve memory that can be used to hold any type of raw probe header. Each protocol version uses a specific data format and is kept internal. Use <a class="el" href="protocol_8c.html#af3887f9a62f9ec20d2063d96bff154ab" title="Decode an encoded raw header into a header structure that is protocol version independent.">ProtocolPayloadHeaderDecode()</a> to decoded the raw packet header into <a class="el" href="structCdiDecodedProbeHeader.html" title="Union of decoded probe headers. Use to reserve memory that can be used to hold any type of decoded CD...">CdiDecodedProbeHeader</a>, which is protocol independent. Use <a class="el" href="protocol_8c.html#ae9095ab0d6b59bcc52a2e58dbab09658" title="Encode raw payload header data using the specified protocol and probe state data.">ProtocolProbeHeaderEncode()</a> to convert a <a class="el" href="structCdiDecodedProbeHeader.html" title="Union of decoded probe headers. Use to reserve memory that can be used to hold any type of decoded CD...">CdiDecodedProbeHeader</a> into this format.  <a href="structCdiRawProbeHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiProtocol.html">CdiProtocol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold negotiated protocol version information.  <a href="structCdiProtocol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiProtocolVTableApi.html">CdiProtocolVTableApi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to hold V-table of APIs that must be implemented by payload protocol versions.  <a href="structCdiProtocolVTableApi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a25da81fb292a7f2132601cc467bc4583" id="r_a25da81fb292a7f2132601cc467bc4583"><td class="memItemLeft" align="right" valign="top"><a id="a25da81fb292a7f2132601cc467bc4583" name="a25da81fb292a7f2132601cc467bc4583"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_RAW_PACKET_HEADER_SIZE_V1</b>&#160;&#160;&#160;(34)</td></tr>
<tr class="memdesc:a25da81fb292a7f2132601cc467bc4583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the size of the <a class="el" href="structPacketHeaderUnion.html" title="Union of payload cdi headers. Use to reserve memory that can be used to hold any type of CDI packet h...">PacketHeaderUnion</a> structure used in protocol V1. This is done so the size of the structure is known at compile time without having to expose the contents of it in a header file. <br /></td></tr>
<tr class="separator:a25da81fb292a7f2132601cc467bc4583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68dea2e12d40034bb7244a6e4846eaf" id="r_ae68dea2e12d40034bb7244a6e4846eaf"><td class="memItemLeft" align="right" valign="top"><a id="ae68dea2e12d40034bb7244a6e4846eaf" name="ae68dea2e12d40034bb7244a6e4846eaf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_RAW_PACKET_HEADER_SIZE_V2</b>&#160;&#160;&#160;(47)</td></tr>
<tr class="memdesc:ae68dea2e12d40034bb7244a6e4846eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the size of the <a class="el" href="structPacketHeaderUnion.html" title="Union of payload cdi headers. Use to reserve memory that can be used to hold any type of CDI packet h...">PacketHeaderUnion</a> structure used in protocol V2. This is done so the size of the structure is known at compile time without having to expose the contents of it in a header file. <br /></td></tr>
<tr class="separator:ae68dea2e12d40034bb7244a6e4846eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72941de3894aee2c1f56f67feb5a9ea" id="r_ad72941de3894aee2c1f56f67feb5a9ea"><td class="memItemLeft" align="right" valign="top"><a id="ad72941de3894aee2c1f56f67feb5a9ea" name="ad72941de3894aee2c1f56f67feb5a9ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_RAW_PROBE_HEADER_SIZE_V1</b>&#160;&#160;&#160;(257)</td></tr>
<tr class="memdesc:ad72941de3894aee2c1f56f67feb5a9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the size of the ProbeHeaderUnion structure used in protocol V1. This is done so the size of the structure is known at compile time without having to expose the contents of it in a header file. <br /></td></tr>
<tr class="separator:ad72941de3894aee2c1f56f67feb5a9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdc65e12870159e9de9ae17088c4935" id="r_abcdc65e12870159e9de9ae17088c4935"><td class="memItemLeft" align="right" valign="top"><a id="abcdc65e12870159e9de9ae17088c4935" name="abcdc65e12870159e9de9ae17088c4935"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_RAW_PROBE_HEADER_SIZE_V2</b>&#160;&#160;&#160;(253)</td></tr>
<tr class="memdesc:abcdc65e12870159e9de9ae17088c4935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the size of the ProbeHeaderUnion structure used in protocol V2. This is done so the size of the structure is known at compile time without having to expose the contents of it in a header file. <br /></td></tr>
<tr class="separator:abcdc65e12870159e9de9ae17088c4935"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa559e15a4e202e215d026c8bc3fcb453" id="r_aa559e15a4e202e215d026c8bc3fcb453"><td class="memItemLeft" align="right" valign="top"><a id="aa559e15a4e202e215d026c8bc3fcb453" name="aa559e15a4e202e215d026c8bc3fcb453"></a>
typedef struct CdiProtocolVersionNumber&#160;</td><td class="memItemRight" valign="bottom"><b>CdiProtocolVersionNumber</b></td></tr>
<tr class="memdesc:aa559e15a4e202e215d026c8bc3fcb453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward reference of structure to create pointers later. <br /></td></tr>
<tr class="separator:aa559e15a4e202e215d026c8bc3fcb453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec16269e770df2adab8c09348b89b17e" id="r_aec16269e770df2adab8c09348b89b17e"><td class="memItemLeft" align="right" valign="top"><a id="aec16269e770df2adab8c09348b89b17e" name="aec16269e770df2adab8c09348b89b17e"></a>
typedef struct CdiRawProbeHeader&#160;</td><td class="memItemRight" valign="bottom"><b>CdiRawProbeHeader</b></td></tr>
<tr class="memdesc:aec16269e770df2adab8c09348b89b17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward reference of structure to create pointers later. <br /></td></tr>
<tr class="separator:aec16269e770df2adab8c09348b89b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37211329c69de49454fff77dd9c54db1" id="r_a37211329c69de49454fff77dd9c54db1"><td class="memItemLeft" align="right" valign="top"><a id="a37211329c69de49454fff77dd9c54db1" name="a37211329c69de49454fff77dd9c54db1"></a>
typedef struct CdiConnectionState&#160;</td><td class="memItemRight" valign="bottom"><b>CdiConnectionState</b></td></tr>
<tr class="memdesc:a37211329c69de49454fff77dd9c54db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward reference of structure to create pointers later. <br /></td></tr>
<tr class="separator:a37211329c69de49454fff77dd9c54db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b726dbfdf7d61bf07a8cac967064f6e" id="r_a8b726dbfdf7d61bf07a8cac967064f6e"><td class="memItemLeft" align="right" valign="top">typedef struct TxPayloadState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b726dbfdf7d61bf07a8cac967064f6e">TxPayloadState</a></td></tr>
<tr class="memdesc:a8b726dbfdf7d61bf07a8cac967064f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward reference of structure to create pointers later.  <br /></td></tr>
<tr class="separator:a8b726dbfdf7d61bf07a8cac967064f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57182d381a4d1be37bfa792b77553e91" id="r_a57182d381a4d1be37bfa792b77553e91"><td class="memItemLeft" align="right" valign="top"><a id="a57182d381a4d1be37bfa792b77553e91" name="a57182d381a4d1be37bfa792b77553e91"></a>
typedef struct <a class="el" href="structCdiProtocol.html">CdiProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiProtocolHandle</b></td></tr>
<tr class="memdesc:a57182d381a4d1be37bfa792b77553e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward reference of structure to create pointers later. <br /></td></tr>
<tr class="separator:a57182d381a4d1be37bfa792b77553e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd5926990b7fc751b181a2fd4567fec" id="r_aedd5926990b7fc751b181a2fd4567fec"><td class="memItemLeft" align="right" valign="top"><a id="aedd5926990b7fc751b181a2fd4567fec" name="aedd5926990b7fc751b181a2fd4567fec"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>VtblPayloadHeaderDecode</b>) (const void *encoded_data_ptr, int encoded_data_size, <a class="el" href="structCdiDecodedPacketHeader.html">CdiDecodedPacketHeader</a> *dest_header_ptr)</td></tr>
<tr class="memdesc:aedd5926990b7fc751b181a2fd4567fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of function used for protocol version VTable API. <br /></td></tr>
<tr class="separator:aedd5926990b7fc751b181a2fd4567fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4454dd608d4531d45f903c0701e8d1c8" id="r_a4454dd608d4531d45f903c0701e8d1c8"><td class="memItemLeft" align="right" valign="top"><a id="a4454dd608d4531d45f903c0701e8d1c8" name="a4454dd608d4531d45f903c0701e8d1c8"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>VtblPayloadHeaderInit</b>) (void *header_ptr, int header_buffer_size, const <a class="el" href="structTxPayloadState.html">TxPayloadState</a> *payload_state_ptr)</td></tr>
<tr class="memdesc:a4454dd608d4531d45f903c0701e8d1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of function used for protocol version VTable API. <br /></td></tr>
<tr class="separator:a4454dd608d4531d45f903c0701e8d1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756834e66597e481307d2026335edcd6" id="r_a756834e66597e481307d2026335edcd6"><td class="memItemLeft" align="right" valign="top"><a id="a756834e66597e481307d2026335edcd6" name="a756834e66597e481307d2026335edcd6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>VtblPayloadPacketRxReorderInfo</b>) (const <a class="el" href="structCdiRawPacketHeader.html">CdiRawPacketHeader</a> *header_ptr, <a class="el" href="structCdiPacketRxReorderInfo.html">CdiPacketRxReorderInfo</a> *ret_info_ptr)</td></tr>
<tr class="memdesc:a756834e66597e481307d2026335edcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of function used for protocol version VTable API. <br /></td></tr>
<tr class="separator:a756834e66597e481307d2026335edcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d1b280e73bae01fdd8cb19b38d8947" id="r_ae9d1b280e73bae01fdd8cb19b38d8947"><td class="memItemLeft" align="right" valign="top"><a id="ae9d1b280e73bae01fdd8cb19b38d8947" name="ae9d1b280e73bae01fdd8cb19b38d8947"></a>
typedef <a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>VtblProbeHeaderDecode</b>) (const void *encoded_data_ptr, int encoded_data_size, <a class="el" href="structCdiDecodedProbeHeader.html">CdiDecodedProbeHeader</a> *dest_header_ptr)</td></tr>
<tr class="memdesc:ae9d1b280e73bae01fdd8cb19b38d8947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of function used for protocol version VTable API. <br /></td></tr>
<tr class="separator:ae9d1b280e73bae01fdd8cb19b38d8947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14348a40adcd782d8ec5481db76484f0" id="r_a14348a40adcd782d8ec5481db76484f0"><td class="memItemLeft" align="right" valign="top"><a id="a14348a40adcd782d8ec5481db76484f0" name="a14348a40adcd782d8ec5481db76484f0"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>VtblProbeHeaderEncode</b>) (const <a class="el" href="structCdiDecodedProbeHeader.html">CdiDecodedProbeHeader</a> *state_ptr, <a class="el" href="structCdiRawProbeHeader.html">CdiRawProbeHeader</a> *dest_header_ptr)</td></tr>
<tr class="memdesc:a14348a40adcd782d8ec5481db76484f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of function used for protocol version VTable API. <br /></td></tr>
<tr class="separator:a14348a40adcd782d8ec5481db76484f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa548bed9cef20b3d1b13193db9add047" id="r_aa548bed9cef20b3d1b13193db9add047"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa548bed9cef20b3d1b13193db9add047">ProbeCommand</a> { <br />
&#160;&#160;<a class="el" href="#aa548bed9cef20b3d1b13193db9add047acaaf2df0cc8243393162e7ff84f2c185">kProbeCommandReset</a> = 1
, <a class="el" href="#aa548bed9cef20b3d1b13193db9add047a3514f095b18a18970932ae0c161d0a6d">kProbeCommandPing</a>
, <a class="el" href="#aa548bed9cef20b3d1b13193db9add047a935cbe9d2892b04c66bd17439c42417a">kProbeCommandConnected</a>
, <a class="el" href="#aa548bed9cef20b3d1b13193db9add047a0a0f6b9c58a1a339855399f32a14900e">kProbeCommandAck</a>
, <br />
&#160;&#160;<a class="el" href="#aa548bed9cef20b3d1b13193db9add047ad314b1c1fe7d6975a6997dd0cf1bd53c">kProbeCommandProtocolVersion</a>
<br />
 }</td></tr>
<tr class="memdesc:aa548bed9cef20b3d1b13193db9add047"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enumeration is used in the ProbePacketHeader structure to indicate a probe command. NOTE: Any changes made here MUST also be made to "probe_command_key_array".  <a href="#aa548bed9cef20b3d1b13193db9add047">More...</a><br /></td></tr>
<tr class="separator:aa548bed9cef20b3d1b13193db9add047"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a097172303b59f473cabbd905922752b3" id="r_a097172303b59f473cabbd905922752b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a097172303b59f473cabbd905922752b3">ProtocolVersionSet</a> (const <a class="el" href="structCdiProtocolVersionNumber.html">CdiProtocolVersionNumber</a> *remote_version_ptr, <a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> *ret_handle_ptr)</td></tr>
<tr class="memdesc:a097172303b59f473cabbd905922752b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a protocol version using the specified remote protocol version. The version is compared against the versions in the current SDK and the most recent compatible version is returned.  <br /></td></tr>
<tr class="separator:a097172303b59f473cabbd905922752b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16147e75a832294cb70f16a447922210" id="r_a16147e75a832294cb70f16a447922210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16147e75a832294cb70f16a447922210">ProtocolVersionSetLegacy</a> (<a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> *ret_handle_ptr)</td></tr>
<tr class="memdesc:a16147e75a832294cb70f16a447922210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a protocol version using the legacy version 1, which is compatible will all SDK versions.  <br /></td></tr>
<tr class="separator:a16147e75a832294cb70f16a447922210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36916e5b37b37b9c4582d678013fdfa" id="r_aa36916e5b37b37b9c4582d678013fdfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa36916e5b37b37b9c4582d678013fdfa">ProtocolVersionDestroy</a> (<a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> protocol_handle)</td></tr>
<tr class="memdesc:aa36916e5b37b37b9c4582d678013fdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freeup resources used by a protocol.  <br /></td></tr>
<tr class="separator:aa36916e5b37b37b9c4582d678013fdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3887f9a62f9ec20d2063d96bff154ab" id="r_af3887f9a62f9ec20d2063d96bff154ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3887f9a62f9ec20d2063d96bff154ab">ProtocolPayloadHeaderDecode</a> (<a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> protocol_handle, void *encoded_data_ptr, int encoded_data_size, <a class="el" href="structCdiDecodedPacketHeader.html">CdiDecodedPacketHeader</a> *dest_header_ptr)</td></tr>
<tr class="memdesc:af3887f9a62f9ec20d2063d96bff154ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an encoded raw header into a header structure that is protocol version independent.  <br /></td></tr>
<tr class="separator:af3887f9a62f9ec20d2063d96bff154ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04eda469f0d14489c50d015e27c820b" id="r_ab04eda469f0d14489c50d015e27c820b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab04eda469f0d14489c50d015e27c820b">ProtocolPayloadHeaderInit</a> (<a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> protocol_handle, void *header_ptr, int header_buffer_size, const <a class="el" href="structTxPayloadState.html">TxPayloadState</a> *payload_state_ptr)</td></tr>
<tr class="memdesc:ab04eda469f0d14489c50d015e27c820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize raw packet encoded header data using the specified protocol and packet state data.  <br /></td></tr>
<tr class="separator:ab04eda469f0d14489c50d015e27c820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e4379a109fd11409144d2490940472" id="r_ac0e4379a109fd11409144d2490940472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0e4379a109fd11409144d2490940472">ProtocolPayloadPacketRxReorderInfo</a> (<a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> protocol_handle, const <a class="el" href="structCdiRawPacketHeader.html">CdiRawPacketHeader</a> *header_ptr, <a class="el" href="structCdiPacketRxReorderInfo.html">CdiPacketRxReorderInfo</a> *ret_info_ptr)</td></tr>
<tr class="memdesc:ac0e4379a109fd11409144d2490940472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rx reorder information for the specified packet.  <br /></td></tr>
<tr class="separator:ac0e4379a109fd11409144d2490940472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5748f73c168a861697b956afa78fdd52" id="r_a5748f73c168a861697b956afa78fdd52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5748f73c168a861697b956afa78fdd52">ProtocolProbeHeaderDecode</a> (const void *encoded_data_ptr, int encoded_data_size, <a class="el" href="structCdiDecodedProbeHeader.html">CdiDecodedProbeHeader</a> *dest_header_ptr)</td></tr>
<tr class="memdesc:a5748f73c168a861697b956afa78fdd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an encoded raw probe header into a header structure that is protocol version independent.  <br /></td></tr>
<tr class="separator:a5748f73c168a861697b956afa78fdd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9095ab0d6b59bcc52a2e58dbab09658" id="r_ae9095ab0d6b59bcc52a2e58dbab09658"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9095ab0d6b59bcc52a2e58dbab09658">ProtocolProbeHeaderEncode</a> (<a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> protocol_handle, <a class="el" href="structCdiDecodedProbeHeader.html">CdiDecodedProbeHeader</a> *src_header_ptr, <a class="el" href="structCdiRawProbeHeader.html">CdiRawProbeHeader</a> *dest_header_ptr)</td></tr>
<tr class="memdesc:ae9095ab0d6b59bcc52a2e58dbab09658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode raw payload header data using the specified protocol and probe state data.  <br /></td></tr>
<tr class="separator:ae9095ab0d6b59bcc52a2e58dbab09658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The declarations in this header file correspond to the definitions in protcol.c. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a8b726dbfdf7d61bf07a8cac967064f6e" name="a8b726dbfdf7d61bf07a8cac967064f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b726dbfdf7d61bf07a8cac967064f6e">&#9670;&#160;</a></span>TxPayloadState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct TxPayloadState TxPayloadState</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward reference of structure to create pointers later. </p>
<p>Forward reference of structure to allow pointer creation. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa548bed9cef20b3d1b13193db9add047" name="aa548bed9cef20b3d1b13193db9add047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa548bed9cef20b3d1b13193db9add047">&#9670;&#160;</a></span>ProbeCommand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aa548bed9cef20b3d1b13193db9add047">ProbeCommand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enumeration is used in the ProbePacketHeader structure to indicate a probe command. NOTE: Any changes made here MUST also be made to "probe_command_key_array". </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa548bed9cef20b3d1b13193db9add047acaaf2df0cc8243393162e7ff84f2c185" name="aa548bed9cef20b3d1b13193db9add047acaaf2df0cc8243393162e7ff84f2c185"></a>kProbeCommandReset&#160;</td><td class="fielddoc"><p>Request to reset the connection. Start with 1 so no commands have the value 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa548bed9cef20b3d1b13193db9add047a3514f095b18a18970932ae0c161d0a6d" name="aa548bed9cef20b3d1b13193db9add047a3514f095b18a18970932ae0c161d0a6d"></a>kProbeCommandPing&#160;</td><td class="fielddoc"><p>Request to ping the connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa548bed9cef20b3d1b13193db9add047a935cbe9d2892b04c66bd17439c42417a" name="aa548bed9cef20b3d1b13193db9add047a935cbe9d2892b04c66bd17439c42417a"></a>kProbeCommandConnected&#160;</td><td class="fielddoc"><p>Notification that connection has been established (probe has completed). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa548bed9cef20b3d1b13193db9add047a0a0f6b9c58a1a339855399f32a14900e" name="aa548bed9cef20b3d1b13193db9add047a0a0f6b9c58a1a339855399f32a14900e"></a>kProbeCommandAck&#160;</td><td class="fielddoc"><p><a class="el" href="structPacket.html">Packet</a> is an ACK response to a previously sent command. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa548bed9cef20b3d1b13193db9add047ad314b1c1fe7d6975a6997dd0cf1bd53c" name="aa548bed9cef20b3d1b13193db9add047ad314b1c1fe7d6975a6997dd0cf1bd53c"></a>kProbeCommandProtocolVersion&#160;</td><td class="fielddoc"><p><a class="el" href="structPacket.html">Packet</a> contains protocol version of sender. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af3887f9a62f9ec20d2063d96bff154ab" name="af3887f9a62f9ec20d2063d96bff154ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3887f9a62f9ec20d2063d96bff154ab">&#9670;&#160;</a></span>ProtocolPayloadHeaderDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolPayloadHeaderDecode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a></td>          <td class="paramname"><span class="paramname"><em>protocol_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>encoded_data_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>encoded_data_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCdiDecodedPacketHeader.html">CdiDecodedPacketHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>dest_header_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an encoded raw header into a header structure that is protocol version independent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol_handle</td><td>Handle of protocol version. </td></tr>
    <tr><td class="paramname">encoded_data_ptr</td><td>Pointer to encoder header data. </td></tr>
    <tr><td class="paramname">encoded_data_size</td><td>Size of encoded header data in bytes. </td></tr>
    <tr><td class="paramname">dest_header_ptr</td><td>Address where to write decoded header data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab04eda469f0d14489c50d015e27c820b" name="ab04eda469f0d14489c50d015e27c820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04eda469f0d14489c50d015e27c820b">&#9670;&#160;</a></span>ProtocolPayloadHeaderInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ProtocolPayloadHeaderInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a></td>          <td class="paramname"><span class="paramname"><em>protocol_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>header_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>header_buffer_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTxPayloadState.html">TxPayloadState</a> *</td>          <td class="paramname"><span class="paramname"><em>payload_state_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize raw packet encoded header data using the specified protocol and packet state data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol_handle</td><td>Handle of protocol version. </td></tr>
    <tr><td class="paramname">header_ptr</td><td>Address where to write raw packet header. </td></tr>
    <tr><td class="paramname">header_buffer_size</td><td>Size of header buffer in bytes. </td></tr>
    <tr><td class="paramname">payload_state_ptr</td><td>Pointer to TX payload state data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of payload header in bytes. </dd></dl>

</div>
</div>
<a id="ac0e4379a109fd11409144d2490940472" name="ac0e4379a109fd11409144d2490940472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e4379a109fd11409144d2490940472">&#9670;&#160;</a></span>ProtocolPayloadPacketRxReorderInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolPayloadPacketRxReorderInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a></td>          <td class="paramname"><span class="paramname"><em>protocol_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCdiRawPacketHeader.html">CdiRawPacketHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>header_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCdiPacketRxReorderInfo.html">CdiPacketRxReorderInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_info_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Rx reorder information for the specified packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol_handle</td><td>Handle of protocol version. </td></tr>
    <tr><td class="paramname">header_ptr</td><td>Pointer to raw encoded packet header to get Rx reorder information from. </td></tr>
    <tr><td class="paramname">ret_info_ptr</td><td>Address where to write returned Rx reorder info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5748f73c168a861697b956afa78fdd52" name="a5748f73c168a861697b956afa78fdd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5748f73c168a861697b956afa78fdd52">&#9670;&#160;</a></span>ProtocolProbeHeaderDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a> ProtocolProbeHeaderDecode </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>encoded_data_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>encoded_data_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCdiDecodedProbeHeader.html">CdiDecodedProbeHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>dest_header_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an encoded raw probe header into a header structure that is protocol version independent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoded_data_ptr</td><td>Pointer to encoder header data. NOTE: The caller must not free this data until done with the decoded version, since some of the decoded values contain pointers to it. </td></tr>
    <tr><td class="paramname">encoded_data_size</td><td>Size of encoded header data in bytes. </td></tr>
    <tr><td class="paramname">dest_header_ptr</td><td>Address where to write decoded header data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the CdiReturnStatus enumeration. </dd></dl>

</div>
</div>
<a id="ae9095ab0d6b59bcc52a2e58dbab09658" name="ae9095ab0d6b59bcc52a2e58dbab09658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9095ab0d6b59bcc52a2e58dbab09658">&#9670;&#160;</a></span>ProtocolProbeHeaderEncode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ProtocolProbeHeaderEncode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a></td>          <td class="paramname"><span class="paramname"><em>protocol_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCdiDecodedProbeHeader.html">CdiDecodedProbeHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>src_header_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCdiRawProbeHeader.html">CdiRawProbeHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>dest_header_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode raw payload header data using the specified protocol and probe state data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol_handle</td><td>Handle of protocol version. </td></tr>
    <tr><td class="paramname">src_header_ptr</td><td>Pointer to source header data. </td></tr>
    <tr><td class="paramname">dest_header_ptr</td><td>Address where to write raw probe header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of protocol header in bytes. </dd></dl>

</div>
</div>
<a id="aa36916e5b37b37b9c4582d678013fdfa" name="aa36916e5b37b37b9c4582d678013fdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36916e5b37b37b9c4582d678013fdfa">&#9670;&#160;</a></span>ProtocolVersionDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolVersionDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a></td>          <td class="paramname"><span class="paramname"><em>protocol_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freeup resources used by a protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol_handle</td><td>Handle of protocol version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a097172303b59f473cabbd905922752b3" name="a097172303b59f473cabbd905922752b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097172303b59f473cabbd905922752b3">&#9670;&#160;</a></span>ProtocolVersionSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolVersionSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCdiProtocolVersionNumber.html">CdiProtocolVersionNumber</a> *</td>          <td class="paramname"><span class="paramname"><em>remote_version_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a protocol version using the specified remote protocol version. The version is compared against the versions in the current SDK and the most recent compatible version is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_version_ptr</td><td>Pointer to remote's protocol version. </td></tr>
    <tr><td class="paramname">ret_handle_ptr</td><td>Address where to write returned protocol handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16147e75a832294cb70f16a447922210" name="a16147e75a832294cb70f16a447922210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16147e75a832294cb70f16a447922210">&#9670;&#160;</a></span>ProtocolVersionSetLegacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProtocolVersionSetLegacy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="payload_8h.html#a57182d381a4d1be37bfa792b77553e91">CdiProtocolHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_handle_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a protocol version using the legacy version 1, which is compatible will all SDK versions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret_handle_ptr</td><td>Address where to write returned protocol handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
