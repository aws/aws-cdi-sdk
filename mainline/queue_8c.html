<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: src/common/src/queue.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fdedb0aba14d44ce9d99bc100e026e6a.html">common</a></li><li class="navelem"><a class="el" href="dir_93d6226967e8e187d15fc6a8b74b4a3e.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">queue.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains definitions and implementation for a queue that allows a reader thread to use <a class="el" href="#aa7e2ddb9798211952858d246d00d31fa">CdiQueuePop()</a> and a writer thread to use CdiQuenePush(). No resource locks are used, so the functions are not reetrant. Blocking <a class="el" href="#aa0a56d1b1e661277e8dcbec3d23a0385">CdiQueuePopWait()</a> and <a class="el" href="#ae618a3a48e234e05ede28bda5e573f0d">CdiQueuePushWait()</a> queue API functions can be used if enabled using the signal_mode parameter of the <a class="el" href="#abcc6740e423a12297412ab004ab3673c" title="Creates a queue. Memory is allocated by this function.">CdiQueueCreate()</a> API fucntion. NOTE: The API functions only support a single-producer/single-consumer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cdi__queue__api_8h_source.html">cdi_queue_api.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cdi__logger__api_8h_source.html">cdi_logger_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="singly__linked__list__api_8h_source.html">singly_linked_list_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="utilities__api_8h_source.html">utilities_api.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQueueItem.html">QueueItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure represents a single queue item.  <a href="structQueueItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQueueState.html">QueueState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold state data for a single queue.  <a href="structQueueState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a13325339862d9b5fdd3de22f55f82423" id="r_a13325339862d9b5fdd3de22f55f82423"><td class="memItemLeft" align="right" valign="top"><a id="a13325339862d9b5fdd3de22f55f82423" name="a13325339862d9b5fdd3de22f55f82423"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_QUEUE_NAME_LENGTH</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="memdesc:a13325339862d9b5fdd3de22f55f82423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the queue name that is stored internally in <a class="el" href="queue_8c.html" title="This file contains definitions and implementation for a queue that allows a reader thread to use CdiQ...">queue.c</a>. <br /></td></tr>
<tr class="separator:a13325339862d9b5fdd3de22f55f82423"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0bc86a7d66e17164fa46e5bdf1bc0beb" id="r_a0bc86a7d66e17164fa46e5bdf1bc0beb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structQueueItem.html">QueueItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc86a7d66e17164fa46e5bdf1bc0beb">GetQueueItemFromItemDataPointer</a> (const void *item_data_ptr)</td></tr>
<tr class="memdesc:a0bc86a7d66e17164fa46e5bdf1bc0beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the item's parent object (<a class="el" href="structQueueItem.html" title="This structure represents a single queue item.">QueueItem</a>).  <br /></td></tr>
<tr class="separator:a0bc86a7d66e17164fa46e5bdf1bc0beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a0cdf125906c4cd2694213940d94f7" id="r_a40a0cdf125906c4cd2694213940d94f7"><td class="memItemLeft" align="right" valign="top">static uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40a0cdf125906c4cd2694213940d94f7">GetDataItemFromListEntry</a> (<a class="el" href="structCdiSinglyLinkedListEntry.html">CdiSinglyLinkedListEntry</a> *entry_item_ptr)</td></tr>
<tr class="memdesc:a40a0cdf125906c4cd2694213940d94f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the data buffer related to the linked list entry of the item.  <br /></td></tr>
<tr class="separator:a40a0cdf125906c4cd2694213940d94f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ece97c6cdbfb5cbd3cfb7a2a990c09" id="r_ab5ece97c6cdbfb5cbd3cfb7a2a990c09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5ece97c6cdbfb5cbd3cfb7a2a990c09">AddEntriesToBuffers</a> (<a class="el" href="structQueueState.html">QueueState</a> *state_ptr, uint8_t *queue_item_array, int item_count)</td></tr>
<tr class="memdesc:ab5ece97c6cdbfb5cbd3cfb7a2a990c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds queue item array to allocated buffer and insert into the circular item list at the current write pointer location.  <br /></td></tr>
<tr class="separator:ab5ece97c6cdbfb5cbd3cfb7a2a990c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e9a24aae8122b798a2cb539b3dcefa" id="r_a08e9a24aae8122b798a2cb539b3dcefa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e9a24aae8122b798a2cb539b3dcefa">QueueIncrease</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle_ptr)</td></tr>
<tr class="memdesc:a08e9a24aae8122b798a2cb539b3dcefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the size of a queue, if it is growable.  <br /></td></tr>
<tr class="separator:a08e9a24aae8122b798a2cb539b3dcefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cf05071d17e60a8ebb9e76d0dd7f64" id="r_a01cf05071d17e60a8ebb9e76d0dd7f64"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01cf05071d17e60a8ebb9e76d0dd7f64">WaitForSignals</a> (<a class="el" href="structCdiSinglyLinkedListEntry.html">CdiSinglyLinkedListEntry</a> *volatile *entry_change_ptr, <a class="el" href="structCdiSinglyLinkedListEntry.html">CdiSinglyLinkedListEntry</a> *entry_static_ptr, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> wait_signal, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *cancel_wait_signal_array, int num_signals, uint32_t *ret_signal_index_ptr)</td></tr>
<tr class="separator:a01cf05071d17e60a8ebb9e76d0dd7f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc6740e423a12297412ab004ab3673c" id="r_abcc6740e423a12297412ab004ab3673c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcc6740e423a12297412ab004ab3673c">CdiQueueCreate</a> (const char *name_str, uint32_t item_count, uint32_t grow_count, uint32_t max_grow_count, uint32_t item_byte_size, <a class="el" href="cdi__queue__api_8h.html#a1c8aae01d621bd312e04c46d5d4a252b">CdiQueueSignalMode</a> signal_mode, <a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> *ret_handle)</td></tr>
<tr class="memdesc:abcc6740e423a12297412ab004ab3673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a queue. Memory is allocated by this function.  <br /></td></tr>
<tr class="separator:abcc6740e423a12297412ab004ab3673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e2ddb9798211952858d246d00d31fa" id="r_aa7e2ddb9798211952858d246d00d31fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7e2ddb9798211952858d246d00d31fa">CdiQueuePop</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, void *item_dest_ptr)</td></tr>
<tr class="separator:aa7e2ddb9798211952858d246d00d31fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a56d1b1e661277e8dcbec3d23a0385" id="r_aa0a56d1b1e661277e8dcbec3d23a0385"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0a56d1b1e661277e8dcbec3d23a0385">CdiQueuePopWait</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> abort_wait_signal, void *item_dest_ptr)</td></tr>
<tr class="separator:aa0a56d1b1e661277e8dcbec3d23a0385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c8d78869b1b2e63b1a5696eae286b2" id="r_a20c8d78869b1b2e63b1a5696eae286b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c8d78869b1b2e63b1a5696eae286b2">CdiQueuePopWaitMultiple</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *abort_wait_signal_array, int num_signals, uint32_t *ret_signal_index_ptr, void *item_dest_ptr)</td></tr>
<tr class="separator:a20c8d78869b1b2e63b1a5696eae286b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0911fbda16aa0396388343376305b01" id="r_ae0911fbda16aa0396388343376305b01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0911fbda16aa0396388343376305b01">CdiQueuePush</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, const void *data_ptr)</td></tr>
<tr class="separator:ae0911fbda16aa0396388343376305b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae618a3a48e234e05ede28bda5e573f0d" id="r_ae618a3a48e234e05ede28bda5e573f0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae618a3a48e234e05ede28bda5e573f0d">CdiQueuePushWait</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> abort_wait_signal, const void *item_ptr)</td></tr>
<tr class="separator:ae618a3a48e234e05ede28bda5e573f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e9337ccd0d70e8a07ca432470dfdf9" id="r_aa3e9337ccd0d70e8a07ca432470dfdf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3e9337ccd0d70e8a07ca432470dfdf9">CdiQueuePushWaitMultiple</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *signal_array, int num_signals, uint32_t *ret_signal_index_ptr, const void *item_ptr)</td></tr>
<tr class="separator:aa3e9337ccd0d70e8a07ca432470dfdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2376061a2111e07eb9ae066d8908eeb" id="r_ae2376061a2111e07eb9ae066d8908eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2376061a2111e07eb9ae066d8908eeb">CdiQueueFlush</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:ae2376061a2111e07eb9ae066d8908eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599cd879e421665a6a670deb19ea7ccc" id="r_a599cd879e421665a6a670deb19ea7ccc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a599cd879e421665a6a670deb19ea7ccc">CdiQueueIsEmpty</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a599cd879e421665a6a670deb19ea7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3f0fe2b074ad137b5837a2cc384084" id="r_a6e3f0fe2b074ad137b5837a2cc384084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e3f0fe2b074ad137b5837a2cc384084">CdiQueueGetPushWaitSignal</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a6e3f0fe2b074ad137b5837a2cc384084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5f072c5c3e86bfac311c7591538b75" id="r_a3a5f072c5c3e86bfac311c7591538b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a5f072c5c3e86bfac311c7591538b75">CdiQueueGetPopWaitSignal</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a3a5f072c5c3e86bfac311c7591538b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1467c6d6d1bea96fcc6321290e07e35" id="r_ad1467c6d6d1bea96fcc6321290e07e35"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1467c6d6d1bea96fcc6321290e07e35">CdiQueueGetName</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:ad1467c6d6d1bea96fcc6321290e07e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9722f10ff210bb94d46699a69b6afed9" id="r_a9722f10ff210bb94d46699a69b6afed9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9722f10ff210bb94d46699a69b6afed9">CdiQueueDestroy</a> (<a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a9722f10ff210bb94d46699a69b6afed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains definitions and implementation for a queue that allows a reader thread to use <a class="el" href="#aa7e2ddb9798211952858d246d00d31fa">CdiQueuePop()</a> and a writer thread to use CdiQuenePush(). No resource locks are used, so the functions are not reetrant. Blocking <a class="el" href="#aa0a56d1b1e661277e8dcbec3d23a0385">CdiQueuePopWait()</a> and <a class="el" href="#ae618a3a48e234e05ede28bda5e573f0d">CdiQueuePushWait()</a> queue API functions can be used if enabled using the signal_mode parameter of the <a class="el" href="#abcc6740e423a12297412ab004ab3673c" title="Creates a queue. Memory is allocated by this function.">CdiQueueCreate()</a> API fucntion. NOTE: The API functions only support a single-producer/single-consumer. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab5ece97c6cdbfb5cbd3cfb7a2a990c09" name="ab5ece97c6cdbfb5cbd3cfb7a2a990c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ece97c6cdbfb5cbd3cfb7a2a990c09">&#9670;&#160;</a></span>AddEntriesToBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AddEntriesToBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueueState.html">QueueState</a> *</td>          <td class="paramname"><span class="paramname"><em>state_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>queue_item_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>item_count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds queue item array to allocated buffer and insert into the circular item list at the current write pointer location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_ptr</td><td>Queue state information. </td></tr>
    <tr><td class="paramname">queue_item_array</td><td>The array being attached. </td></tr>
    <tr><td class="paramname">item_count</td><td>Number of items in array to be attached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcc6740e423a12297412ab004ab3673c" name="abcc6740e423a12297412ab004ab3673c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc6740e423a12297412ab004ab3673c">&#9670;&#160;</a></span>CdiQueueCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueueCreate </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>item_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>grow_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_grow_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>item_byte_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#a1c8aae01d621bd312e04c46d5d4a252b">CdiQueueSignalMode</a></td>          <td class="paramname"><span class="paramname"><em>signal_mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a queue. Memory is allocated by this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_str</td><td>Name of queue. </td></tr>
    <tr><td class="paramname">item_count</td><td>Number of items in the queue. </td></tr>
    <tr><td class="paramname">grow_count</td><td>Number of items that a queue may be increased by if the initial size requested is inadequate. </td></tr>
    <tr><td class="paramname">max_grow_count</td><td>Maximum number of times a queue may be increased before an error occurs. </td></tr>
    <tr><td class="paramname">item_byte_size</td><td>Size of each item in bytes. </td></tr>
    <tr><td class="paramname">signal_mode</td><td>Sets type of signals and optional locking, if any, to use. </td></tr>
    <tr><td class="paramname">ret_handle_ptr</td><td>Pointer to returned handle of the new queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a9722f10ff210bb94d46699a69b6afed9" name="a9722f10ff210bb94d46699a69b6afed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9722f10ff210bb94d46699a69b6afed9">&#9670;&#160;</a></span>CdiQueueDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiQueueDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2376061a2111e07eb9ae066d8908eeb" name="ae2376061a2111e07eb9ae066d8908eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2376061a2111e07eb9ae066d8908eeb">&#9670;&#160;</a></span>CdiQueueFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiQueueFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drain all items in the queue. NOTE: The caller must ensure that other threads cannot use either of the <a class="el" href="cdi__queue__api_8h.html#a2b85d94d83745d50b6ccf6f254be15da">CdiQueuePop()</a> or <a class="el" href="cdi__queue__api_8h.html#a1056fe5c8b539246f781c99b7016618e">CdiQueuePush()</a> API functions while using this API function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1467c6d6d1bea96fcc6321290e07e35" name="ad1467c6d6d1bea96fcc6321290e07e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1467c6d6d1bea96fcc6321290e07e35">&#9670;&#160;</a></span>CdiQueueGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CdiQueueGetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get name of the queue that was defined when it was created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a5f072c5c3e86bfac311c7591538b75" name="a3a5f072c5c3e86bfac311c7591538b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5f072c5c3e86bfac311c7591538b75">&#9670;&#160;</a></span>CdiQueueGetPopWaitSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> CdiQueueGetPopWaitSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If kQueueSignalPopWait or kQueueSignalBoth was specified when the queue was created, this function returns the signal that got set whenever an item is pushed on the queue. It is used to wait in <a class="el" href="cdi__queue__api_8h.html#a1ff1c51f0b23fe1813a41bc70012b352">CdiQueuePopWait()</a>. Otherwise, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e3f0fe2b074ad137b5837a2cc384084" name="a6e3f0fe2b074ad137b5837a2cc384084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3f0fe2b074ad137b5837a2cc384084">&#9670;&#160;</a></span>CdiQueueGetPushWaitSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> CdiQueueGetPushWaitSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If kQueueSignalPushWait or kQueueSignalBoth was specified when the queue was created, this function returns the signal that got set whenever an item is popped off the queue. It is used to wait in <a class="el" href="cdi__queue__api_8h.html#af5a0f9915733f135f6586044e4cf2ed9">CdiQueuePushWait()</a>. Otherwise, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a599cd879e421665a6a670deb19ea7ccc" name="a599cd879e421665a6a670deb19ea7ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599cd879e421665a6a670deb19ea7ccc">&#9670;&#160;</a></span>CdiQueueIsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueueIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the queue is empty, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="aa7e2ddb9798211952858d246d00d31fa" name="aa7e2ddb9798211952858d246d00d31fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e2ddb9798211952858d246d00d31fa">&#9670;&#160;</a></span>CdiQueuePop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueuePop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item_dest_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop an item from the queue buffer and copy to item_dest_ptr. If the queue is empty, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">item_dest_ptr</td><td>Pointer to buffer where to copy the item to. Size of buffer must be large enough to hold the data. Data size was set when the queue was created (see item_byte_size). This is an optional parameter, you can pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is empty). </dd></dl>

</div>
</div>
<a id="aa0a56d1b1e661277e8dcbec3d23a0385" name="aa0a56d1b1e661277e8dcbec3d23a0385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a56d1b1e661277e8dcbec3d23a0385">&#9670;&#160;</a></span>CdiQueuePopWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueuePopWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item_dest_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop an item from the queue buffer and copy to the address item_dest_ptr. If the queue is empty, wait until the specified timeout expires or the optional signal gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely </td></tr>
    <tr><td class="paramname">abort_wait_signal</td><td>Signal used to abort waiting. </td></tr>
    <tr><td class="paramname">item_dest_ptr</td><td>Pointer to buffer where to copy the item to. Size of buffer must be large enough to hold the data. Data size was set when the queue was created (see item_byte_size). This is an optional parameter. Pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is empty and timeout expired or signal got set). </dd></dl>

</div>
</div>
<a id="a20c8d78869b1b2e63b1a5696eae286b2" name="a20c8d78869b1b2e63b1a5696eae286b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c8d78869b1b2e63b1a5696eae286b2">&#9670;&#160;</a></span>CdiQueuePopWaitMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueuePopWaitMultiple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_signals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ret_signal_index_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item_dest_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop an item from the queue buffer and copy to the address item_dest_ptr. If the queue is empty, wait until the specified timeout expires or one of the signals in the signal array gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">abort_wait_signal_array</td><td>Array of signals used to abort waiting. </td></tr>
    <tr><td class="paramname">num_signals</td><td>Number of signals in the array. </td></tr>
    <tr><td class="paramname">ret_signal_index_ptr</td><td>Pointer to the returned signal index that caused the wait to abort. If a timeout occurred, CDI_OS_SIG_TIMEOUT is returned. This is an optional parameter. Pass NULL if you don't care. </td></tr>
    <tr><td class="paramname">item_dest_ptr</td><td>Pointer to buffer where to copy the item to. Size of buffer must be large enough to hold the data. Data size was set when the queue was created (see item_byte_size). This is an optional parameter. Pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is empty and timeout expired or signal got set). </dd></dl>

</div>
</div>
<a id="ae0911fbda16aa0396388343376305b01" name="ae0911fbda16aa0396388343376305b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0911fbda16aa0396388343376305b01">&#9670;&#160;</a></span>CdiQueuePush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueuePush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>item_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push an item on the queue. If the queue is full, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>Pointer where to copy the item from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is full). </dd></dl>

</div>
</div>
<a id="ae618a3a48e234e05ede28bda5e573f0d" name="ae618a3a48e234e05ede28bda5e573f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae618a3a48e234e05ede28bda5e573f0d">&#9670;&#160;</a></span>CdiQueuePushWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueuePushWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>item_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push an item on the queue. If the queue is full, wait until the specified timeout expires or the optional signal gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">abort_wait_signal</td><td>Signal used to abort waiting. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>Address where to copy the item from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is full and timeout expired or signal got set). </dd></dl>

</div>
</div>
<a id="aa3e9337ccd0d70e8a07ca432470dfdf9" name="aa3e9337ccd0d70e8a07ca432470dfdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e9337ccd0d70e8a07ca432470dfdf9">&#9670;&#160;</a></span>CdiQueuePushWaitMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiQueuePushWaitMultiple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_signals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ret_signal_index_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>item_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push an item on the queue. If the queue is full, wait until the specified timeout expires or one of the signals in the signal array gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">abort_wait_signal_array</td><td>Array of signals used to abort waiting. </td></tr>
    <tr><td class="paramname">num_signals</td><td>Number of signals in the array. </td></tr>
    <tr><td class="paramname">ret_signal_index_ptr</td><td>Pointer to the returned signal index that caused the wait to abort. If a timeout occurred, CDI_OS_SIG_TIMEOUT is returned. This is an optional parameter. Pass NULL if you don't care. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>Address where to copy the item from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is full and timeout expired or signal got set). </dd></dl>

</div>
</div>
<a id="a40a0cdf125906c4cd2694213940d94f7" name="a40a0cdf125906c4cd2694213940d94f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a0cdf125906c4cd2694213940d94f7">&#9670;&#160;</a></span>GetDataItemFromListEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t * GetDataItemFromListEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCdiSinglyLinkedListEntry.html">CdiSinglyLinkedListEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry_item_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the data buffer related to the linked list entry of the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_item_ptr</td><td>Pointer to queue item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to item's data buffer. </dd></dl>

</div>
</div>
<a id="a0bc86a7d66e17164fa46e5bdf1bc0beb" name="a0bc86a7d66e17164fa46e5bdf1bc0beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc86a7d66e17164fa46e5bdf1bc0beb">&#9670;&#160;</a></span>GetQueueItemFromItemDataPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structQueueItem.html">QueueItem</a> * GetQueueItemFromItemDataPointer </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>item_data_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the item's parent object (<a class="el" href="structQueueItem.html" title="This structure represents a single queue item.">QueueItem</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_data_ptr</td><td>Pointer to object being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to parent of object. </dd></dl>

</div>
</div>
<a id="a08e9a24aae8122b798a2cb539b3dcefa" name="a08e9a24aae8122b798a2cb539b3dcefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e9a24aae8122b798a2cb539b3dcefa">&#9670;&#160;</a></span>QueueIncrease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool QueueIncrease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the size of a queue, if it is growable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_ptr</td><td>Pointer to queue handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful true is returned, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a01cf05071d17e60a8ebb9e76d0dd7f64" name="a01cf05071d17e60a8ebb9e76d0dd7f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cf05071d17e60a8ebb9e76d0dd7f64">&#9670;&#160;</a></span>WaitForSignals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool WaitForSignals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCdiSinglyLinkedListEntry.html">CdiSinglyLinkedListEntry</a> *volatile *</td>          <td class="paramname"><span class="paramname"><em>entry_change_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCdiSinglyLinkedListEntry.html">CdiSinglyLinkedListEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry_static_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>wait_signal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>cancel_wait_signal_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_signals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ret_signal_index_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait on either an empty or full queue. This is done by using the specified signal to wait for one of the queue read/write pointers to change. The wait can be aborted if any of the signals in the specified signal array get set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_change_ptr</td><td>Pointer to either the read or write pointer that is going to be changed outside the scope of this function. The contents of this pointer is made a volatile pointer to prevent the compiler from caching it in a register. It must be re-read from memory each time it is used in this function. </td></tr>
    <tr><td class="paramname">entry_static_ptr</td><td>Pointer to the read or write pointer that is not being changed. </td></tr>
    <tr><td class="paramname">wait_signal</td><td>Signal that is set when the address pointed to by entry_change_ptr changes. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Maximume time to wait, in milliseconds. </td></tr>
    <tr><td class="paramname">cancel_wait_signal_array</td><td>Array of wait cancel signals. </td></tr>
    <tr><td class="paramname">num_signals</td><td>Number of signals in the signal array. </td></tr>
    <tr><td class="paramname">ret_signal_index_ptr</td><td>Address where to write the returned index value of the signal that was set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the wait_signal was set and the contents of the address pointed to by entry_change_ptr changed. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
