<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: src/cdi/receive_buffer.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_440858bc2ff41f5ef15b020e90223871.html">cdi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">receive_buffer.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the implementation of the receive payload delay buffer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="receive__buffer_8h_source.html">receive_buffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cdi__os__api_8h_source.html">cdi_os_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="configuration_8h_source.html">configuration.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="internal_8h_source.html">internal.h</a>&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structReceiveBufferState.html">ReceiveBufferState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a60c2dcbbdf24ff1682687b0eec39d807" id="r_a60c2dcbbdf24ff1682687b0eec39d807"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60c2dcbbdf24ff1682687b0eec39d807">TaiNowMicroseconds</a> ()</td></tr>
<tr class="separator:a60c2dcbbdf24ff1682687b0eec39d807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac441fc92726efce2510254cfc8823f47" id="r_ac441fc92726efce2510254cfc8823f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__os__api_8h.html#af54546942bb91b024de5fae2a253564d">CDI_THREAD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac441fc92726efce2510254cfc8823f47">ReceiveBufferThread</a> (void *ptr)</td></tr>
<tr class="separator:ac441fc92726efce2510254cfc8823f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33db9a7bf2852109bf7eb75e840986f9" id="r_a33db9a7bf2852109bf7eb75e840986f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33db9a7bf2852109bf7eb75e840986f9">RxBufferInit</a> (<a class="el" href="cdi__log__api_8h.html#a96ba0529710acff2f9fc27ab3f43e7ae">CdiLogHandle</a> log_handle, <a class="el" href="cdi__pool__api_8h.html#a8e5912d6ac4676dac0adfb54cada3e03">CdiPoolHandle</a> error_message_pool, int buffer_delay_ms, int max_rx_payloads, <a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> output_queue_handle, <a class="el" href="private_8h.html#a59b37102301baff3ac58bc3daad35df5">ReceiveBufferHandle</a> *receive_buffer_handle_ptr, <a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> *input_queue_handle_ptr)</td></tr>
<tr class="separator:a33db9a7bf2852109bf7eb75e840986f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabd0acd49b5de5b2fbf285bc64839c5" id="r_aaabd0acd49b5de5b2fbf285bc64839c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaabd0acd49b5de5b2fbf285bc64839c5">RxBufferDestroy</a> (<a class="el" href="private_8h.html#a59b37102301baff3ac58bc3daad35df5">ReceiveBufferHandle</a> receive_buffer_handle)</td></tr>
<tr class="separator:aaabd0acd49b5de5b2fbf285bc64839c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3b811954807911f36c85a0c5978ee8eb" id="r_a3b811954807911f36c85a0c5978ee8eb"><td class="memItemLeft" align="right" valign="top"><a id="a3b811954807911f36c85a0c5978ee8eb" name="a3b811954807911f36c85a0c5978ee8eb"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxMissed</b> = 100</td></tr>
<tr class="memdesc:a3b811954807911f36c85a0c5978ee8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of consecutive payloads with time stamps out of the buffering window before offset is reset. <br /></td></tr>
<tr class="separator:a3b811954807911f36c85a0c5978ee8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the implementation of the receive payload delay buffer. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac441fc92726efce2510254cfc8823f47" name="ac441fc92726efce2510254cfc8823f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac441fc92726efce2510254cfc8823f47">&#9670;&#160;</a></span>ReceiveBufferThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__os__api_8h.html#af54546942bb91b024de5fae2a253564d">CDI_THREAD</a> ReceiveBufferThread </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main function for the receive delay buffer thread. It takes application callback structures from its input queue and sends them to the configured queue after a configurable delay based on the timestamps associated with each payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to thread specific data. In this case, a pointer to <a class="el" href="structReceiveBufferState.html">ReceiveBufferState</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is not used. </dd></dl>

</div>
</div>
<a id="aaabd0acd49b5de5b2fbf285bc64839c5" name="aaabd0acd49b5de5b2fbf285bc64839c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabd0acd49b5de5b2fbf285bc64839c5">&#9670;&#160;</a></span>RxBufferDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RxBufferDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="private_8h.html#a59b37102301baff3ac58bc3daad35df5">ReceiveBufferHandle</a></td>          <td class="paramname"><span class="paramname"><em>receive_buffer_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys the receive delay buffer specified by the handle. Payloads currently in the delay line are pushed to the output queue then the associate thread is shut down and joined and all resources allocated are freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receive_buffer_handle</td><td>Handle for the receive delay buffer to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33db9a7bf2852109bf7eb75e840986f9" name="a33db9a7bf2852109bf7eb75e840986f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33db9a7bf2852109bf7eb75e840986f9">&#9670;&#160;</a></span>RxBufferInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a> RxBufferInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__log__api_8h.html#a96ba0529710acff2f9fc27ab3f43e7ae">CdiLogHandle</a></td>          <td class="paramname"><span class="paramname"><em>log_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__pool__api_8h.html#a8e5912d6ac4676dac0adfb54cada3e03">CdiPoolHandle</a></td>          <td class="paramname"><span class="paramname"><em>error_message_pool</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>buffer_delay_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_rx_payloads</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>output_queue_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="private_8h.html#a59b37102301baff3ac58bc3daad35df5">ReceiveBufferHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>receive_buffer_handle_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__queue__api_8h.html#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>input_queue_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a receive delay buffer of the specified length, allocating all of the associated resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_handle</td><td>Handle to the logger to be used for any messages from this module. </td></tr>
    <tr><td class="paramname">error_message_pool</td><td>Handle to the pool to which error messages are to be freed in the event that an internal error prevents an input payload from being sent to the next stage. </td></tr>
    <tr><td class="paramname">buffer_delay_ms</td><td>The number of milliseconds to delay each payload, more or less, depending on each payload's timestamp value. </td></tr>
    <tr><td class="paramname">max_rx_payloads</td><td>The number of objects to allocate for holding payloads in the delay buffer. </td></tr>
    <tr><td class="paramname">output_queue_handle</td><td>Handle to which the receive delay buffer is to send payloads after they've been delayed. </td></tr>
    <tr><td class="paramname">receive_buffer_handle_ptr</td><td>Address of where to write the receive delay buffer's handle if successfully created. </td></tr>
    <tr><td class="paramname">input_queue_handle_ptr</td><td>Address to write the handle for the receive delay buffer's input queue if creation was successful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CdiReturnStatus kCdiStatusOk if the recieve delay buffer was successfully created or kCdiStatusNotEnoughMemory if memory was insufficient to allocate all of the required resources. </dd></dl>

</div>
</div>
<a id="a60c2dcbbdf24ff1682687b0eec39d807" name="a60c2dcbbdf24ff1682687b0eec39d807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c2dcbbdf24ff1682687b0eec39d807">&#9670;&#160;</a></span>TaiNowMicroseconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t TaiNowMicroseconds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to get the TAI based PTP timestamp and convert it to a single integer value representing the number of microseconds from the epoch.</p>
<dl class="section return"><dt>Returns</dt><dd>uint64_t The number of microseconds since the epoch according to the hosts real time clock. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
