<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: src/common/src/os_linux.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fdedb0aba14d44ce9d99bc100e026e6a.html">common</a></li><li class="navelem"><a class="el" href="dir_93d6226967e8e187d15fc6a8b74b4a3e.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">os_linux.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the Linux definitions for OS functions for creating/deleting threads, semaphores, mutexes, and also for sleeps and string copies.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cdi__os__api_8h_source.html">cdi_os_api.h</a>&quot;</code><br />
<code>#include &lt;arpa/inet.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;dirent.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;malloc.h&gt;</code><br />
<code>#include &lt;netdb.h&gt;</code><br />
<code>#include &lt;netinet/ip.h&gt;</code><br />
<code>#include &lt;poll.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;semaphore.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &lt;sys/uio.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cdi__logger__api_8h_source.html">cdi_logger_api.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiThreadInfo.html">CdiThreadInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to keep track of thread state info.  <a href="structCdiThreadInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSemInfo.html">SemInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold semaphore state data.  <a href="structSemInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSignalInfo.html">SignalInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold signal state data.  <a href="structSignalInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSocketInfo.html">SocketInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold semaphore state data.  <a href="structSocketInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8a7363c1dbf7bffcd0937769964adb00" id="r_a8a7363c1dbf7bffcd0937769964adb00"><td class="memItemLeft" align="right" valign="top"><a id="a8a7363c1dbf7bffcd0937769964adb00" name="a8a7363c1dbf7bffcd0937769964adb00"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__USE_XOPEN2K</b></td></tr>
<tr class="memdesc:a8a7363c1dbf7bffcd0937769964adb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linux definition. <br /></td></tr>
<tr class="separator:a8a7363c1dbf7bffcd0937769964adb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369266c24eacffb87046522897a570d5" id="r_a369266c24eacffb87046522897a570d5"><td class="memItemLeft" align="right" valign="top"><a id="a369266c24eacffb87046522897a570d5" name="a369266c24eacffb87046522897a570d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_GNU_SOURCE</b></td></tr>
<tr class="memdesc:a369266c24eacffb87046522897a570d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">_GNU_SOURCE Linux required for pthread_setname_np(). <br /></td></tr>
<tr class="separator:a369266c24eacffb87046522897a570d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b7a8cb7bc3fdbd98014a3e15ee6e9a" id="r_a90b7a8cb7bc3fdbd98014a3e15ee6e9a"><td class="memItemLeft" align="right" valign="top"><a id="a90b7a8cb7bc3fdbd98014a3e15ee6e9a" name="a90b7a8cb7bc3fdbd98014a3e15ee6e9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THREAD_STACK_SIZE</b>&#160;&#160;&#160;(1024*1024)</td></tr>
<tr class="memdesc:a90b7a8cb7bc3fdbd98014a3e15ee6e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linux definition of stack size. <br /></td></tr>
<tr class="separator:a90b7a8cb7bc3fdbd98014a3e15ee6e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e336ab66f768d6667c528773b7a5ed7" id="r_a7e336ab66f768d6667c528773b7a5ed7"><td class="memItemLeft" align="right" valign="top"><a id="a7e336ab66f768d6667c528773b7a5ed7" name="a7e336ab66f768d6667c528773b7a5ed7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_THREADS_WAITING</b>&#160;&#160;&#160;(50)</td></tr>
<tr class="memdesc:a7e336ab66f768d6667c528773b7a5ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of threads that can register for notifications from another signal. <br /></td></tr>
<tr class="separator:a7e336ab66f768d6667c528773b7a5ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae5c74c245f8d601504d3224915c614" id="r_acae5c74c245f8d601504d3224915c614"><td class="memItemLeft" align="right" valign="top"><a id="acae5c74c245f8d601504d3224915c614" name="acae5c74c245f8d601504d3224915c614"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ERROR_MESSAGE</b>(...)&#160;&#160;&#160;<a class="el" href="#a2c2d56d8351d17ed553f501fd1fbd66d">LogMessage</a>(<a class="el" href="cdi__log__enums_8h.html#a419726836ec976c1dfbd9293d5f64705a959df2659726a9ade66bf741c5b53da5">kLogError</a>, __FUNCTION__, __LINE__, __VA_ARGS__)</td></tr>
<tr class="memdesc:acae5c74c245f8d601504d3224915c614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used within this file to handle generation of error messages either to the logger or stderr. <br /></td></tr>
<tr class="separator:acae5c74c245f8d601504d3224915c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6d9527001d3564e7f0df88d2b79a08" id="r_a9e6d9527001d3564e7f0df88d2b79a08"><td class="memItemLeft" align="right" valign="top"><a id="a9e6d9527001d3564e7f0df88d2b79a08" name="a9e6d9527001d3564e7f0df88d2b79a08"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WARNING_MESSAGE</b>(...)&#160;&#160;&#160;<a class="el" href="#a2c2d56d8351d17ed553f501fd1fbd66d">LogMessage</a>(<a class="el" href="cdi__log__enums_8h.html#a419726836ec976c1dfbd9293d5f64705a5c23064bde636fb7f6e63a32e604afae">kLogWarning</a>, __FUNCTION__, __LINE__, __VA_ARGS__)</td></tr>
<tr class="memdesc:a9e6d9527001d3564e7f0df88d2b79a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used within this file to handle generation of error messages either to the logger or stderr. <br /></td></tr>
<tr class="separator:a9e6d9527001d3564e7f0df88d2b79a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab499794db9860a49f455265a15ad19a7" id="r_ab499794db9860a49f455265a15ad19a7"><td class="memItemLeft" align="right" valign="top"><a id="ab499794db9860a49f455265a15ad19a7" name="ab499794db9860a49f455265a15ad19a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_FORMATTED_MESSAGE_LENGTH</b>&#160;&#160;&#160;(1024)</td></tr>
<tr class="memdesc:ab499794db9860a49f455265a15ad19a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a single formatted message string. <br /></td></tr>
<tr class="separator:ab499794db9860a49f455265a15ad19a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a99278521e44f14d94660a5baefeb2bfc" id="r_a99278521e44f14d94660a5baefeb2bfc"><td class="memItemLeft" align="right" valign="top"><a id="a99278521e44f14d94660a5baefeb2bfc" name="a99278521e44f14d94660a5baefeb2bfc"></a>
typedef struct CdiThreadInfo&#160;</td><td class="memItemRight" valign="bottom"><b>CdiThreadInfo</b></td></tr>
<tr class="memdesc:a99278521e44f14d94660a5baefeb2bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Info is kept in a doubly-linked list. <br /></td></tr>
<tr class="separator:a99278521e44f14d94660a5baefeb2bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cde4de49a8e9a479403e4ed3a8528b" id="r_af3cde4de49a8e9a479403e4ed3a8528b"><td class="memItemLeft" align="right" valign="top"><a id="af3cde4de49a8e9a479403e4ed3a8528b" name="af3cde4de49a8e9a479403e4ed3a8528b"></a>
typedef struct SemInfo&#160;</td><td class="memItemRight" valign="bottom"><b>SemInfo</b></td></tr>
<tr class="memdesc:af3cde4de49a8e9a479403e4ed3a8528b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration to create pointer to semaphore info when used. <br /></td></tr>
<tr class="separator:af3cde4de49a8e9a479403e4ed3a8528b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7438b18a4ad01008205c05b86c6154a" id="r_aa7438b18a4ad01008205c05b86c6154a"><td class="memItemLeft" align="right" valign="top"><a id="aa7438b18a4ad01008205c05b86c6154a" name="aa7438b18a4ad01008205c05b86c6154a"></a>
typedef struct SignalInfo&#160;</td><td class="memItemRight" valign="bottom"><b>SignalInfo</b></td></tr>
<tr class="memdesc:aa7438b18a4ad01008205c05b86c6154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration to create pointer to signal info when used. <br /></td></tr>
<tr class="separator:aa7438b18a4ad01008205c05b86c6154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86649303b78f58890926ab3a9a571c6b" id="r_a86649303b78f58890926ab3a9a571c6b"><td class="memItemLeft" align="right" valign="top"><a id="a86649303b78f58890926ab3a9a571c6b" name="a86649303b78f58890926ab3a9a571c6b"></a>
typedef struct SocketInfo&#160;</td><td class="memItemRight" valign="bottom"><b>SocketInfo</b></td></tr>
<tr class="memdesc:a86649303b78f58890926ab3a9a571c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration to create pointer to socket info when used. <br /></td></tr>
<tr class="separator:a86649303b78f58890926ab3a9a571c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2c2d56d8351d17ed553f501fd1fbd66d" id="r_a2c2d56d8351d17ed553f501fd1fbd66d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c2d56d8351d17ed553f501fd1fbd66d">LogMessage</a> (<a class="el" href="cdi__log__enums_8h.html#a419726836ec976c1dfbd9293d5f64705">CdiLogLevel</a> level, const char *func_name_str, int line, const char *format_str,...)</td></tr>
<tr class="separator:a2c2d56d8351d17ed553f501fd1fbd66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62e301797317b873763a31e3e538961" id="r_ad62e301797317b873763a31e3e538961"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad62e301797317b873763a31e3e538961">GetTimeout</a> (struct timespec *spec, uint32_t num_ms, clockid_t clock_id)</td></tr>
<tr class="separator:ad62e301797317b873763a31e3e538961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2e059e1c7b75131e450ac31b0b94e0" id="r_aff2e059e1c7b75131e450ac31b0b94e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2e059e1c7b75131e450ac31b0b94e0">PopulateSigAction</a> (struct sigaction *sig_act_ptr, <a class="el" href="cdi__os__api_8h.html#a75656dffadf2d578ae0316591674bef3">CdiSignalHandlerFunction</a> func_ptr)</td></tr>
<tr class="separator:aff2e059e1c7b75131e450ac31b0b94e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec6f84b5a7ab852d719de3eb7fe838e" id="r_abec6f84b5a7ab852d719de3eb7fe838e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abec6f84b5a7ab852d719de3eb7fe838e">ThreadFuncHelper</a> (void *thread_ptr)</td></tr>
<tr class="separator:abec6f84b5a7ab852d719de3eb7fe838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1867814de8b653289b65042f558f78" id="r_abc1867814de8b653289b65042f558f78"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc1867814de8b653289b65042f558f78">SocketWrite</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, const struct msghdr *msg_ptr, int *byte_count_ptr)</td></tr>
<tr class="separator:abc1867814de8b653289b65042f558f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d90148bb293124b995ef5f8b1e6885" id="r_aa2d90148bb293124b995ef5f8b1e6885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2d90148bb293124b995ef5f8b1e6885">CdiOsUseLogger</a> (void)</td></tr>
<tr class="separator:aa2d90148bb293124b995ef5f8b1e6885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb86a0f3c35dd10ccbb7a8e20e6b13c4" id="r_adb86a0f3c35dd10ccbb7a8e20e6b13c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb86a0f3c35dd10ccbb7a8e20e6b13c4">CdiOsSignalHandlerSet</a> (int signal_num, <a class="el" href="cdi__os__api_8h.html#a75656dffadf2d578ae0316591674bef3">CdiSignalHandlerFunction</a> func_ptr)</td></tr>
<tr class="separator:adb86a0f3c35dd10ccbb7a8e20e6b13c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41e664402cd3c6519c637b5c569395d" id="r_af41e664402cd3c6519c637b5c569395d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41e664402cd3c6519c637b5c569395d">CdiOsThreadCreatePinned</a> (<a class="el" href="cdi__os__api_8h.html#ae81e397cf8839b0315e33bcc5d662b97">CdiThreadFuncName</a> thread_func, <a class="el" href="cdi__os__api_8h.html#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> *thread_id_out_ptr, const char *thread_name_str, void *thread_func_arg_ptr, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> start_signal, int cpu_affinity)</td></tr>
<tr class="separator:af41e664402cd3c6519c637b5c569395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d14e12c7b12b05e0e181715e7da3906" id="r_a5d14e12c7b12b05e0e181715e7da3906"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d14e12c7b12b05e0e181715e7da3906">CdiOsThreadAllocData</a> (<a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> *handle_out_ptr)</td></tr>
<tr class="separator:a5d14e12c7b12b05e0e181715e7da3906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e196505946cb3855358fc0fa96c80b" id="r_ad6e196505946cb3855358fc0fa96c80b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6e196505946cb3855358fc0fa96c80b">CdiOsThreadFreeData</a> (<a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> handle)</td></tr>
<tr class="separator:ad6e196505946cb3855358fc0fa96c80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235d66e1158b08b4bc7230ef39c25598" id="r_a235d66e1158b08b4bc7230ef39c25598"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235d66e1158b08b4bc7230ef39c25598">CdiOsThreadSetData</a> (<a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> handle, void *content_ptr)</td></tr>
<tr class="separator:a235d66e1158b08b4bc7230ef39c25598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925c06af6be8911fa814dd37b577d91a" id="r_a925c06af6be8911fa814dd37b577d91a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a925c06af6be8911fa814dd37b577d91a">CdiOsThreadGetData</a> (<a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> handle, void **content_out_ptr)</td></tr>
<tr class="separator:a925c06af6be8911fa814dd37b577d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b56bf25bfd0072f4ef08bd5979337b" id="r_a04b56bf25bfd0072f4ef08bd5979337b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b56bf25bfd0072f4ef08bd5979337b">CdiOsThreadGetName</a> (<a class="el" href="cdi__os__api_8h.html#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> thread_id)</td></tr>
<tr class="separator:a04b56bf25bfd0072f4ef08bd5979337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacef38627440f8e65e0a4af37e8ed293" id="r_aacef38627440f8e65e0a4af37e8ed293"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacef38627440f8e65e0a4af37e8ed293">CdiOsThreadJoin</a> (<a class="el" href="cdi__os__api_8h.html#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> thread_id, uint32_t timeout_in_ms, bool *timed_out_ptr)</td></tr>
<tr class="separator:aacef38627440f8e65e0a4af37e8ed293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8319d7e05e2f082af03ccdca8ff54e9" id="r_af8319d7e05e2f082af03ccdca8ff54e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8319d7e05e2f082af03ccdca8ff54e9">CdiOsSemaphoreCreate</a> (<a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> *ret_sem_handle_ptr, int sem_count)</td></tr>
<tr class="separator:af8319d7e05e2f082af03ccdca8ff54e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d1746c644f3a4b6a7f0cf59e9369c5" id="r_aa5d1746c644f3a4b6a7f0cf59e9369c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5d1746c644f3a4b6a7f0cf59e9369c5">CdiOsSemaphoreDelete</a> (<a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle)</td></tr>
<tr class="separator:aa5d1746c644f3a4b6a7f0cf59e9369c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb1292b7b9bc6a16a4b118050959b34" id="r_a6cb1292b7b9bc6a16a4b118050959b34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb1292b7b9bc6a16a4b118050959b34">CdiOsSemaphoreRelease</a> (<a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle)</td></tr>
<tr class="separator:a6cb1292b7b9bc6a16a4b118050959b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e5b4ac8f8f14166f9ff97e93d72dc5" id="r_a40e5b4ac8f8f14166f9ff97e93d72dc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40e5b4ac8f8f14166f9ff97e93d72dc5">CdiOsSemaphoreReserve</a> (<a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle, int timeout_in_ms)</td></tr>
<tr class="separator:a40e5b4ac8f8f14166f9ff97e93d72dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c12ef62b4964594c880c167c18538b" id="r_af9c12ef62b4964594c880c167c18538b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9c12ef62b4964594c880c167c18538b">CdiOsSemaphoreValueGet</a> (<a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle)</td></tr>
<tr class="separator:af9c12ef62b4964594c880c167c18538b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff844d16d378bea56192484fbad4c96" id="r_a7ff844d16d378bea56192484fbad4c96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ff844d16d378bea56192484fbad4c96">CdiOsCritSectionCreate</a> (<a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> *cs_handle_ptr)</td></tr>
<tr class="separator:a7ff844d16d378bea56192484fbad4c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9869d1251bbff8d0d62456ef1bae9e15" id="r_a9869d1251bbff8d0d62456ef1bae9e15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9869d1251bbff8d0d62456ef1bae9e15">CdiOsCritSectionReserve</a> (<a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> cs_handle)</td></tr>
<tr class="separator:a9869d1251bbff8d0d62456ef1bae9e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b0bb9a34dbabf79ac42dd034a61459" id="r_a72b0bb9a34dbabf79ac42dd034a61459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72b0bb9a34dbabf79ac42dd034a61459">CdiOsCritSectionRelease</a> (<a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> cs_handle)</td></tr>
<tr class="separator:a72b0bb9a34dbabf79ac42dd034a61459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca84e00acbf02a01c28f85a92e0a0e1" id="r_afca84e00acbf02a01c28f85a92e0a0e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afca84e00acbf02a01c28f85a92e0a0e1">CdiOsCritSectionDelete</a> (<a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> cs_handle)</td></tr>
<tr class="separator:afca84e00acbf02a01c28f85a92e0a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c39c1882e4674a1f609526116211c8b" id="r_a1c39c1882e4674a1f609526116211c8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c39c1882e4674a1f609526116211c8b">CdiOsSignalCreate</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *signal_handle_ptr)</td></tr>
<tr class="separator:a1c39c1882e4674a1f609526116211c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d24e6eece4ad2e42a62b301a51c77e2" id="r_a3d24e6eece4ad2e42a62b301a51c77e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d24e6eece4ad2e42a62b301a51c77e2">CdiOsSignalDelete</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:a3d24e6eece4ad2e42a62b301a51c77e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9d3f997b994adc1dac583fd13b979b" id="r_adf9d3f997b994adc1dac583fd13b979b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf9d3f997b994adc1dac583fd13b979b">CdiOsSignalClear</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:adf9d3f997b994adc1dac583fd13b979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e729be2f103641ae208a93f721cb60" id="r_af3e729be2f103641ae208a93f721cb60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e729be2f103641ae208a93f721cb60">CdiOsSignalSet</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:af3e729be2f103641ae208a93f721cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16deff9aea85cefbbd4bb4fd4bb97063" id="r_a16deff9aea85cefbbd4bb4fd4bb97063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16deff9aea85cefbbd4bb4fd4bb97063">CdiOsSignalGet</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:a16deff9aea85cefbbd4bb4fd4bb97063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668daefa642e25d210d65423d9575f1a" id="r_a668daefa642e25d210d65423d9575f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a668daefa642e25d210d65423d9575f1a">CdiOsSignalReadState</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:a668daefa642e25d210d65423d9575f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed2c74c25da49ea4b586ee84cbbd436" id="r_a6ed2c74c25da49ea4b586ee84cbbd436"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ed2c74c25da49ea4b586ee84cbbd436">CdiOsSignalWait</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle, uint32_t timeout_in_ms, bool *timed_out_ptr)</td></tr>
<tr class="separator:a6ed2c74c25da49ea4b586ee84cbbd436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdc9c31b38a8bc5a9fa7b31fc7aff1" id="r_a0ecdc9c31b38a8bc5a9fa7b31fc7aff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ecdc9c31b38a8bc5a9fa7b31fc7aff1">CdiOsSignalsWait</a> (<a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *signal_array, uint8_t num_signals, bool wait_all, uint32_t timeout_in_ms, uint32_t *ret_signal_index_ptr)</td></tr>
<tr class="separator:a0ecdc9c31b38a8bc5a9fa7b31fc7aff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a13725dcb80a7398a23e5020bf46b42" id="r_a8a13725dcb80a7398a23e5020bf46b42"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a13725dcb80a7398a23e5020bf46b42">CdiOsMemAlloc</a> (int64_t mem_size)</td></tr>
<tr class="separator:a8a13725dcb80a7398a23e5020bf46b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f61cbc47b62a0985761e91d69ba759" id="r_a82f61cbc47b62a0985761e91d69ba759"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82f61cbc47b62a0985761e91d69ba759">CdiOsMemAllocZero</a> (int64_t mem_size)</td></tr>
<tr class="separator:a82f61cbc47b62a0985761e91d69ba759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25cdff9bed3b492e85c139b75a23847" id="r_ad25cdff9bed3b492e85c139b75a23847"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad25cdff9bed3b492e85c139b75a23847">CdiOsMemFree</a> (void *mem_ptr)</td></tr>
<tr class="separator:ad25cdff9bed3b492e85c139b75a23847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3980ecd290a4048a4f79a06ba9372e2f" id="r_a3980ecd290a4048a4f79a06ba9372e2f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3980ecd290a4048a4f79a06ba9372e2f">CdiOsMemAllocHugePage</a> (int64_t mem_size)</td></tr>
<tr class="separator:a3980ecd290a4048a4f79a06ba9372e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e7715c24505e0a5040288c90f3e9ec" id="r_a14e7715c24505e0a5040288c90f3e9ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14e7715c24505e0a5040288c90f3e9ec">CdiOsMemFreeHugePage</a> (void *mem_ptr, int64_t mem_size)</td></tr>
<tr class="separator:a14e7715c24505e0a5040288c90f3e9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad463e62872b19383eae29d6a672b885e" id="r_ad463e62872b19383eae29d6a672b885e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad463e62872b19383eae29d6a672b885e">CdiOsOpenForWrite</a> (const char *file_name_str, <a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *file_handle_ptr)</td></tr>
<tr class="separator:ad463e62872b19383eae29d6a672b885e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaf0ca28a0f34c1cefef799db1cc495" id="r_abaaf0ca28a0f34c1cefef799db1cc495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaaf0ca28a0f34c1cefef799db1cc495">CdiOsOpenForRead</a> (const char *file_name_str, <a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *file_handle_ptr)</td></tr>
<tr class="separator:abaaf0ca28a0f34c1cefef799db1cc495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc6aa191f0960c43ebd3774ed28850f" id="r_abfc6aa191f0960c43ebd3774ed28850f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfc6aa191f0960c43ebd3774ed28850f">CdiOsClose</a> (<a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle)</td></tr>
<tr class="separator:abfc6aa191f0960c43ebd3774ed28850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b10fc244d4cf14ffebee520d66d874e" id="r_a4b10fc244d4cf14ffebee520d66d874e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b10fc244d4cf14ffebee520d66d874e">CdiOsRead</a> (<a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, void *buffer_ptr, uint32_t byte_count, uint32_t *bytes_read_ptr)</td></tr>
<tr class="separator:a4b10fc244d4cf14ffebee520d66d874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a44d71a1dec2c25bd5443bb5e9a07c" id="r_aa0a44d71a1dec2c25bd5443bb5e9a07c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0a44d71a1dec2c25bd5443bb5e9a07c">CdiOsWrite</a> (<a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, const void *data_ptr, uint32_t byte_count)</td></tr>
<tr class="separator:aa0a44d71a1dec2c25bd5443bb5e9a07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28575730effb64859138c98723d26614" id="r_a28575730effb64859138c98723d26614"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28575730effb64859138c98723d26614">CdiOsFlush</a> (<a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle)</td></tr>
<tr class="separator:a28575730effb64859138c98723d26614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fa7028b2fa1d53266ca4fbd5436225" id="r_ac2fa7028b2fa1d53266ca4fbd5436225"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2fa7028b2fa1d53266ca4fbd5436225">CdiOsFTell</a> (<a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, uint64_t *current_position_ptr)</td></tr>
<tr class="separator:ac2fa7028b2fa1d53266ca4fbd5436225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fa8b81667b835ffb701d235353f0c1" id="r_ad5fa8b81667b835ffb701d235353f0c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5fa8b81667b835ffb701d235353f0c1">CdiOsFSeek</a> (<a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, int64_t offset, int position)</td></tr>
<tr class="separator:ad5fa8b81667b835ffb701d235353f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5716b7b1364e9a2ca7b2729e43b88d06" id="r_a5716b7b1364e9a2ca7b2729e43b88d06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5716b7b1364e9a2ca7b2729e43b88d06">CdiOsSplitPath</a> (const char *filepath_str, char *filename_str, int filename_buf_size, char *directory_str, int directory_buf_size)</td></tr>
<tr class="separator:a5716b7b1364e9a2ca7b2729e43b88d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f33d2923f427076da8c84b83990f72" id="r_a52f33d2923f427076da8c84b83990f72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f33d2923f427076da8c84b83990f72">CdiOsIsPathWriteable</a> (const char *directory_str)</td></tr>
<tr class="separator:a52f33d2923f427076da8c84b83990f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1eaf023562ecaecdf2ada6d35389b3a" id="r_af1eaf023562ecaecdf2ada6d35389b3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1eaf023562ecaecdf2ada6d35389b3a">CdiOsStrCpy</a> (char *dest_str, uint32_t max_str_len, const char *src_str)</td></tr>
<tr class="separator:af1eaf023562ecaecdf2ada6d35389b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4717fa2b854e77732f76d2c80d7044fc" id="r_a4717fa2b854e77732f76d2c80d7044fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4717fa2b854e77732f76d2c80d7044fc">CdiOsSleep</a> (uint32_t milliseconds)</td></tr>
<tr class="separator:a4717fa2b854e77732f76d2c80d7044fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778bac33c333ba54cf1d350fe2bd4f0c" id="r_a778bac33c333ba54cf1d350fe2bd4f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a778bac33c333ba54cf1d350fe2bd4f0c">CdiOsSleepMicroseconds</a> (uint32_t microseconds)</td></tr>
<tr class="separator:a778bac33c333ba54cf1d350fe2bd4f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f689abda189bc7285d37cb0d38e731e" id="r_a9f689abda189bc7285d37cb0d38e731e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f689abda189bc7285d37cb0d38e731e">CdiOsGetMicroseconds</a> ()</td></tr>
<tr class="memdesc:a9f689abda189bc7285d37cb0d38e731e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timers get a microsecond timestamp from CLOCK_MONOTONIC on linux or from the performance counter on Windows.  <br /></td></tr>
<tr class="separator:a9f689abda189bc7285d37cb0d38e731e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0015a0fece84dbf729e139df353cc34" id="r_ab0015a0fece84dbf729e139df353cc34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0015a0fece84dbf729e139df353cc34">CdiOsGetUtcTime</a> (struct timespec *ret_time_ptr)</td></tr>
<tr class="memdesc:ab0015a0fece84dbf729e139df353cc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an OS call to get the current synced AWS network time in UTC format.  <br /></td></tr>
<tr class="separator:ab0015a0fece84dbf729e139df353cc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11290952a5741ca9c359dad9ad85ef75" id="r_a11290952a5741ca9c359dad9ad85ef75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11290952a5741ca9c359dad9ad85ef75">CdiOsGetLocalTime</a> (struct tm *local_time_ret_ptr)</td></tr>
<tr class="separator:a11290952a5741ca9c359dad9ad85ef75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c14c6fd36217063553d9637b4bdb7c0" id="r_a6c14c6fd36217063553d9637b4bdb7c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c14c6fd36217063553d9637b4bdb7c0">CdiOsGetLocalTimeString</a> (char *time_str, int max_string_len)</td></tr>
<tr class="separator:a6c14c6fd36217063553d9637b4bdb7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dd4ec1bd24ba902a4a10b359f3789b" id="r_ac2dd4ec1bd24ba902a4a10b359f3789b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2dd4ec1bd24ba902a4a10b359f3789b">CdiOsSocketOpen</a> (const char *host_address_str, int port_number, const char *bind_address_str, <a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> *new_socket_ptr)</td></tr>
<tr class="separator:ac2dd4ec1bd24ba902a4a10b359f3789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620bc5368b8ec28047aff5dd1173895a" id="r_a620bc5368b8ec28047aff5dd1173895a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a620bc5368b8ec28047aff5dd1173895a">CdiOsSocketGetPort</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, int *port_number_ptr)</td></tr>
<tr class="separator:a620bc5368b8ec28047aff5dd1173895a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecec95c4b2f438f35054f6c962a93b42" id="r_aecec95c4b2f438f35054f6c962a93b42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecec95c4b2f438f35054f6c962a93b42">CdiOsSocketGetSockAddrIn</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, struct sockaddr_in *sockaddr_in_ptr)</td></tr>
<tr class="separator:aecec95c4b2f438f35054f6c962a93b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ade60bffedb23914c88c39e97447c1" id="r_ac9ade60bffedb23914c88c39e97447c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9ade60bffedb23914c88c39e97447c1">CdiOsSocketClose</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> s)</td></tr>
<tr class="separator:ac9ade60bffedb23914c88c39e97447c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb940900cb298aee889f56579c94264" id="r_aadb940900cb298aee889f56579c94264"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadb940900cb298aee889f56579c94264">CdiOsSocketRead</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, void *buffer_ptr, int *byte_count_ptr)</td></tr>
<tr class="separator:aadb940900cb298aee889f56579c94264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c384ee7f407179bb9aea84f508cb5" id="r_a5b5c384ee7f407179bb9aea84f508cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b5c384ee7f407179bb9aea84f508cb5">CdiOsSocketReadFrom</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, void *buffer_ptr, int *byte_count_ptr, struct sockaddr_in *source_address_ptr)</td></tr>
<tr class="separator:a5b5c384ee7f407179bb9aea84f508cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b650c025d2f1136360263a79e3d8c0" id="r_ad4b650c025d2f1136360263a79e3d8c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4b650c025d2f1136360263a79e3d8c0">CdiOsSocketWrite</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, struct iovec *iov, int iovcnt, int *byte_count_ptr)</td></tr>
<tr class="separator:ad4b650c025d2f1136360263a79e3d8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d66853add5393841f6ce25d511ba5e7" id="r_a2d66853add5393841f6ce25d511ba5e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d66853add5393841f6ce25d511ba5e7">CdiOsSocketWriteTo</a> (<a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, struct iovec *iov, int iovcnt, const struct sockaddr_in *destination_address_ptr, int *byte_count_ptr)</td></tr>
<tr class="separator:a2d66853add5393841f6ce25d511ba5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa416af6613ed969fd234b7539824021f" id="r_aa416af6613ed969fd234b7539824021f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa416af6613ed969fd234b7539824021f">CdiOsEnvironmentVariableSet</a> (const char *name_str, const char *value_str)</td></tr>
<tr class="separator:aa416af6613ed969fd234b7539824021f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc4bdc2f7c55e879e924a37ca5c1c97" id="r_adcc4bdc2f7c55e879e924a37ca5c1c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc4bdc2f7c55e879e924a37ca5c1c97">CdiOsShutdown</a> ()</td></tr>
<tr class="separator:adcc4bdc2f7c55e879e924a37ca5c1c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a310ef9b015dcd2bb44439f9268b274a5" id="r_a310ef9b015dcd2bb44439f9268b274a5"><td class="memItemLeft" align="right" valign="top"><a id="a310ef9b015dcd2bb44439f9268b274a5" name="a310ef9b015dcd2bb44439f9268b274a5"></a>
static const clockid_t&#160;</td><td class="memItemRight" valign="bottom"><b>kPreferredClock</b> = CLOCK_MONOTONIC</td></tr>
<tr class="memdesc:a310ef9b015dcd2bb44439f9268b274a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred clock used when doing timing calculations, because unaffected by system clock adjustments. <br /></td></tr>
<tr class="separator:a310ef9b015dcd2bb44439f9268b274a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d922d65193fd4a2c8d232381221cd8" id="r_a48d922d65193fd4a2c8d232381221cd8"><td class="memItemLeft" align="right" valign="top"><a id="a48d922d65193fd4a2c8d232381221cd8" name="a48d922d65193fd4a2c8d232381221cd8"></a>
static <a class="el" href="structCdiSignalHandlerInfo.html">CdiSignalHandlerInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>signal_handler_function_array</b> [<a class="el" href="cdi__os__api_8h.html#ac042d8501b00160c33330c61dc2fe6d6">CDI_MAX_SIGNAL_HANDLERS</a>]</td></tr>
<tr class="memdesc:a48d922d65193fd4a2c8d232381221cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of data used to hold signal handlers. <br /></td></tr>
<tr class="separator:a48d922d65193fd4a2c8d232381221cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b7265e1cbd132ffcfd605b68073e30" id="r_a34b7265e1cbd132ffcfd605b68073e30"><td class="memItemLeft" align="right" valign="top"><a id="a34b7265e1cbd132ffcfd605b68073e30" name="a34b7265e1cbd132ffcfd605b68073e30"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>signal_handler_count</b> = 0</td></tr>
<tr class="memdesc:a34b7265e1cbd132ffcfd605b68073e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of signal handlers in signal_handler_function_array. <br /></td></tr>
<tr class="separator:a34b7265e1cbd132ffcfd605b68073e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fac1cfa7b093c3d8b52004afa648ab" id="r_a07fac1cfa7b093c3d8b52004afa648ab"><td class="memItemLeft" align="right" valign="top"><a id="a07fac1cfa7b093c3d8b52004afa648ab" name="a07fac1cfa7b093c3d8b52004afa648ab"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_logger</b> = false</td></tr>
<tr class="memdesc:a07fac1cfa7b093c3d8b52004afa648ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the CDI logger will be used to generate error messages, otherwise output will be sent to stderr. <br /></td></tr>
<tr class="separator:a07fac1cfa7b093c3d8b52004afa648ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the Linux definitions for OS functions for creating/deleting threads, semaphores, mutexes, and also for sleeps and string copies. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abfc6aa191f0960c43ebd3774ed28850f" name="abfc6aa191f0960c43ebd3774ed28850f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc6aa191f0960c43ebd3774ed28850f">&#9670;&#160;</a></span>CdiOsClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of file to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a7ff844d16d378bea56192484fbad4c96" name="a7ff844d16d378bea56192484fbad4c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff844d16d378bea56192484fbad4c96">&#9670;&#160;</a></span>CdiOsCritSectionCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsCritSectionCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> *</td>          <td class="paramname"><span class="paramname"><em>cs_handle_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes a critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle_ptr</td><td>Pointer to critical section ID to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="afca84e00acbf02a01c28f85a92e0a0e1" name="afca84e00acbf02a01c28f85a92e0a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca84e00acbf02a01c28f85a92e0a0e1">&#9670;&#160;</a></span>CdiOsCritSectionDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsCritSectionDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a></td>          <td class="paramname"><span class="paramname"><em>cs_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle</td><td>Pointer to critical section ID to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a72b0bb9a34dbabf79ac42dd034a61459" name="a72b0bb9a34dbabf79ac42dd034a61459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b0bb9a34dbabf79ac42dd034a61459">&#9670;&#160;</a></span>CdiOsCritSectionRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsCritSectionRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a></td>          <td class="paramname"><span class="paramname"><em>cs_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the specified critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle</td><td>Critical section ID to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9869d1251bbff8d0d62456ef1bae9e15" name="a9869d1251bbff8d0d62456ef1bae9e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9869d1251bbff8d0d62456ef1bae9e15">&#9670;&#160;</a></span>CdiOsCritSectionReserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsCritSectionReserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a></td>          <td class="paramname"><span class="paramname"><em>cs_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves the specified critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle</td><td>Critical section ID to reserve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa416af6613ed969fd234b7539824021f" name="aa416af6613ed969fd234b7539824021f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa416af6613ed969fd234b7539824021f">&#9670;&#160;</a></span>CdiOsEnvironmentVariableSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsEnvironmentVariableSet </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an environment variable for the currently running process. NOTE: Does not set the process's shell environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_str</td><td>Pointer to string name of variable to set. Assumed to be a non-NULL value. </td></tr>
    <tr><td class="paramname">value_str</td><td>Pointer to string value to set. NOTE: Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a28575730effb64859138c98723d26614" name="a28575730effb64859138c98723d26614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28575730effb64859138c98723d26614">&#9670;&#160;</a></span>CdiOsFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes write buffers for the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of the file to flush.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ad5fa8b81667b835ffb701d235353f0c1" name="ad5fa8b81667b835ffb701d235353f0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fa8b81667b835ffb701d235353f0c1">&#9670;&#160;</a></span>CdiOsFSeek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsFSeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>position</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current file position for the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of the file. </td></tr>
    <tr><td class="paramname">offset</td><td>Number of bytes to offset from position. </td></tr>
    <tr><td class="paramname">position</td><td>The position from where offset is added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ac2fa7028b2fa1d53266ca4fbd5436225" name="ac2fa7028b2fa1d53266ca4fbd5436225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fa7028b2fa1d53266ca4fbd5436225">&#9670;&#160;</a></span>CdiOsFTell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsFTell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>current_position_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current file position for the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of the file. </td></tr>
    <tr><td class="paramname">current_position_ptr</td><td>Pointer to current position of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a11290952a5741ca9c359dad9ad85ef75" name="a11290952a5741ca9c359dad9ad85ef75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11290952a5741ca9c359dad9ad85ef75">&#9670;&#160;</a></span>CdiOsGetLocalTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsGetLocalTime </td>
          <td>(</td>
          <td class="paramtype">struct tm *</td>          <td class="paramname"><span class="paramname"><em>local_time_ret_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current local time as "tm" structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_time_ret_ptr</td><td>Pointer to returned local time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c14c6fd36217063553d9637b4bdb7c0" name="a6c14c6fd36217063553d9637b4bdb7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c14c6fd36217063553d9637b4bdb7c0">&#9670;&#160;</a></span>CdiOsGetLocalTimeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CdiOsGetLocalTimeString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>time_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_string_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current local time as a formatted as ISO 8601.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_str</td><td>Formatted string to represent ISO 8601 time format. </td></tr>
    <tr><td class="paramname">max_string_len</td><td>Maximum allowable characters in the time string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char_count Returns the number of characters of the formatted string. </dd></dl>

</div>
</div>
<a id="a9f689abda189bc7285d37cb0d38e731e" name="a9f689abda189bc7285d37cb0d38e731e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f689abda189bc7285d37cb0d38e731e">&#9670;&#160;</a></span>CdiOsGetMicroseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CdiOsGetMicroseconds </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timers get a microsecond timestamp from CLOCK_MONOTONIC on linux or from the performance counter on Windows. </p>
<dl class="section return"><dt>Returns</dt><dd>Microsecond timestamp. </dd></dl>

</div>
</div>
<a id="ab0015a0fece84dbf729e139df353cc34" name="ab0015a0fece84dbf729e139df353cc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0015a0fece84dbf729e139df353cc34">&#9670;&#160;</a></span>CdiOsGetUtcTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsGetUtcTime </td>
          <td>(</td>
          <td class="paramtype">struct timespec *</td>          <td class="paramname"><span class="paramname"><em>ret_time_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an OS call to get the current synced AWS network time in UTC format. </p>
<p>This function will be kept up to date with the best practices for getting high accuracy time from Amazon Time Sync Service as improved accuracy time is available. All EC2 instances that call this function should be using the Amazon Time Sync Service. Amazon Time Sync Service setup directions for Linux can be found at: <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html#configure-amazon-time-service">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html#configure-amazon-time-service</a></p>
<p>For Windows follow the directions at: <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-set-time.html">https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-set-time.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret_time_ptr</td><td>a pointer returned to a UTC timestamp in the format of a timespec structure as defined by time.h. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52f33d2923f427076da8c84b83990f72" name="a52f33d2923f427076da8c84b83990f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f33d2923f427076da8c84b83990f72">&#9670;&#160;</a></span>CdiOsIsPathWriteable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsIsPathWriteable </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>directory_str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a directory string and verifies that the directory exists and is writeable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory_str</td><td>String containing the directory path, including any end '/' without the filename.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a8a13725dcb80a7398a23e5020bf46b42" name="a8a13725dcb80a7398a23e5020bf46b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a13725dcb80a7398a23e5020bf46b42">&#9670;&#160;</a></span>CdiOsMemAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CdiOsMemAlloc </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a block of memory and returns a pointer to the start of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_size</td><td>Number of bytes to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory block. If unable to allocate the memory block, NULL is returned. </dd></dl>

</div>
</div>
<a id="a3980ecd290a4048a4f79a06ba9372e2f" name="a3980ecd290a4048a4f79a06ba9372e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3980ecd290a4048a4f79a06ba9372e2f">&#9670;&#160;</a></span>CdiOsMemAllocHugePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CdiOsMemAllocHugePage </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a block of huge page memory and returns a pointer to the start of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_size</td><td>Number of bytes to allocate. Size must be a multiple of CDI_HUGE_PAGES_BYTE_SIZE. If not, NULL is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory block. If unable to allocate the memory block, NULL is returned. </dd></dl>

</div>
</div>
<a id="a82f61cbc47b62a0985761e91d69ba759" name="a82f61cbc47b62a0985761e91d69ba759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f61cbc47b62a0985761e91d69ba759">&#9670;&#160;</a></span>CdiOsMemAllocZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CdiOsMemAllocZero </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a block of memory, writes zero across its entirety, and returns a pointer to the start of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_size</td><td>Number of bytes to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory block. If unable to allocate the memory block, NULL is returned. </dd></dl>

</div>
</div>
<a id="ad25cdff9bed3b492e85c139b75a23847" name="ad25cdff9bed3b492e85c139b75a23847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25cdff9bed3b492e85c139b75a23847">&#9670;&#160;</a></span>CdiOsMemFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsMemFree </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>mem_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a previously allocated block of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_ptr</td><td>Pointer to start address of memory block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e7715c24505e0a5040288c90f3e9ec" name="a14e7715c24505e0a5040288c90f3e9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e7715c24505e0a5040288c90f3e9ec">&#9670;&#160;</a></span>CdiOsMemFreeHugePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsMemFreeHugePage </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>mem_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a previously allocated block of huge page memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_ptr</td><td>Pointer to start address of memory block. </td></tr>
    <tr><td class="paramname">mem_size</td><td>Number of bytes that were allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaaf0ca28a0f34c1cefef799db1cc495" name="abaaf0ca28a0f34c1cefef799db1cc495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaf0ca28a0f34c1cefef799db1cc495">&#9670;&#160;</a></span>CdiOsOpenForRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsOpenForRead </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *</td>          <td class="paramname"><span class="paramname"><em>file_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a file (file_name_str) for read and returns a file handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name_str</td><td>Pointer to filename to open. </td></tr>
    <tr><td class="paramname">file_handle_ptr</td><td>Address where to write returned file handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ad463e62872b19383eae29d6a672b885e" name="ad463e62872b19383eae29d6a672b885e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad463e62872b19383eae29d6a672b885e">&#9670;&#160;</a></span>CdiOsOpenForWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsOpenForWrite </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *</td>          <td class="paramname"><span class="paramname"><em>file_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a file (file_name_str) for writing and returns a file handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name_str</td><td>Pointer to filename to open. </td></tr>
    <tr><td class="paramname">file_handle_ptr</td><td>Address where to write returned file handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a4b10fc244d4cf14ffebee520d66d874e" name="a4b10fc244d4cf14ffebee520d66d874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b10fc244d4cf14ffebee520d66d874e">&#9670;&#160;</a></span>CdiOsRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>byte_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>bytes_read_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of file to read from. </td></tr>
    <tr><td class="paramname">buffer_ptr</td><td>Pointer to buffer to read in to. </td></tr>
    <tr><td class="paramname">byte_count</td><td>Number of bytes to read into the buffer pointed to by buffer_ptr. </td></tr>
    <tr><td class="paramname">bytes_read_ptr</td><td>Returns the number of bytes read (NULL if you don't care).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. Check EOF using OS's EOF API function. </dd></dl>

</div>
</div>
<a id="af8319d7e05e2f082af03ccdca8ff54e9" name="af8319d7e05e2f082af03ccdca8ff54e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8319d7e05e2f082af03ccdca8ff54e9">&#9670;&#160;</a></span>CdiOsSemaphoreCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSemaphoreCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_sem_handle_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sem_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret_sem_handle_ptr</td><td>Pointer to semaphore ID to return. </td></tr>
    <tr><td class="paramname">sem_count</td><td>Initial semaphore count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="aa5d1746c644f3a4b6a7f0cf59e9369c5" name="aa5d1746c644f3a4b6a7f0cf59e9369c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d1746c644f3a4b6a7f0cf59e9369c5">&#9670;&#160;</a></span>CdiOsSemaphoreDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSemaphoreDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Pointer to semaphore ID to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if successful, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a6cb1292b7b9bc6a16a4b118050959b34" name="a6cb1292b7b9bc6a16a4b118050959b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb1292b7b9bc6a16a4b118050959b34">&#9670;&#160;</a></span>CdiOsSemaphoreRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSemaphoreRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Semaphore ID to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a40e5b4ac8f8f14166f9ff97e93d72dc5" name="a40e5b4ac8f8f14166f9ff97e93d72dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e5b4ac8f8f14166f9ff97e93d72dc5">&#9670;&#160;</a></span>CdiOsSemaphoreReserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSemaphoreReserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves a semaphore and blocks if the current semaphore count is 0. If the semaphore is already reserved by the calling thread, then this call simply returns success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Semaphore ID to reserve. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>Amount of miliseconds to wait for the semaphore, CDI_INFINITE to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="af9c12ef62b4964594c880c167c18538b" name="af9c12ef62b4964594c880c167c18538b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c12ef62b4964594c880c167c18538b">&#9670;&#160;</a></span>CdiOsSemaphoreValueGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CdiOsSemaphoreValueGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of the given semaphore (ie. how many semaphore resources are available).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Semaphore ID to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of semaphore. </dd></dl>

</div>
</div>
<a id="adcc4bdc2f7c55e879e924a37ca5c1c97" name="adcc4bdc2f7c55e879e924a37ca5c1c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc4bdc2f7c55e879e924a37ca5c1c97">&#9670;&#160;</a></span>CdiOsShutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsShutdown </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuts down OS specific resources used by the SDK. </p>

</div>
</div>
<a id="adf9d3f997b994adc1dac583fd13b979b" name="adf9d3f997b994adc1dac583fd13b979b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9d3f997b994adc1dac583fd13b979b">&#9670;&#160;</a></span>CdiOsSignalClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function clears a signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to clear the value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a1c39c1882e4674a1f609526116211c8b" name="a1c39c1882e4674a1f609526116211c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c39c1882e4674a1f609526116211c8b">&#9670;&#160;</a></span>CdiOsSignalCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>signal_handle_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a signal. The initial value is not signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle_ptr</td><td>Address where to write the returned signal handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a3d24e6eece4ad2e42a62b301a51c77e2" name="a3d24e6eece4ad2e42a62b301a51c77e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d24e6eece4ad2e42a62b301a51c77e2">&#9670;&#160;</a></span>CdiOsSignalDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes a signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a16deff9aea85cefbbd4bb4fd4bb97063" name="a16deff9aea85cefbbd4bb4fd4bb97063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16deff9aea85cefbbd4bb4fd4bb97063">&#9670;&#160;</a></span>CdiOsSignalGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the value of the signal passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to get the value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="adb86a0f3c35dd10ccbb7a8e20e6b13c4" name="adb86a0f3c35dd10ccbb7a8e20e6b13c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb86a0f3c35dd10ccbb7a8e20e6b13c4">&#9670;&#160;</a></span>CdiOsSignalHandlerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalHandlerSet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>signal_num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a75656dffadf2d578ae0316591674bef3">CdiSignalHandlerFunction</a></td>          <td class="paramname"><span class="paramname"><em>func_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the address to the default signal handler function shared by all threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_num</td><td>Number of the signal to set the new handler. </td></tr>
    <tr><td class="paramname">func_ptr</td><td>Address of signal handler function to set for the signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if there isn't enough storage to hold the signal or if there was an error. </dd></dl>

</div>
</div>
<a id="a668daefa642e25d210d65423d9575f1a" name="a668daefa642e25d210d65423d9575f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668daefa642e25d210d65423d9575f1a">&#9670;&#160;</a></span>CdiOsSignalReadState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalReadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the value of the signal passed in without using any OS resources. It only accesses state data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to read the state value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="af3e729be2f103641ae208a93f721cb60" name="af3e729be2f103641ae208a93f721cb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e729be2f103641ae208a93f721cb60">&#9670;&#160;</a></span>CdiOsSignalSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets a signal and its related state variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to set the value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a0ecdc9c31b38a8bc5a9fa7b31fc7aff1" name="a0ecdc9c31b38a8bc5a9fa7b31fc7aff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecdc9c31b38a8bc5a9fa7b31fc7aff1">&#9670;&#160;</a></span>CdiOsSignalsWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalsWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>signal_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>num_signals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait_all</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ret_signal_index_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function waits for an array of signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_array</td><td>Pointer to an array of signal handles to wait on. </td></tr>
    <tr><td class="paramname">num_signals</td><td>Number of signals in the array. </td></tr>
    <tr><td class="paramname">wait_all</td><td>Use true to wait for all signals, false to block on any signal. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">ret_signal_index_ptr</td><td>Pointer to the returned signal index that caused the thread to be signaled. if wait_all is true, then this is set to 1 when all signals are signaled. If a timeout occurred, CDI_OS_SIG_TIMEOUT is returned. This is an optional parameter, you can pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a6ed2c74c25da49ea4b586ee84cbbd436" name="a6ed2c74c25da49ea4b586ee84cbbd436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed2c74c25da49ea4b586ee84cbbd436">&#9670;&#160;</a></span>CdiOsSignalWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSignalWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>timed_out_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function waits for a signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to wait on. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">timed_out_ptr</td><td>Pointer to boolean - set to true if timed out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a4717fa2b854e77732f76d2c80d7044fc" name="a4717fa2b854e77732f76d2c80d7044fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4717fa2b854e77732f76d2c80d7044fc">&#9670;&#160;</a></span>CdiOsSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsSleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>milliseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block the current thread for the specified number of milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>Block thread for this much time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a778bac33c333ba54cf1d350fe2bd4f0c" name="a778bac33c333ba54cf1d350fe2bd4f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778bac33c333ba54cf1d350fe2bd4f0c">&#9670;&#160;</a></span>CdiOsSleepMicroseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsSleepMicroseconds </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>microseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block the current thread for microseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microseconds</td><td>Block thread for this much time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9ade60bffedb23914c88c39e97447c1" name="ac9ade60bffedb23914c88c39e97447c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ade60bffedb23914c88c39e97447c1">&#9670;&#160;</a></span>CdiOsSocketClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a previously opened communications socket, freeing resources that were allocated for it including the local port if the socket was opened for receiving.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle of the socket which is to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the socket was closed cleanly, false if a problem was encountered trying to close it. </dd></dl>

</div>
</div>
<a id="a620bc5368b8ec28047aff5dd1173895a" name="a620bc5368b8ec28047aff5dd1173895a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620bc5368b8ec28047aff5dd1173895a">&#9670;&#160;</a></span>CdiOsSocketGetPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketGetPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>port_number_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of the port to which the specified socket is bound. This is useful for receive sockets opened with their port number specified as 0, which makes the operating system assign a random port number. It also works on transmit sockets which are also randomly assigned a port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The socket whose port number is of interest. </td></tr>
    <tr><td class="paramname">port_number_ptr</td><td>Address of where the port number will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port number could be determined or false if a problem was encountered. </dd></dl>

</div>
</div>
<a id="aecec95c4b2f438f35054f6c962a93b42" name="aecec95c4b2f438f35054f6c962a93b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecec95c4b2f438f35054f6c962a93b42">&#9670;&#160;</a></span>CdiOsSocketGetSockAddrIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketGetSockAddrIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *</td>          <td class="paramname"><span class="paramname"><em>sockaddr_in_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the sockaddr_in structure to which the specified socket is bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The socket whose port number is of interest. </td></tr>
    <tr><td class="paramname">sockaddr_in_ptr</td><td>Address of where the sockaddr_in data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sockaddr_in data could be determined or false if a problem was encountered. </dd></dl>

</div>
</div>
<a id="ac2dd4ec1bd24ba902a4a10b359f3789b" name="ac2dd4ec1bd24ba902a4a10b359f3789b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dd4ec1bd24ba902a4a10b359f3789b">&#9670;&#160;</a></span>CdiOsSocketOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketOpen </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>host_address_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_number</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bind_address_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> *</td>          <td class="paramname"><span class="paramname"><em>new_socket_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a unidirectional or bidirectional Internet Protocol User Datagram Protocol (IP/UDP) socket for communications. For a unidirectional socket to send on, specify the host address of the remote host. To create a unidirectional socket for receiving, specify NULL as host_address_str.</p>
<p>For a bidirectional socket, where datagrams can be sent and received through the socket, specify NULL as host_address_str for both client and server sides. For the client side, specify zero for port_number so a randomly selected port number is used. Call </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="cdi__os__api_8h.html#af52ef666f0a782ae687d62681f419c4e">CdiOsSocketGetPort</a> to determine the port number that was assigned. When sending datagrams, Use </dd>
<dd>
<a class="el" href="cdi__os__api_8h.html#acbddbe739d3b8ec2ad256722a58f4944">CdiOsSocketWriteTo</a> to specify the remote destination address and port. For the server side, specify the local port number for port_number to listen for incoming datagrams. Use </dd>
<dd>
<a class="el" href="cdi__os__api_8h.html#a9ccd2528a80d9d2b78b6f9b803047a4e">CdiOsSocketReadFrom</a> so that the datagram's source host's IP address and port number are provided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_address_str</td><td>The address of the remote host (dotted IPv4 address) to which to send datagrams or NULL if the socket is to be used for receiving datagrams or is bidirectional. </td></tr>
    <tr><td class="paramname">port_number</td><td>For a unidirectional send-only socket, the numeric port number on the remote host. For a unidirectional receive only socket or server side of a bidirectional socket, the local port number to listen for incoming datagrams. For the client side of a bidirectional socket, use zero for this value so that a randomly selected port number is used. Call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cdi__os__api_8h.html#af52ef666f0a782ae687d62681f419c4e">CdiOsSocketGetPort</a> to determine the port number that was assigned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bind_address_str</td><td>Optional bind address (dotted IPv4 address). If NULL, default interface is used. </td></tr>
    <tr><td class="paramname">new_socket_ptr</td><td>A pointer to the location which will get the new socket handle written to it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the socket was successfully opened and is ready for communications, otherwise false. </dd></dl>

</div>
</div>
<a id="aadb940900cb298aee889f56579c94264" name="aadb940900cb298aee889f56579c94264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb940900cb298aee889f56579c94264">&#9670;&#160;</a></span>CdiOsSocketRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously reads the next available datagram from the specified socket. If no datagram is available after a short timeout, true is returned but the value written to byte_count_ptr will be zero. This timeout is so that the caller can periodically check whether to shut down its polling loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket for which incoming datagrams are to be received. </td></tr>
    <tr><td class="paramname">buffer_ptr</td><td>The address in memory where the bytes of the datagram will be written. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>On entry, the value at the location pointed to must be the size of the buffer at buffer_ptr available for the datagram to be written. At exit, the address will be overwritten with the number of bytes that are actually contained in the datagram and thus written to the buffer. A value of 0 indicates that the read timed out waiting for a datagram and that the read should be retried unless the polling process should be shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the function succeeded, false if it failed. Timing out is considered to be success but zero will have been written to byte_count_ptr to disambiguate a timeout condition from data being written into the buffer. </dd></dl>

</div>
</div>
<a id="a5b5c384ee7f407179bb9aea84f508cb5" name="a5b5c384ee7f407179bb9aea84f508cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5c384ee7f407179bb9aea84f508cb5">&#9670;&#160;</a></span>CdiOsSocketReadFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketReadFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *</td>          <td class="paramname"><span class="paramname"><em>source_address_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously reads the next available datagram from the specified socket and provides the source IP address/port number. If no datagram is available after a short timeout, true is returned but the value written to byte_count_ptr will be zero. This timeout is so that the caller can periodically check whether to shut down its polling loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket for which incoming datagrams are to be received. </td></tr>
    <tr><td class="paramname">buffer_ptr</td><td>The address in memory where the bytes of the datagram will be written. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>On entry, the value at the location pointed to must be the size of the buffer at buffer_ptr available for the datagram to be written. At exit, the address will be overwritten with the number of bytes that are actually contained in the datagram and thus written to the buffer. A value of 0 indicates that the read timed out waiting for a datagram and that the read should be retried unless the polling process should be shut down. </td></tr>
    <tr><td class="paramname">source_address_ptr</td><td>Pointer to memory where the source address and port number from the UDP packet will be written so that the caller can determine where to send replies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the function succeeded, false if it failed. Timing out is considered to be success but zero will have been written to byte_count_ptr to disambiguate a timeout condition from data being written into the buffer. </dd></dl>

</div>
</div>
<a id="ad4b650c025d2f1136360263a79e3d8c0" name="ad4b650c025d2f1136360263a79e3d8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b650c025d2f1136360263a79e3d8c0">&#9670;&#160;</a></span>CdiOsSocketWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously write a datagram to a communications socket. The data is represented as an array of address pointers and sizes. This data is copied inside of the function so once it returns the buffer(s) are available for reuse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket through which the datagram will be written. </td></tr>
    <tr><td class="paramname">iov</td><td>The address of an array of iovec structures which specify the data to be sent. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of iovec structures contained in the iov array. This value is limited to CDI_OS_SOCKET_MAX_IOVCNT. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>The address of a location into which the number of bytes written to the socket will be placed if the datagram was successfully sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the datagram was successfully sent, false if not. Note that there is no guarantee that the datagram was actually received by the destination host. </dd></dl>

</div>
</div>
<a id="a2d66853add5393841f6ce25d511ba5e7" name="a2d66853add5393841f6ce25d511ba5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d66853add5393841f6ce25d511ba5e7">&#9670;&#160;</a></span>CdiOsSocketWriteTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSocketWriteTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *</td>          <td class="paramname"><span class="paramname"><em>destination_address_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously write a datagram to a communications socket. The data is represented as an array of address pointers and sizes. This data is copied inside of the function so once it returns the buffer(s) are available for reuse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket through which the datagram will be written. </td></tr>
    <tr><td class="paramname">iov</td><td>The address of an array of iovec structures which specify the data to be sent. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of iovec structures contained in the iov array. This value is limited to RMT_OS_SOCKET_MAX_IOVCNT. </td></tr>
    <tr><td class="paramname">destination_address_ptr</td><td>Pointer to the destination (IP address and port number) to which to send the UDP packet. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>The address of a location into which the number of bytes written to the socket will be placed if the datagram was successfully sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the datagram was successfully sent, false if not. Note that there is no guarantee that the datagram was actually received by the destination host. </dd></dl>

</div>
</div>
<a id="a5716b7b1364e9a2ca7b2729e43b88d06" name="a5716b7b1364e9a2ca7b2729e43b88d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5716b7b1364e9a2ca7b2729e43b88d06">&#9670;&#160;</a></span>CdiOsSplitPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsSplitPath </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filepath_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>filename_buf_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>directory_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>directory_buf_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a filepath and breaks it into its component directory and filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath_str</td><td>String containing a path name and filename. </td></tr>
    <tr><td class="paramname">filename_str</td><td>String containing the filename without the path. Pass NULL for this parameter if the filename is not needed. </td></tr>
    <tr><td class="paramname">filename_buf_size</td><td>Size of the buffer sent for storing the filename string. </td></tr>
    <tr><td class="paramname">directory_str</td><td>String containing the directory path, including any end '/' without the filename. Pass NULL for this parameter if the directory path is not needed. </td></tr>
    <tr><td class="paramname">directory_buf_size</td><td>Size of the buffer sent for storing the directory path string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="af1eaf023562ecaecdf2ada6d35389b3a" name="af1eaf023562ecaecdf2ada6d35389b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1eaf023562ecaecdf2ada6d35389b3a">&#9670;&#160;</a></span>CdiOsStrCpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CdiOsStrCpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_str_len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A portable version of strcpy with range checking to replace Microsoft's strcpy_s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_str</td><td>Buffer to receive copied string. </td></tr>
    <tr><td class="paramname">max_str_len</td><td>Maximum number of characters to copy. This includes the terminating '\0'. </td></tr>
    <tr><td class="paramname">src_str</td><td>Source string to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters copied. </dd></dl>

</div>
</div>
<a id="a5d14e12c7b12b05e0e181715e7da3906" name="a5d14e12c7b12b05e0e181715e7da3906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d14e12c7b12b05e0e181715e7da3906">&#9670;&#160;</a></span>CdiOsThreadAllocData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsThreadAllocData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> *</td>          <td class="paramname"><span class="paramname"><em>handle_out_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a slot of thread-local storage. The slot is allocated once for the whole program, after which each thread can store and read private data from the slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_out_ptr</td><td>Returned handle for a thread data slot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="af41e664402cd3c6519c637b5c569395d" name="af41e664402cd3c6519c637b5c569395d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41e664402cd3c6519c637b5c569395d">&#9670;&#160;</a></span>CdiOsThreadCreatePinned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsThreadCreatePinned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ae81e397cf8839b0315e33bcc5d662b97">CdiThreadFuncName</a></td>          <td class="paramname"><span class="paramname"><em>thread_func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_id_out_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>thread_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>thread_func_arg_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>start_signal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cpu_affinity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a thread which can optionally be pinned to a specific CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_func</td><td>Pointer to a function for the thread. </td></tr>
    <tr><td class="paramname">thread_id_out_ptr</td><td>Pointer to CdiThreadID to return. </td></tr>
    <tr><td class="paramname">thread_name_str</td><td>Optional Thread Name for debugging and logging purposes (NULL if don't care). </td></tr>
    <tr><td class="paramname">thread_func_arg_ptr</td><td>Optional pointer to user data passed to the thread delegate. </td></tr>
    <tr><td class="paramname">start_signal</td><td>Optional signal used to start the thread. If NULL, thread starts running immediately. </td></tr>
    <tr><td class="paramname">cpu_affinity</td><td>Zero-based CPU number to pin this thread to, -1 to not pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ad6e196505946cb3855358fc0fa96c80b" name="ad6e196505946cb3855358fc0fa96c80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e196505946cb3855358fc0fa96c80b">&#9670;&#160;</a></span>CdiOsThreadFreeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsThreadFreeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a slot of thread-local storage. Should be called before program exit but after all threads are done using the slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle of thread data to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a925c06af6be8911fa814dd37b577d91a" name="a925c06af6be8911fa814dd37b577d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925c06af6be8911fa814dd37b577d91a">&#9670;&#160;</a></span>CdiOsThreadGetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsThreadGetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>content_out_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of this thread's copy of a thread-local storage slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to thread data slot. </td></tr>
    <tr><td class="paramname">content_out_ptr</td><td>Pointer to a variable which receives the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a04b56bf25bfd0072f4ef08bd5979337b" name="a04b56bf25bfd0072f4ef08bd5979337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b56bf25bfd0072f4ef08bd5979337b">&#9670;&#160;</a></span>CdiOsThreadGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CdiOsThreadGetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a></td>          <td class="paramname"><span class="paramname"><em>thread_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the thread that was created using <a class="el" href="cdi__os__api_8h.html#aadf0876a49820a51991452ac6e282537">CdiOsThreadCreatePinned()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Data structure for thread to get name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to name of the thread. </dd></dl>

</div>
</div>
<a id="aacef38627440f8e65e0a4af37e8ed293" name="aacef38627440f8e65e0a4af37e8ed293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacef38627440f8e65e0a4af37e8ed293">&#9670;&#160;</a></span>CdiOsThreadJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsThreadJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a></td>          <td class="paramname"><span class="paramname"><em>thread_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>timed_out_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits/blocks until the given thread has finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Data structure for thread to wait for. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>How long to wait for join before timing out. </td></tr>
    <tr><td class="paramname">timed_out_ptr</td><td>Pointer to a boolean that indicates a timeout has occurred when true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a235d66e1158b08b4bc7230ef39c25598" name="a235d66e1158b08b4bc7230ef39c25598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235d66e1158b08b4bc7230ef39c25598">&#9670;&#160;</a></span>CdiOsThreadSetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsThreadSetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>content_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a value in this thread's copy of a thread-local storage slot. Calls to osThreadGetData from the same thread will get this value back. The slot must have been allocated by CdiOsThreadAllocData.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to thread data slot. </td></tr>
    <tr><td class="paramname">content_ptr</td><td>Pointer to be stored in the slot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="aa2d90148bb293124b995ef5f8b1e6885" name="aa2d90148bb293124b995ef5f8b1e6885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d90148bb293124b995ef5f8b1e6885">&#9670;&#160;</a></span>CdiOsUseLogger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdiOsUseLogger </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable use of the logger when generating error messages. This function is normally used internally as part of initialization of the CDI SDK. If it is not used, then output will be directed to stderr. </p>

</div>
</div>
<a id="aa0a44d71a1dec2c25bd5443bb5e9a07c" name="aa0a44d71a1dec2c25bd5443bb5e9a07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a44d71a1dec2c25bd5443bb5e9a07c">&#9670;&#160;</a></span>CdiOsWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CdiOsWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>byte_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of file to write to. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>Pointer to data to write. </td></tr>
    <tr><td class="paramname">byte_count</td><td>Number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ad62e301797317b873763a31e3e538961" name="ad62e301797317b873763a31e3e538961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62e301797317b873763a31e3e538961">&#9670;&#160;</a></span>GetTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void GetTimeout </td>
          <td>(</td>
          <td class="paramtype">struct timespec *</td>          <td class="paramname"><span class="paramname"><em>spec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>num_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clockid_t</td>          <td class="paramname"><span class="paramname"><em>clock_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the time for a given delay (timeout) and return it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>A timespec pointer for the resulting time calculation. </td></tr>
    <tr><td class="paramname">num_ms</td><td>The number of milliseconds into the future to calculate. </td></tr>
    <tr><td class="paramname">clock_id</td><td>Clock to use (CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2d56d8351d17ed553f501fd1fbd66d" name="a2c2d56d8351d17ed553f501fd1fbd66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2d56d8351d17ed553f501fd1fbd66d">&#9670;&#160;</a></span>LogMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LogMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__log__enums_8h.html#a419726836ec976c1dfbd9293d5f64705">CdiLogLevel</a></td>          <td class="paramname"><span class="paramname"><em>level</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate an error message and send to logger or stderr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The log level. </td></tr>
    <tr><td class="paramname">func_name_str</td><td>Pointer to function name string. </td></tr>
    <tr><td class="paramname">line</td><td>Source line number. </td></tr>
    <tr><td class="paramname">format_str</td><td>Pointer to format string. </td></tr>
    <tr><td class="paramname">...</td><td>Variable length list of message arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff2e059e1c7b75131e450ac31b0b94e0" name="aff2e059e1c7b75131e450ac31b0b94e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2e059e1c7b75131e450ac31b0b94e0">&#9670;&#160;</a></span>PopulateSigAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PopulateSigAction </td>
          <td>(</td>
          <td class="paramtype">struct sigaction *</td>          <td class="paramname"><span class="paramname"><em>sig_act_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a75656dffadf2d578ae0316591674bef3">CdiSignalHandlerFunction</a></td>          <td class="paramname"><span class="paramname"><em>func_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This populates the sigaction structure with the appropriate flags and user-defined callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig_act_ptr</td><td>The pointer to the sigaction structure. </td></tr>
    <tr><td class="paramname">func_ptr</td><td>The pointer to the callback that executes on an intercepted signal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1867814de8b653289b65042f558f78" name="abc1867814de8b653289b65042f558f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1867814de8b653289b65042f558f78">&#9670;&#160;</a></span>SocketWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SocketWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct msghdr *</td>          <td class="paramname"><span class="paramname"><em>msg_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to write an IPv4 UDP packet through a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle of the socket through which to send the UDP packet. </td></tr>
    <tr><td class="paramname">msg_ptr</td><td>Structure with the details of the packet and optionally the destination address/port. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>Address where to write the number of bytes written to the socket; this pointer is only accessed if the function returns true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the write was successful, false if not. </dd></dl>

</div>
</div>
<a id="abec6f84b5a7ab852d719de3eb7fe838e" name="abec6f84b5a7ab852d719de3eb7fe838e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec6f84b5a7ab852d719de3eb7fe838e">&#9670;&#160;</a></span>ThreadFuncHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * ThreadFuncHelper </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>thread_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When we create a thread, we use ThreadFuncHelper so that the is_done signal can be set. The only reason for this is so we can timeout when we try to join the thread. (Our osSignalWait can timeout but pthread_join can't.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_ptr</td><td>The pointer to the thread info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
