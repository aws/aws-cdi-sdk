<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: src/cdi/configuration.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_440858bc2ff41f5ef15b020e90223871.html">cdi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">configuration.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This header file contains definitions used to define the build configuration of the CDI SDK's implementation.  
<a href="#details">More...</a></p>

<p><a href="configuration_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5b9c26209597d30296a0696d57c19720" id="r_a5b9c26209597d30296a0696d57c19720"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9c26209597d30296a0696d57c19720">HD_TO_4K_FACTOR</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a5b9c26209597d30296a0696d57c19720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable to debug packet sequences. NOTE: This generates a lot of debug output.  <br /></td></tr>
<tr class="separator:a5b9c26209597d30296a0696d57c19720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde6589ff81873d8e53d5a45f777546" id="r_adfde6589ff81873d8e53d5a45f777546"><td class="memItemLeft" align="right" valign="top"><a id="adfde6589ff81873d8e53d5a45f777546" name="adfde6589ff81873d8e53d5a45f777546"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GROW_COUNT</b>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:adfde6589ff81873d8e53d5a45f777546"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used for pools that will not grow when they become empty. <br /></td></tr>
<tr class="separator:adfde6589ff81873d8e53d5a45f777546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27948aafb1a6cb00b320b34836281fcd" id="r_a27948aafb1a6cb00b320b34836281fcd"><td class="memItemLeft" align="right" valign="top"><a id="a27948aafb1a6cb00b320b34836281fcd" name="a27948aafb1a6cb00b320b34836281fcd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GROW_SIZE</b>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a27948aafb1a6cb00b320b34836281fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used for pools that will not grow when they become empty. <br /></td></tr>
<tr class="separator:a27948aafb1a6cb00b320b34836281fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf0222035ebcdf3c11cb35556584185" id="r_adaf0222035ebcdf3c11cb35556584185"><td class="memItemLeft" align="right" valign="top"><a id="adaf0222035ebcdf3c11cb35556584185" name="adaf0222035ebcdf3c11cb35556584185"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_RX_OUT_OF_ORDER</b>&#160;&#160;&#160;(128)</td></tr>
<tr class="memdesc:adaf0222035ebcdf3c11cb35556584185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of out of order packets that can be received. <br /></td></tr>
<tr class="separator:adaf0222035ebcdf3c11cb35556584185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bab94c40ccd34b2a5a945f40e5b3d55" id="r_a5bab94c40ccd34b2a5a945f40e5b3d55"><td class="memItemLeft" align="right" valign="top"><a id="a5bab94c40ccd34b2a5a945f40e5b3d55" name="a5bab94c40ccd34b2a5a945f40e5b3d55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_RX_OUT_OF_ORDER_GROW</b>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:a5bab94c40ccd34b2a5a945f40e5b3d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number out of order packets buffer can be increased by. <br /></td></tr>
<tr class="separator:a5bab94c40ccd34b2a5a945f40e5b3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f36c9ebfcc3d6687982ec6a1c5a7b6" id="r_a31f36c9ebfcc3d6687982ec6a1c5a7b6"><td class="memItemLeft" align="right" valign="top"><a id="a31f36c9ebfcc3d6687982ec6a1c5a7b6" name="a31f36c9ebfcc3d6687982ec6a1c5a7b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_ERROR_STRING_LENGTH</b>&#160;&#160;&#160;(1024)</td></tr>
<tr class="memdesc:a31f36c9ebfcc3d6687982ec6a1c5a7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of error string message. <br /></td></tr>
<tr class="separator:a31f36c9ebfcc3d6687982ec6a1c5a7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26239b5e80852f9918e6da6074b64046" id="r_a26239b5e80852f9918e6da6074b64046"><td class="memItemLeft" align="right" valign="top"><a id="a26239b5e80852f9918e6da6074b64046" name="a26239b5e80852f9918e6da6074b64046"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_IP_STRING_LENGTH</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="memdesc:a26239b5e80852f9918e6da6074b64046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum IP string length. <br /></td></tr>
<tr class="separator:a26239b5e80852f9918e6da6074b64046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c12a9b71a34bebb6fde6de5a8ffde0b" id="r_a3c12a9b71a34bebb6fde6de5a8ffde0b"><td class="memItemLeft" align="right" valign="top"><a id="a3c12a9b71a34bebb6fde6de5a8ffde0b" name="a3c12a9b71a34bebb6fde6de5a8ffde0b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_IPV6_GID_LENGTH</b>&#160;&#160;&#160;(32)</td></tr>
<tr class="memdesc:a3c12a9b71a34bebb6fde6de5a8ffde0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum EFA device GID length. Contains GID + QPN (see efa_ep_addr). <br /></td></tr>
<tr class="separator:a3c12a9b71a34bebb6fde6de5a8ffde0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8445d446a46d113c4ae897e1bc7a0d" id="r_a3f8445d446a46d113c4ae897e1bc7a0d"><td class="memItemLeft" align="right" valign="top"><a id="a3f8445d446a46d113c4ae897e1bc7a0d" name="a3f8445d446a46d113c4ae897e1bc7a0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_IPV6_ADDRESS_STRING_LENGTH</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="memdesc:a3f8445d446a46d113c4ae897e1bc7a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum IPV6 address string length. <br /></td></tr>
<tr class="separator:a3f8445d446a46d113c4ae897e1bc7a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19d07aecb19a0dc0f9e67fe97d41810" id="r_ad19d07aecb19a0dc0f9e67fe97d41810"><td class="memItemLeft" align="right" valign="top"><a id="ad19d07aecb19a0dc0f9e67fe97d41810" name="ad19d07aecb19a0dc0f9e67fe97d41810"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_POOL_NAME_LENGTH</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="memdesc:ad19d07aecb19a0dc0f9e67fe97d41810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of memory pool name that is stored internally in <a class="el" href="pool_8c.html" title="This file contains definitions and implementation for a memory pool.">pool.c</a>. <br /></td></tr>
<tr class="separator:ad19d07aecb19a0dc0f9e67fe97d41810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382358a178b0f4225862ecf6568f23dc" id="r_a382358a178b0f4225862ecf6568f23dc"><td class="memItemLeft" align="right" valign="top"><a id="a382358a178b0f4225862ecf6568f23dc" name="a382358a178b0f4225862ecf6568f23dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_FIFO_NAME_LENGTH</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="memdesc:a382358a178b0f4225862ecf6568f23dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the FIFO name that is stored internally in <a class="el" href="fifo_8c.html" title="This file contains definitions and implementation for a simple FIFO.">fifo.c</a>. <br /></td></tr>
<tr class="separator:a382358a178b0f4225862ecf6568f23dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49735de83103d60dc273a0519032d4a" id="r_af49735de83103d60dc273a0519032d4a"><td class="memItemLeft" align="right" valign="top"><a id="af49735de83103d60dc273a0519032d4a" name="af49735de83103d60dc273a0519032d4a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_PAYLOADS_PER_CONNECTION</b>&#160;&#160;&#160;(100)</td></tr>
<tr class="memdesc:af49735de83103d60dc273a0519032d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of payloads for a single connection. <br /></td></tr>
<tr class="separator:af49735de83103d60dc273a0519032d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d53db09214512c33284b37504c2bf5d" id="r_a3d53db09214512c33284b37504c2bf5d"><td class="memItemLeft" align="right" valign="top"><a id="a3d53db09214512c33284b37504c2bf5d" name="a3d53db09214512c33284b37504c2bf5d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TX_PACKET_WORK_REQUESTS_PER_CONNECTION</b>&#160;&#160;&#160;(3000*<a class="el" href="#a5b9c26209597d30296a0696d57c19720">HD_TO_4K_FACTOR</a>)</td></tr>
<tr class="memdesc:a3d53db09214512c33284b37504c2bf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of Tx packet work requests per connection. <br /></td></tr>
<tr class="separator:a3d53db09214512c33284b37504c2bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab857b3854f4540ffb6a0c05dcd2107aa" id="r_ab857b3854f4540ffb6a0c05dcd2107aa"><td class="memItemLeft" align="right" valign="top"><a id="ab857b3854f4540ffb6a0c05dcd2107aa" name="ab857b3854f4540ffb6a0c05dcd2107aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_AVM_PACKET_HEADER_POOL_SIZE_PER_CONNECTION</b>&#160;&#160;&#160;(100)</td></tr>
<tr class="memdesc:ab857b3854f4540ffb6a0c05dcd2107aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Tx AVM packet header pool entries available for a Tx connection. The pool is used to hold user-specified AVM configuration data that is associated with a payload. The memory allocated must be part of the DMA Tx memory region. <br /></td></tr>
<tr class="separator:ab857b3854f4540ffb6a0c05dcd2107aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa6091530e10a81bc6d92e85ab9b52a" id="r_a9fa6091530e10a81bc6d92e85ab9b52a"><td class="memItemLeft" align="right" valign="top"><a id="a9fa6091530e10a81bc6d92e85ab9b52a" name="a9fa6091530e10a81bc6d92e85ab9b52a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_PACKET_SGL_ENTRY_SIZE_PER_CONNECTION</b>&#160;&#160;&#160;(3000*<a class="el" href="#a5b9c26209597d30296a0696d57c19720">HD_TO_4K_FACTOR</a>)</td></tr>
<tr class="memdesc:a9fa6091530e10a81bc6d92e85ab9b52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial number of SGL entries in a tx payload. <br /></td></tr>
<tr class="separator:a9fa6091530e10a81bc6d92e85ab9b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643cf3ac43543c28fbd9dc0fab22941b" id="r_a643cf3ac43543c28fbd9dc0fab22941b"><td class="memItemLeft" align="right" valign="top"><a id="a643cf3ac43543c28fbd9dc0fab22941b" name="a643cf3ac43543c28fbd9dc0fab22941b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_PACKET_SGL_ENTRY_SIZE_PER_CONNECTION_GROW</b>&#160;&#160;&#160;(500)</td></tr>
<tr class="memdesc:a643cf3ac43543c28fbd9dc0fab22941b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries the tx payload SGL list may be increased by. <br /></td></tr>
<tr class="separator:a643cf3ac43543c28fbd9dc0fab22941b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01edd1a906d4d11ad8e7830ba1f1c082" id="r_a01edd1a906d4d11ad8e7830ba1f1c082"><td class="memItemLeft" align="right" valign="top"><a id="a01edd1a906d4d11ad8e7830ba1f1c082" name="a01edd1a906d4d11ad8e7830ba1f1c082"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TX_PACKETS_PER_CONNECTION</b>&#160;&#160;&#160;(3000*<a class="el" href="#a5b9c26209597d30296a0696d57c19720">HD_TO_4K_FACTOR</a>)</td></tr>
<tr class="memdesc:a01edd1a906d4d11ad8e7830ba1f1c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of transmit packets per payload. Additional objects are needed due to the asynchronous nature of the API. Multiple payload transmissions may overlap. <br /></td></tr>
<tr class="separator:a01edd1a906d4d11ad8e7830ba1f1c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84ed46dfbedf6b0d8ec333f781a1ae4" id="r_ad84ed46dfbedf6b0d8ec333f781a1ae4"><td class="memItemLeft" align="right" valign="top"><a id="ad84ed46dfbedf6b0d8ec333f781a1ae4" name="ad84ed46dfbedf6b0d8ec333f781a1ae4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_PACKET_POOL_SIZE_GROW</b>&#160;&#160;&#160;(100)</td></tr>
<tr class="memdesc:ad84ed46dfbedf6b0d8ec333f781a1ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries the tx packet queue may be increased by. <br /></td></tr>
<tr class="separator:ad84ed46dfbedf6b0d8ec333f781a1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0943d373e68f2ce3b019714ef596cc" id="r_a2a0943d373e68f2ce3b019714ef596cc"><td class="memItemLeft" align="right" valign="top"><a id="a2a0943d373e68f2ce3b019714ef596cc" name="a2a0943d373e68f2ce3b019714ef596cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TX_PACKET_BATCHES_PER_CONNECTION</b>&#160;&#160;&#160;(12*<a class="el" href="#a5b9c26209597d30296a0696d57c19720">HD_TO_4K_FACTOR</a>)</td></tr>
<tr class="memdesc:a2a0943d373e68f2ce3b019714ef596cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of batches of transmit packets allowed to send to an endpoint. Transmit packets are sent in ever increasingly sized batches so the number of batches is approximately log[base2](packets). <br /></td></tr>
<tr class="separator:a2a0943d373e68f2ce3b019714ef596cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a12ac75f6a9fdddd22f548015f5df3" id="r_af8a12ac75f6a9fdddd22f548015f5df3"><td class="memItemLeft" align="right" valign="top"><a id="af8a12ac75f6a9fdddd22f548015f5df3" name="af8a12ac75f6a9fdddd22f548015f5df3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_PACKET_SEND_QUEUE_SIZE_GROW</b>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:af8a12ac75f6a9fdddd22f548015f5df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries the tx packet queue may be increased by. <br /></td></tr>
<tr class="separator:af8a12ac75f6a9fdddd22f548015f5df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7951f46f6c118403bdc1f458bde8ef5e" id="r_a7951f46f6c118403bdc1f458bde8ef5e"><td class="memItemLeft" align="right" valign="top"><a id="a7951f46f6c118403bdc1f458bde8ef5e" name="a7951f46f6c118403bdc1f458bde8ef5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TX_SGL_PACKET_ENTRIES</b>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a7951f46f6c118403bdc1f458bde8ef5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of SGL entries for a single transmit packet. <br /></td></tr>
<tr class="separator:a7951f46f6c118403bdc1f458bde8ef5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7d46319deb92056ec6bd67f7eb44e9" id="r_aab7d46319deb92056ec6bd67f7eb44e9"><td class="memItemLeft" align="right" valign="top"><a id="aab7d46319deb92056ec6bd67f7eb44e9" name="aab7d46319deb92056ec6bd67f7eb44e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SIMULTANEOUS_TX_PACKET_LIMIT</b>&#160;&#160;&#160;(50)</td></tr>
<tr class="memdesc:aab7d46319deb92056ec6bd67f7eb44e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of packets that can be simultaneously queued for transmission without receiving a corresponding completion event (ACK or error). <br /></td></tr>
<tr class="separator:aab7d46319deb92056ec6bd67f7eb44e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae994c6cee481cfe0886fffc1ba43e35c" id="r_ae994c6cee481cfe0886fffc1ba43e35c"><td class="memItemLeft" align="right" valign="top"><a id="ae994c6cee481cfe0886fffc1ba43e35c" name="ae994c6cee481cfe0886fffc1ba43e35c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TX_BULK_COMPLETION_QUEUE_MESSAGES</b>&#160;&#160;&#160;(<a class="el" href="#aab7d46319deb92056ec6bd67f7eb44e9">SIMULTANEOUS_TX_PACKET_LIMIT</a>)</td></tr>
<tr class="memdesc:ae994c6cee481cfe0886fffc1ba43e35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of completion queue messages to process in a single Tx poll call. <br /></td></tr>
<tr class="separator:ae994c6cee481cfe0886fffc1ba43e35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd4899eb7652bb38d33e052f8e5e91c" id="r_abfd4899eb7652bb38d33e052f8e5e91c"><td class="memItemLeft" align="right" valign="top"><a id="abfd4899eb7652bb38d33e052f8e5e91c" name="abfd4899eb7652bb38d33e052f8e5e91c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_RX_BULK_COMPLETION_QUEUE_MESSAGES</b>&#160;&#160;&#160;(50)</td></tr>
<tr class="memdesc:abfd4899eb7652bb38d33e052f8e5e91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of completion queue messages to process in a single Rx poll call. <br /></td></tr>
<tr class="separator:abfd4899eb7652bb38d33e052f8e5e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157a2bff2ce8a2db7cd2344e07f10b14" id="r_a157a2bff2ce8a2db7cd2344e07f10b14"><td class="memItemLeft" align="right" valign="top"><a id="a157a2bff2ce8a2db7cd2344e07f10b14" name="a157a2bff2ce8a2db7cd2344e07f10b14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_RX_PACKETS_PER_CONNECTION</b>&#160;&#160;&#160;(10000)</td></tr>
<tr class="memdesc:a157a2bff2ce8a2db7cd2344e07f10b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial number of rx packets in a connection. <br /></td></tr>
<tr class="separator:a157a2bff2ce8a2db7cd2344e07f10b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67da2b3ff99cd66116b4299c52f042e" id="r_ab67da2b3ff99cd66116b4299c52f042e"><td class="memItemLeft" align="right" valign="top"><a id="ab67da2b3ff99cd66116b4299c52f042e" name="ab67da2b3ff99cd66116b4299c52f042e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_RX_PACKETS_PER_CONNECTION_GROW</b>&#160;&#160;&#160;(500)</td></tr>
<tr class="memdesc:ab67da2b3ff99cd66116b4299c52f042e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries the rx packet connection list may be increased by. <br /></td></tr>
<tr class="separator:ab67da2b3ff99cd66116b4299c52f042e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eba5d270e63355daf87f5b6d0c2cf91" id="r_a5eba5d270e63355daf87f5b6d0c2cf91"><td class="memItemLeft" align="right" valign="top"><a id="a5eba5d270e63355daf87f5b6d0c2cf91" name="a5eba5d270e63355daf87f5b6d0c2cf91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RX_SOCKET_BUFFER_SIZE</b>&#160;&#160;&#160;(1000)</td></tr>
<tr class="memdesc:a5eba5d270e63355daf87f5b6d0c2cf91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial number of rx sockets. <br /></td></tr>
<tr class="separator:a5eba5d270e63355daf87f5b6d0c2cf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280e940111a4a0a154481bd31befe5ae" id="r_a280e940111a4a0a154481bd31befe5ae"><td class="memItemLeft" align="right" valign="top"><a id="a280e940111a4a0a154481bd31befe5ae" name="a280e940111a4a0a154481bd31befe5ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RX_SOCKET_BUFFER_SIZE_GROW</b>&#160;&#160;&#160;(100)</td></tr>
<tr class="memdesc:a280e940111a4a0a154481bd31befe5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries the rx socket list may be increased by. <br /></td></tr>
<tr class="separator:a280e940111a4a0a154481bd31befe5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b26fc1ef0f5fbe2f3592af85089bd07" id="r_a1b26fc1ef0f5fbe2f3592af85089bd07"><td class="memItemLeft" align="right" valign="top"><a id="a1b26fc1ef0f5fbe2f3592af85089bd07" name="a1b26fc1ef0f5fbe2f3592af85089bd07"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_ENDPOINT_COMMAND_QUEUE_SIZE</b>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:a1b26fc1ef0f5fbe2f3592af85089bd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the endpoint command queue used by the Endpoint Manager. <br /></td></tr>
<tr class="separator:a1b26fc1ef0f5fbe2f3592af85089bd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a8d5e6731e5e5d00a705f181d98b36" id="r_ab2a8d5e6731e5e5d00a705f181d98b36"><td class="memItemLeft" align="right" valign="top"><a id="ab2a8d5e6731e5e5d00a705f181d98b36" name="ab2a8d5e6731e5e5d00a705f181d98b36"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_POOL_GROW_COUNT</b>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:ab2a8d5e6731e5e5d00a705f181d98b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of times a pool may grow in size before an error occurs. <br /></td></tr>
<tr class="separator:ab2a8d5e6731e5e5d00a705f181d98b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cf07d88735330d1920c1cdf6c49eb2" id="r_a46cf07d88735330d1920c1cdf6c49eb2"><td class="memItemLeft" align="right" valign="top"><a id="a46cf07d88735330d1920c1cdf6c49eb2" name="a46cf07d88735330d1920c1cdf6c49eb2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_QUEUE_GROW_COUNT</b>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:a46cf07d88735330d1920c1cdf6c49eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of times a queue may grow in size before an error occurs. <br /></td></tr>
<tr class="separator:a46cf07d88735330d1920c1cdf6c49eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac949d46c538c622766cca1d8bf8b4cc6" id="r_ac949d46c538c622766cca1d8bf8b4cc6"><td class="memItemLeft" align="right" valign="top"><a id="ac949d46c538c622766cca1d8bf8b4cc6" name="ac949d46c538c622766cca1d8bf8b4cc6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_MSG_PREFIX_SIZE</b>&#160;&#160;&#160;(22 * 8)</td></tr>
<tr class="memdesc:ac949d46c538c622766cca1d8bf8b4cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The space reserved for the libfabric message prefix in our packet header. This must be set to be equal or larger than the largest prefix size needed by the EFA provider. It must be a multiple of 8. See <a href="https://ofiwg.github.io/libfabric/v1.13.0/man/fi_msg.3.html#notes">https://ofiwg.github.io/libfabric/v1.13.0/man/fi_msg.3.html#notes</a>. <br /></td></tr>
<tr class="separator:ac949d46c538c622766cca1d8bf8b4cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fde9deb9c0a043e313de8d92ee77a9" id="r_a73fde9deb9c0a043e313de8d92ee77a9"><td class="memItemLeft" align="right" valign="top"><a id="a73fde9deb9c0a043e313de8d92ee77a9" name="a73fde9deb9c0a043e313de8d92ee77a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_TX_PACKET_CACHE_SIZE</b>&#160;&#160;&#160;(16)</td></tr>
<tr class="memdesc:a73fde9deb9c0a043e313de8d92ee77a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Tx packets to cache before notifying libfabric to ring the NIC's doorbell. <br /></td></tr>
<tr class="separator:a73fde9deb9c0a043e313de8d92ee77a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd097fa0bcf8f88880fb409ea951b84" id="r_a7dd097fa0bcf8f88880fb409ea951b84"><td class="memItemLeft" align="right" valign="top"><a id="a7dd097fa0bcf8f88880fb409ea951b84" name="a7dd097fa0bcf8f88880fb409ea951b84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_RX_PACKET_BUFFER_CACHE_SIZE</b>&#160;&#160;&#160;(16)</td></tr>
<tr class="memdesc:a7dd097fa0bcf8f88880fb409ea951b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Rx buffer posts to cache before notifying libfabric to ring the NIC's doorbell. <br /></td></tr>
<tr class="separator:a7dd097fa0bcf8f88880fb409ea951b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f12f9d76de101a15cd46ec72e63332d" id="r_a2f12f9d76de101a15cd46ec72e63332d"><td class="memItemLeft" align="right" valign="top"><a id="a2f12f9d76de101a15cd46ec72e63332d" name="a2f12f9d76de101a15cd46ec72e63332d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_CQ_READ_SIZE</b>&#160;&#160;&#160;(50)</td></tr>
<tr class="memdesc:a2f12f9d76de101a15cd46ec72e63332d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of read completion queue entries. Current libfabric default is 50. <br /></td></tr>
<tr class="separator:a2f12f9d76de101a15cd46ec72e63332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3561370ae05edbb9d1dc6bd0a7f36fc" id="r_aa3561370ae05edbb9d1dc6bd0a7f36fc"><td class="memItemLeft" align="right" valign="top"><a id="aa3561370ae05edbb9d1dc6bd0a7f36fc" name="aa3561370ae05edbb9d1dc6bd0a7f36fc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROBE_RX_PACKET_BUFFERS_PER_CONNECTION</b>&#160;&#160;&#160;(100)</td></tr>
<tr class="memdesc:aa3561370ae05edbb9d1dc6bd0a7f36fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of probe Rx packet buffers to reserve per connection. <br /></td></tr>
<tr class="separator:aa3561370ae05edbb9d1dc6bd0a7f36fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac342590af5070c658128d4a3e145cfdf" id="r_ac342590af5070c658128d4a3e145cfdf"><td class="memItemLeft" align="right" valign="top"><a id="ac342590af5070c658128d4a3e145cfdf" name="ac342590af5070c658128d4a3e145cfdf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_PROBE_CONTROL_COMMANDS_PER_CONNECTION</b>&#160;&#160;&#160;(20)</td></tr>
<tr class="memdesc:ac342590af5070c658128d4a3e145cfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of control interface commands per connection. <br /></td></tr>
<tr class="separator:ac342590af5070c658128d4a3e145cfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336c0c764b605e5c7d1843be3ebecdd8" id="r_a336c0c764b605e5c7d1843be3ebecdd8"><td class="memItemLeft" align="right" valign="top"><a id="a336c0c764b605e5c7d1843be3ebecdd8" name="a336c0c764b605e5c7d1843be3ebecdd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONTROL_INTERFACE_TX_BUFFER_SIZE_BYTES</b>&#160;&#160;&#160;(4096)</td></tr>
<tr class="memdesc:a336c0c764b605e5c7d1843be3ebecdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of control interface transfer buffer size in bytes. <br /></td></tr>
<tr class="separator:a336c0c764b605e5c7d1843be3ebecdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507755076c46e7166ab5e9c8a0c3900f" id="r_a507755076c46e7166ab5e9c8a0c3900f"><td class="memItemLeft" align="right" valign="top"><a id="a507755076c46e7166ab5e9c8a0c3900f" name="a507755076c46e7166ab5e9c8a0c3900f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RX_RESET_COMMAND_MAX_RETRIES</b>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:a507755076c46e7166ab5e9c8a0c3900f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used by the receiver to define how many times a reset command is sent without receiving any responses before destroying the Rx endpoint. <br /></td></tr>
<tr class="separator:a507755076c46e7166ab5e9c8a0c3900f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed07dd7de5a9d00dab949f46a9325b5" id="r_afed07dd7de5a9d00dab949f46a9325b5"><td class="memItemLeft" align="right" valign="top"><a id="afed07dd7de5a9d00dab949f46a9325b5" name="afed07dd7de5a9d00dab949f46a9325b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEND_RESET_COMMAND_FREQUENCY_MSEC</b>&#160;&#160;&#160;(2000)</td></tr>
<tr class="memdesc:afed07dd7de5a9d00dab949f46a9325b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how often a reset command is sent to the remote target using the control interface. The value is in milliseconds. <br /></td></tr>
<tr class="separator:afed07dd7de5a9d00dab949f46a9325b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b75c0727f13496c1aa2d00f874a5cff" id="r_a6b75c0727f13496c1aa2d00f874a5cff"><td class="memItemLeft" align="right" valign="top"><a id="a6b75c0727f13496c1aa2d00f874a5cff" name="a6b75c0727f13496c1aa2d00f874a5cff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ENDPOINT_MANAGER_COMPLETION_TIMEOUT_MSEC</b>&#160;&#160;&#160;(1000)</td></tr>
<tr class="memdesc:a6b75c0727f13496c1aa2d00f874a5cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once a command has been sent to the Endpoint Manager, this defines how long to wait before it completes. <br /></td></tr>
<tr class="separator:a6b75c0727f13496c1aa2d00f874a5cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75bd0b5b71ee28600c48a13448c2418" id="r_ae75bd0b5b71ee28600c48a13448c2418"><td class="memItemLeft" align="right" valign="top"><a id="ae75bd0b5b71ee28600c48a13448c2418" name="ae75bd0b5b71ee28600c48a13448c2418"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_CONNECTION_DELAY_MSEC</b>&#160;&#160;&#160;(1000)</td></tr>
<tr class="memdesc:ae75bd0b5b71ee28600c48a13448c2418"><td class="mdescLeft">&#160;</td><td class="mdescRight">After probe packet ACKs have been received, this is how long to wait before changing to the connected state. The value is in milliseconds. <br /></td></tr>
<tr class="separator:ae75bd0b5b71ee28600c48a13448c2418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebbc64bfbfcd914e18805c72fdf67d3" id="r_a8ebbc64bfbfcd914e18805c72fdf67d3"><td class="memItemLeft" align="right" valign="top"><a id="a8ebbc64bfbfcd914e18805c72fdf67d3" name="a8ebbc64bfbfcd914e18805c72fdf67d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEND_PING_COMMAND_FREQUENCY_MSEC</b>&#160;&#160;&#160;(5000)</td></tr>
<tr class="memdesc:a8ebbc64bfbfcd914e18805c72fdf67d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once a connection has been established, this defines how often the transmitter sends a ping to command to the receiver using the control interface. The value is in milliseconds. <br /></td></tr>
<tr class="separator:a8ebbc64bfbfcd914e18805c72fdf67d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49748f3a9dca2d8d366657d423098d38" id="r_a49748f3a9dca2d8d366657d423098d38"><td class="memItemLeft" align="right" valign="top"><a id="a49748f3a9dca2d8d366657d423098d38" name="a49748f3a9dca2d8d366657d423098d38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_COMMAND_MAX_RETRIES</b>&#160;&#160;&#160;(40)</td></tr>
<tr class="memdesc:a49748f3a9dca2d8d366657d423098d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used by the transmitter to define how many times a command is sent without receiving an ACK reply before going into connection reset mode. <br /></td></tr>
<tr class="separator:a49748f3a9dca2d8d366657d423098d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deba3198864b8f87597d09400495a8b" id="r_a9deba3198864b8f87597d09400495a8b"><td class="memItemLeft" align="right" valign="top"><a id="a9deba3198864b8f87597d09400495a8b" name="a9deba3198864b8f87597d09400495a8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_COMMAND_ACK_TIMEOUT_MSEC</b>&#160;&#160;&#160;(500)</td></tr>
<tr class="memdesc:a9deba3198864b8f87597d09400495a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used by the transmitter to define how long it waits for an ACK response to a command that it sent. If the timeout expires, the same command will be sent up to the amount specified by <a class="el" href="#a49748f3a9dca2d8d366657d423098d38" title="This value is used by the transmitter to define how many times a command is sent without receiving an...">TX_COMMAND_MAX_RETRIES</a>. Once the specified number of attempts has been exhausted, the transmitter will go into connection reset mode. The value is in milliseconds. <br /></td></tr>
<tr class="separator:a9deba3198864b8f87597d09400495a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec1b81a8d43ccc9df29fc1801018f42" id="r_acec1b81a8d43ccc9df29fc1801018f42"><td class="memItemLeft" align="right" valign="top"><a id="acec1b81a8d43ccc9df29fc1801018f42" name="acec1b81a8d43ccc9df29fc1801018f42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RX_PING_MONITOR_TIMEOUT_MSEC</b>&#160;&#160;&#160;(5000 + (<a class="el" href="#a8ebbc64bfbfcd914e18805c72fdf67d3">SEND_PING_COMMAND_FREQUENCY_MSEC</a>*3))</td></tr>
<tr class="memdesc:acec1b81a8d43ccc9df29fc1801018f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how long the receiver waits for a ping command from the remote target before changing to connection reset mode. The value is in milliseconds. This should be long enough to avoid false disconnects due to a few TX ping packets getting dropped. <br /></td></tr>
<tr class="separator:acec1b81a8d43ccc9df29fc1801018f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a1169b5682c1965eb6535b2a113aa3" id="r_ab8a1169b5682c1965eb6535b2a113aa3"><td class="memItemLeft" align="right" valign="top"><a id="ab8a1169b5682c1965eb6535b2a113aa3" name="ab8a1169b5682c1965eb6535b2a113aa3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_PROBE_PACKET_BUFFER_COUNT</b>&#160;&#160;&#160;(<a class="el" href="cdi__core__api_8h.html#a449dd605005c96edcfd007699024e7e4">CDI_MAX_SIMULTANEOUS_CONNECTIONS</a>*<a class="el" href="cdi__core__api_8h.html#a8683afaefd3fd41547cad17795f9e2dc">CDI_MAX_ENDPOINTS_PER_CONNECTION</a>)</td></tr>
<tr class="memdesc:ab8a1169b5682c1965eb6535b2a113aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the number of EFA interface Tx probe packet buffers to allocate in DMA memory. Each probe endpoint uses one packet buffer, so this value sets the maximum number of endpoints that can simultaneously be probing. The memory region is reserved as part EFA adapter initialization. It is internally added by the SDK to the size specified by <a class="el" href="structCdiAdapterData.html#a31b4864d0f3de2eb5034e43e3980e17e" title="The size in bytes of a memory region for holding payload data to transmit. If no transmit connections...">CdiAdapterData.tx_buffer_size_bytes</a>. <br /></td></tr>
<tr class="separator:ab8a1169b5682c1965eb6535b2a113aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d53d098ca51a76a59c74cccd5256df" id="r_a36d53d098ca51a76a59c74cccd5256df"><td class="memItemLeft" align="right" valign="top"><a id="a36d53d098ca51a76a59c74cccd5256df" name="a36d53d098ca51a76a59c74cccd5256df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_PROBE_PACKET_DATA_SIZE</b>&#160;&#160;&#160;(1024)</td></tr>
<tr class="memdesc:a36d53d098ca51a76a59c74cccd5256df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the EFA interface probe packet data size. <br /></td></tr>
<tr class="separator:a36d53d098ca51a76a59c74cccd5256df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e075e235688ac6ffb5bd1244c507c4e" id="r_a3e075e235688ac6ffb5bd1244c507c4e"><td class="memItemLeft" align="right" valign="top"><a id="a3e075e235688ac6ffb5bd1244c507c4e" name="a3e075e235688ac6ffb5bd1244c507c4e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_PROBE_PACKET_COUNT</b>&#160;&#160;&#160;(1000)</td></tr>
<tr class="memdesc:a3e075e235688ac6ffb5bd1244c507c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the number of EFA interface probe packets that must be successfully transmitted before advancing to the connected mode. <br /></td></tr>
<tr class="separator:a3e075e235688ac6ffb5bd1244c507c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2722b171677aeeb93191d92d9f4b088a" id="r_a2722b171677aeeb93191d92d9f4b088a"><td class="memItemLeft" align="right" valign="top"><a id="a2722b171677aeeb93191d92d9f4b088a" name="a2722b171677aeeb93191d92d9f4b088a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_TX_PROBE_ACK_TIMEOUT</b>&#160;&#160;&#160;(100)</td></tr>
<tr class="memdesc:a2722b171677aeeb93191d92d9f4b088a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how long the transmitter should wait for all the probe packet ACKs to be received after the transmitter has received the kProbeCommandConnected command from the receiver. <br /></td></tr>
<tr class="separator:a2722b171677aeeb93191d92d9f4b088a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75907ab34a0a652fa9fc1532f2c9d021" id="r_a75907ab34a0a652fa9fc1532f2c9d021"><td class="memItemLeft" align="right" valign="top"><a id="a75907ab34a0a652fa9fc1532f2c9d021" name="a75907ab34a0a652fa9fc1532f2c9d021"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_TX_PROBE_ACK_MAX_RETRIES</b>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:a75907ab34a0a652fa9fc1532f2c9d021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how many times to retry EFA_TX_PROBE_ACK_TIMEOUT before going into connection reset mode. <br /></td></tr>
<tr class="separator:a75907ab34a0a652fa9fc1532f2c9d021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411e8af023c057740a06b83a660d2729" id="r_a411e8af023c057740a06b83a660d2729"><td class="memItemLeft" align="right" valign="top"><a id="a411e8af023c057740a06b83a660d2729" name="a411e8af023c057740a06b83a660d2729"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_PROBE_MONITOR_TIMEOUT_MSEC</b>&#160;&#160;&#160;(3000)</td></tr>
<tr class="memdesc:a411e8af023c057740a06b83a660d2729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how long to wait for the EFA interface probe to complete before changing to connection reset mode. The value is in milliseconds. <br /></td></tr>
<tr class="separator:a411e8af023c057740a06b83a660d2729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d60870012e0460a45e050002ce21b38" id="r_a5d60870012e0460a45e050002ce21b38"><td class="memItemLeft" align="right" valign="top"><a id="a5d60870012e0460a45e050002ce21b38" name="a5d60870012e0460a45e050002ce21b38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EFA_PROBE_PACKET_DATA_PATTERN</b>&#160;&#160;&#160;(0x41)</td></tr>
<tr class="memdesc:a5d60870012e0460a45e050002ce21b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The byte pattern used for the data portion of EFA probe packets. <br /></td></tr>
<tr class="separator:a5d60870012e0460a45e050002ce21b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d530e02cc0d6b6af0e3687806ad39d" id="r_ad7d530e02cc0d6b6af0e3687806ad39d"><td class="memItemLeft" align="right" valign="top"><a id="ad7d530e02cc0d6b6af0e3687806ad39d" name="ad7d530e02cc0d6b6af0e3687806ad39d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_TIMEOUT_MSEC</b>&#160;&#160;&#160;(1000)</td></tr>
<tr class="memdesc:ad7d530e02cc0d6b6af0e3687806ad39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default timeout value used by <a class="el" href="adapter__efa__probe__control_8c.html#a5f5f626def575681b9588a5951df962e">ProbeControlThread()</a>. The value is in milliseconds. <br /></td></tr>
<tr class="separator:ad7d530e02cc0d6b6af0e3687806ad39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce0b6ffe35a8b01328aca71bb126aeb" id="r_a3ce0b6ffe35a8b01328aca71bb126aeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ce0b6ffe35a8b01328aca71bb126aeb">RX_LINEAR_BUFFER_COUNT</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="separator:a3ce0b6ffe35a8b01328aca71bb126aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689e5ca0a1c1693bce2bf8e56462f61" id="r_aa689e5ca0a1c1693bce2bf8e56462f61"><td class="memItemLeft" align="right" valign="top"><a id="aa689e5ca0a1c1693bce2bf8e56462f61" name="aa689e5ca0a1c1693bce2bf8e56462f61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSTEM_MONITORING_SLEEP_TIME_MS</b>&#160;&#160;&#160;(400)</td></tr>
<tr class="memdesc:aa689e5ca0a1c1693bce2bf8e56462f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of milliseconds that system monitoring thread sleeps for before checking anything. <br /></td></tr>
<tr class="separator:aa689e5ca0a1c1693bce2bf8e56462f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45699e0ddfbcf00abc3c722daf8564d3" id="r_a45699e0ddfbcf00abc3c722daf8564d3"><td class="memItemLeft" align="right" valign="top"><a id="a45699e0ddfbcf00abc3c722daf8564d3" name="a45699e0ddfbcf00abc3c722daf8564d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSTEM_MONITORING_SLEEP_TIME_TOLERANCE_MS</b>&#160;&#160;&#160;(<a class="el" href="#aa689e5ca0a1c1693bce2bf8e56462f61">SYSTEM_MONITORING_SLEEP_TIME_MS</a> + 200)</td></tr>
<tr class="memdesc:a45699e0ddfbcf00abc3c722daf8564d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of milliseconds that system monitoring thread should have slept for before waking up. <br /></td></tr>
<tr class="separator:a45699e0ddfbcf00abc3c722daf8564d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845f0933a343de11c85d8f1acc0070fd" id="r_a845f0933a343de11c85d8f1acc0070fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a845f0933a343de11c85d8f1acc0070fd">CLOUDWATCH_METRICS_ENABLED</a></td></tr>
<tr class="separator:a845f0933a343de11c85d8f1acc0070fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcdf4ce95420ce985c8786c938fda74" id="r_a0dcdf4ce95420ce985c8786c938fda74"><td class="memItemLeft" align="right" valign="top"><a id="a0dcdf4ce95420ce985c8786c938fda74" name="a0dcdf4ce95420ce985c8786c938fda74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CLOUDWATCH_DEFAULT_NAMESPACE_STRING</b>&#160;&#160;&#160;(&quot;CloudDigitalInterface&quot;)</td></tr>
<tr class="memdesc:a0dcdf4ce95420ce985c8786c938fda74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default CloudWatch namespace to use. <br /></td></tr>
<tr class="separator:a0dcdf4ce95420ce985c8786c938fda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0c0ce9a5d4ab9d1a23d6f7ec5c42b" id="r_a91d0c0ce9a5d4ab9d1a23d6f7ec5c42b"><td class="memItemLeft" align="right" valign="top"><a id="a91d0c0ce9a5d4ab9d1a23d6f7ec5c42b" name="a91d0c0ce9a5d4ab9d1a23d6f7ec5c42b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_CLOUDWATCH_STRING_LENGTH</b>&#160;&#160;&#160;(256)</td></tr>
<tr class="memdesc:a91d0c0ce9a5d4ab9d1a23d6f7ec5c42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum string length used to represent strings specific to CloudWatch (ie. namespace, region and dimension domain name). <br /></td></tr>
<tr class="separator:a91d0c0ce9a5d4ab9d1a23d6f7ec5c42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebee1a7cfa0d84ce636354e4e29d31a3" id="r_aebee1a7cfa0d84ce636354e4e29d31a3"><td class="memItemLeft" align="right" valign="top"><a id="aebee1a7cfa0d84ce636354e4e29d31a3" name="aebee1a7cfa0d84ce636354e4e29d31a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CLOUDWATCH_STATS_FIFO_DEPTH</b>&#160;&#160;&#160;(1000)</td></tr>
<tr class="memdesc:aebee1a7cfa0d84ce636354e4e29d31a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum depth of the CloudWatch statistics FIFO. <br /></td></tr>
<tr class="separator:aebee1a7cfa0d84ce636354e4e29d31a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33aeb008277eee6dd12069717606573" id="r_af33aeb008277eee6dd12069717606573"><td class="memItemLeft" align="right" valign="top"><a id="af33aeb008277eee6dd12069717606573" name="af33aeb008277eee6dd12069717606573"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>METRICS_GATHERING_SERVICE_ENABLED</b></td></tr>
<tr class="memdesc:af33aeb008277eee6dd12069717606573"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro enables sending metrics to the AWS CDI metrics gathering service. <br /></td></tr>
<tr class="separator:af33aeb008277eee6dd12069717606573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header file contains definitions used to define the build configuration of the CDI SDK's implementation. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a845f0933a343de11c85d8f1acc0070fd" name="a845f0933a343de11c85d8f1acc0070fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845f0933a343de11c85d8f1acc0070fd">&#9670;&#160;</a></span>CLOUDWATCH_METRICS_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLOUDWATCH_METRICS_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When defined, publishing metrics to CloudWatch can be enabled through the API. This macro must also be defined to use the metrics gathering service. </p>

</div>
</div>
<a id="a5b9c26209597d30296a0696d57c19720" name="a5b9c26209597d30296a0696d57c19720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9c26209597d30296a0696d57c19720">&#9670;&#160;</a></span>HD_TO_4K_FACTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HD_TO_4K_FACTOR&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable to debug packet sequences. NOTE: This generates a lot of debug output. </p>
<p>Enable to debug poll thread sleep time. NOTE: This generates a lot of debug output.</p>
<p>Enable to debug Tx packet SGL entry pool free item count.</p>
<p>This is an example of how to use the queue debug function. It enables queue debugging of the tx_packet_queue_handle in <a class="el" href="adapter_8c.html" title="This file contains the definitions of common functions that comprise the CDI adapter API.">adapter.c</a>. NOTE: This feature is currently only available in a DEBUG build.</p>
<p>Enable additional debug logging of the control_work_request_pool_handle pool used in <a class="el" href="adapter__efa__probe_8c.html" title="This file contains internal definitions and implementation used within the SDK to support functionali...">adapter_efa_probe.c</a>. NOTE: This feature is currently only available in a DEBUG build.</p>
<p>Options to enable debug output for logic defined in rx_reorder.c.</p>
<p>Option to enable compiling and debug output for logic defined in <a class="el" href="t__digest_8c.html" title="An implementation of the t-digest percentile estimation algorithm developed by Ted Dunning and Otmar ...">t_digest.c</a>.</p>
<p>Dump Tx SGL and related SGL entries for each packet.</p>
<p>Dump Rx raw SGL entries as part of <a class="el" href="internal__rx_8c.html#a1890b390a1ca394d5dd6eb6c918e4b18">RxPollFreeBuffer()</a>.</p>
<p>Log Rx payload SGL entry free counts used in <a class="el" href="internal__rx_8c.html#a1890b390a1ca394d5dd6eb6c918e4b18">RxPollFreeBuffer()</a>.</p>
<p>After a connection has been established, disable all connection probe monitoring. This allows breakpoints and other delays to occur without causing the probe to reset the connection.</p>
<p>Enable the define below to set the libfabric log level. Default is no logging.</p>
<p>Multiplication factor used to increase buffer sizes from HD to 4K payloads. </p>

</div>
</div>
<a id="a3ce0b6ffe35a8b01328aca71bb126aeb" name="a3ce0b6ffe35a8b01328aca71bb126aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce0b6ffe35a8b01328aca71bb126aeb">&#9670;&#160;</a></span>RX_LINEAR_BUFFER_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RX_LINEAR_BUFFER_COUNT&#160;&#160;&#160;(5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of linear receive buffers allocated per connection opened with rx_buffer_type set to kCdiLinearBuffer. The application program cannot hold on to more than this number of buffers before returning them through the <a class="el" href="cdi__core__api_8h.html#a164e1970b75f0347bbc9499dc88ae436">CdiCoreRxFreeBuffer()</a> function. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
