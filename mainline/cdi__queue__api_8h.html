<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: include/cdi_queue_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cdi_queue_api.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The declarations in this header file correspond to the definitions in <a class="el" href="queue_8c.html" title="This file contains definitions and implementation for a queue that allows a reader thread to use CdiQ...">queue.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cdi__os__api_8h_source.html">cdi_os_api.h</a>&quot;</code><br />
</div>
<p><a href="cdi__queue__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiQueueCbData.html">CdiQueueCbData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure of this type is passed as the parameter to <a class="el" href="#aac12fd671f6c88875299014a0acbcf0a">CdiQueueCallback()</a>. It contains the state of a single queue read or write operation.  <a href="structCdiQueueCbData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afb8b8122c9d9a615a777c91170f58dde" id="r_afb8b8122c9d9a615a777c91170f58dde"><td class="memItemLeft" align="right" valign="top"><a id="afb8b8122c9d9a615a777c91170f58dde" name="afb8b8122c9d9a615a777c91170f58dde"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_FIXED_QUEUE_SIZE</b>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:afb8b8122c9d9a615a777c91170f58dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue cannot dynamically grow. <br /></td></tr>
<tr class="separator:afb8b8122c9d9a615a777c91170f58dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af8f6efa6070786580a9c41ee4fc85c2b" id="r_af8f6efa6070786580a9c41ee4fc85c2b"><td class="memItemLeft" align="right" valign="top"><a id="af8f6efa6070786580a9c41ee4fc85c2b" name="af8f6efa6070786580a9c41ee4fc85c2b"></a>
typedef struct CdiQueueState *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiQueueHandle</b></td></tr>
<tr class="memdesc:af8f6efa6070786580a9c41ee4fc85c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used as the handle (pointer to an opaque structure) for a queue. Each handle represents a instance of a queue. <br /></td></tr>
<tr class="separator:af8f6efa6070786580a9c41ee4fc85c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eab0b0d54c5baaaa0f95fc247e7a10d" id="r_a0eab0b0d54c5baaaa0f95fc247e7a10d"><td class="memItemLeft" align="right" valign="top"><a id="a0eab0b0d54c5baaaa0f95fc247e7a10d" name="a0eab0b0d54c5baaaa0f95fc247e7a10d"></a>
typedef struct CdiSinglyLinkedListEntry&#160;</td><td class="memItemRight" valign="bottom"><b>CdiSinglyLinkedListEntry</b></td></tr>
<tr class="memdesc:a0eab0b0d54c5baaaa0f95fc247e7a10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of <a class="el" href="structCdiSinglyLinkedListEntry.html" title="This structure represents a single list entry.">CdiSinglyLinkedListEntry</a> defined in <a class="el" href="singly__linked__list__api_8h.html" title="This file defines all the methods required for a singly linked list. A tail pointer is provided in or...">singly_linked_list_api.h</a>. <br /></td></tr>
<tr class="separator:a0eab0b0d54c5baaaa0f95fc247e7a10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac12fd671f6c88875299014a0acbcf0a" id="r_aac12fd671f6c88875299014a0acbcf0a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac12fd671f6c88875299014a0acbcf0a">CdiQueueCallback</a>) (const <a class="el" href="structCdiQueueCbData.html">CdiQueueCbData</a> *data_ptr)</td></tr>
<tr class="separator:aac12fd671f6c88875299014a0acbcf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1c8aae01d621bd312e04c46d5d4a252b" id="r_a1c8aae01d621bd312e04c46d5d4a252b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252b">CdiQueueSignalMode</a> { <br />
&#160;&#160;<a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252baae0fff1a50c8ae4d2f09bc806b2bbf15">kQueueSignalNone</a>
, <a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252bac1571f242533f7bd6f7d893b363d0a3a">kQueueSignalPopWait</a>
, <a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252ba01dfbb05ce26225ecdddae7e910e1635">kQueueSignalPushWait</a>
, <a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252badf225b0c136bae0f7169bbd8ef1446a8">kQueueSignalPopPushWait</a>
, <br />
&#160;&#160;<a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252baeeda4e2dca643ac404d5ee9bc5e14c04">kQueueSignalModeMask</a> = 0x7
, <a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252ba426c52e4a5d9cd0969fe91074d62f417">kQueueMultipleWritersFlag</a> = 0x08
<br />
 }</td></tr>
<tr class="memdesc:a1c8aae01d621bd312e04c46d5d4a252b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enumeration is used in the internal queue structure to indicate the type of OS signals, if any, to use in the queue.  <a href="#a1c8aae01d621bd312e04c46d5d4a252b">More...</a><br /></td></tr>
<tr class="separator:a1c8aae01d621bd312e04c46d5d4a252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a56ab25f5d845b76515043846cfb25439" id="r_a56ab25f5d845b76515043846cfb25439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56ab25f5d845b76515043846cfb25439">CdiQueueCreate</a> (const char *name_str, uint32_t item_count, uint32_t grow_count, uint32_t max_grow_count, uint32_t item_byte_size, <a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252b">CdiQueueSignalMode</a> signal_mode, <a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> *ret_handle_ptr)</td></tr>
<tr class="memdesc:a56ab25f5d845b76515043846cfb25439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a queue. Memory is allocated by this function.  <br /></td></tr>
<tr class="separator:a56ab25f5d845b76515043846cfb25439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b85d94d83745d50b6ccf6f254be15da" id="r_a2b85d94d83745d50b6ccf6f254be15da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b85d94d83745d50b6ccf6f254be15da">CdiQueuePop</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, void *item_dest_ptr)</td></tr>
<tr class="separator:a2b85d94d83745d50b6ccf6f254be15da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff1c51f0b23fe1813a41bc70012b352" id="r_a1ff1c51f0b23fe1813a41bc70012b352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff1c51f0b23fe1813a41bc70012b352">CdiQueuePopWait</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> abort_wait_signal, void *item_dest_ptr)</td></tr>
<tr class="separator:a1ff1c51f0b23fe1813a41bc70012b352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd2a5ae661ccaf82fbb49e2da3be45" id="r_abbdd2a5ae661ccaf82fbb49e2da3be45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbdd2a5ae661ccaf82fbb49e2da3be45">CdiQueuePopWaitMultiple</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *abort_wait_signal_array, int num_signals, uint32_t *ret_signal_index_ptr, void *item_dest_ptr)</td></tr>
<tr class="separator:abbdd2a5ae661ccaf82fbb49e2da3be45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056fe5c8b539246f781c99b7016618e" id="r_a1056fe5c8b539246f781c99b7016618e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1056fe5c8b539246f781c99b7016618e">CdiQueuePush</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, const void *item_ptr)</td></tr>
<tr class="separator:a1056fe5c8b539246f781c99b7016618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a0f9915733f135f6586044e4cf2ed9" id="r_af5a0f9915733f135f6586044e4cf2ed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a0f9915733f135f6586044e4cf2ed9">CdiQueuePushWait</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> abort_wait_signal, const void *item_ptr)</td></tr>
<tr class="separator:af5a0f9915733f135f6586044e4cf2ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea866b4d65d0d5ee5cfad09ea7072a35" id="r_aea866b4d65d0d5ee5cfad09ea7072a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea866b4d65d0d5ee5cfad09ea7072a35">CdiQueuePushWaitMultiple</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle, int timeout_ms, <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *abort_wait_signal_array, int num_signals, uint32_t *ret_signal_index_ptr, const void *item_ptr)</td></tr>
<tr class="separator:aea866b4d65d0d5ee5cfad09ea7072a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb90d86f66ea25e7ab5d0151df38fab" id="r_abcb90d86f66ea25e7ab5d0151df38fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcb90d86f66ea25e7ab5d0151df38fab">CdiQueueIsEmpty</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:abcb90d86f66ea25e7ab5d0151df38fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1d4cc3b2f0286e09c7c971c77148a8" id="r_a1b1d4cc3b2f0286e09c7c971c77148a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b1d4cc3b2f0286e09c7c971c77148a8">CdiQueueFlush</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a1b1d4cc3b2f0286e09c7c971c77148a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5e6f4d03c1cd612816b252c67184a" id="r_a06f5e6f4d03c1cd612816b252c67184a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06f5e6f4d03c1cd612816b252c67184a">CdiQueueGetPopWaitSignal</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a06f5e6f4d03c1cd612816b252c67184a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fe504a4f178a36e6aae46625bc07b1" id="r_a37fe504a4f178a36e6aae46625bc07b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37fe504a4f178a36e6aae46625bc07b1">CdiQueueGetPushWaitSignal</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a37fe504a4f178a36e6aae46625bc07b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710a744719faa7b47b35338053835e73" id="r_a710a744719faa7b47b35338053835e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710a744719faa7b47b35338053835e73">CdiQueueGetName</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a710a744719faa7b47b35338053835e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c4a8f55850cb448fa306a5a02c1bf" id="r_a183c4a8f55850cb448fa306a5a02c1bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a183c4a8f55850cb448fa306a5a02c1bf">CdiQueueDestroy</a> (<a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> handle)</td></tr>
<tr class="separator:a183c4a8f55850cb448fa306a5a02c1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The declarations in this header file correspond to the definitions in <a class="el" href="queue_8c.html" title="This file contains definitions and implementation for a queue that allows a reader thread to use CdiQ...">queue.c</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aac12fd671f6c88875299014a0acbcf0a" name="aac12fd671f6c88875299014a0acbcf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac12fd671f6c88875299014a0acbcf0a">&#9670;&#160;</a></span>CdiQueueCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CdiQueueCallback) (const <a class="el" href="structCdiQueueCbData.html">CdiQueueCbData</a> *data_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype of the queue debug callback function.</p>
<p>This callback function is invoked whenever an item is written to or read from the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_ptr</td><td>A pointer to an <a class="el" href="structCdiQueueCbData.html" title="A structure of this type is passed as the parameter to CdiQueueCallback(). It contains the state of a...">CdiQueueCbData</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1c8aae01d621bd312e04c46d5d4a252b" name="a1c8aae01d621bd312e04c46d5d4a252b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8aae01d621bd312e04c46d5d4a252b">&#9670;&#160;</a></span>CdiQueueSignalMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252b">CdiQueueSignalMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enumeration is used in the internal queue structure to indicate the type of OS signals, if any, to use in the queue. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c8aae01d621bd312e04c46d5d4a252baae0fff1a50c8ae4d2f09bc806b2bbf15" name="a1c8aae01d621bd312e04c46d5d4a252baae0fff1a50c8ae4d2f09bc806b2bbf15"></a>kQueueSignalNone&#160;</td><td class="fielddoc"><p>In this mode signals are not used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c8aae01d621bd312e04c46d5d4a252bac1571f242533f7bd6f7d893b363d0a3a" name="a1c8aae01d621bd312e04c46d5d4a252bac1571f242533f7bd6f7d893b363d0a3a"></a>kQueueSignalPopWait&#160;</td><td class="fielddoc"><p>In this mode, use <a class="el" href="#a1ff1c51f0b23fe1813a41bc70012b352">CdiQueuePopWait()</a> to block and wait on an empty queue. Use <a class="el" href="#a06f5e6f4d03c1cd612816b252c67184a">CdiQueueGetPopWaitSignal()</a> to directly get the signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c8aae01d621bd312e04c46d5d4a252ba01dfbb05ce26225ecdddae7e910e1635" name="a1c8aae01d621bd312e04c46d5d4a252ba01dfbb05ce26225ecdddae7e910e1635"></a>kQueueSignalPushWait&#160;</td><td class="fielddoc"><p>In this mode, use <a class="el" href="#af5a0f9915733f135f6586044e4cf2ed9">CdiQueuePushWait()</a> to block and wait on a full queue. Use <a class="el" href="#a37fe504a4f178a36e6aae46625bc07b1">CdiQueueGetPushWaitSignal()</a> to directly get the signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c8aae01d621bd312e04c46d5d4a252badf225b0c136bae0f7169bbd8ef1446a8" name="a1c8aae01d621bd312e04c46d5d4a252badf225b0c136bae0f7169bbd8ef1446a8"></a>kQueueSignalPopPushWait&#160;</td><td class="fielddoc"><p>In this mode, signals are enabled for both push and pop operations (see above). </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c8aae01d621bd312e04c46d5d4a252baeeda4e2dca643ac404d5ee9bc5e14c04" name="a1c8aae01d621bd312e04c46d5d4a252baeeda4e2dca643ac404d5ee9bc5e14c04"></a>kQueueSignalModeMask&#160;</td><td class="fielddoc"><p>Mask that only includes the main mode options. Used for ignoring option flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c8aae01d621bd312e04c46d5d4a252ba426c52e4a5d9cd0969fe91074d62f417" name="a1c8aae01d621bd312e04c46d5d4a252ba426c52e4a5d9cd0969fe91074d62f417"></a>kQueueMultipleWritersFlag&#160;</td><td class="fielddoc"><p>Optional flag to add locking for thread safe pushing into the queue. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a56ab25f5d845b76515043846cfb25439" name="a56ab25f5d845b76515043846cfb25439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ab25f5d845b76515043846cfb25439">&#9670;&#160;</a></span>CdiQueueCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueueCreate </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>item_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>grow_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_grow_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>item_byte_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1c8aae01d621bd312e04c46d5d4a252b">CdiQueueSignalMode</a></td>          <td class="paramname"><span class="paramname"><em>signal_mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a queue. Memory is allocated by this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_str</td><td>Name of queue. </td></tr>
    <tr><td class="paramname">item_count</td><td>Number of items in the queue. </td></tr>
    <tr><td class="paramname">grow_count</td><td>Number of items that a queue may be increased by if the initial size requested is inadequate. </td></tr>
    <tr><td class="paramname">max_grow_count</td><td>Maximum number of times a queue may be increased before an error occurs. </td></tr>
    <tr><td class="paramname">item_byte_size</td><td>Size of each item in bytes. </td></tr>
    <tr><td class="paramname">signal_mode</td><td>Sets type of signals and optional locking, if any, to use. </td></tr>
    <tr><td class="paramname">ret_handle_ptr</td><td>Pointer to returned handle of the new queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a183c4a8f55850cb448fa306a5a02c1bf" name="a183c4a8f55850cb448fa306a5a02c1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183c4a8f55850cb448fa306a5a02c1bf">&#9670;&#160;</a></span>CdiQueueDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiQueueDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1d4cc3b2f0286e09c7c971c77148a8" name="a1b1d4cc3b2f0286e09c7c971c77148a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1d4cc3b2f0286e09c7c971c77148a8">&#9670;&#160;</a></span>CdiQueueFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiQueueFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drain all items in the queue. NOTE: The caller must ensure that other threads cannot use either of the <a class="el" href="#a2b85d94d83745d50b6ccf6f254be15da">CdiQueuePop()</a> or <a class="el" href="#a1056fe5c8b539246f781c99b7016618e">CdiQueuePush()</a> API functions while using this API function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710a744719faa7b47b35338053835e73" name="a710a744719faa7b47b35338053835e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710a744719faa7b47b35338053835e73">&#9670;&#160;</a></span>CdiQueueGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> const char * CdiQueueGetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get name of the queue that was defined when it was created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06f5e6f4d03c1cd612816b252c67184a" name="a06f5e6f4d03c1cd612816b252c67184a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f5e6f4d03c1cd612816b252c67184a">&#9670;&#160;</a></span>CdiQueueGetPopWaitSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> CdiQueueGetPopWaitSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If kQueueSignalPopWait or kQueueSignalBoth was specified when the queue was created, this function returns the signal that got set whenever an item is pushed on the queue. It is used to wait in <a class="el" href="#a1ff1c51f0b23fe1813a41bc70012b352">CdiQueuePopWait()</a>. Otherwise, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37fe504a4f178a36e6aae46625bc07b1" name="a37fe504a4f178a36e6aae46625bc07b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fe504a4f178a36e6aae46625bc07b1">&#9670;&#160;</a></span>CdiQueueGetPushWaitSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> <a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> CdiQueueGetPushWaitSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If kQueueSignalPushWait or kQueueSignalBoth was specified when the queue was created, this function returns the signal that got set whenever an item is popped off the queue. It is used to wait in <a class="el" href="#af5a0f9915733f135f6586044e4cf2ed9">CdiQueuePushWait()</a>. Otherwise, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcb90d86f66ea25e7ab5d0151df38fab" name="abcb90d86f66ea25e7ab5d0151df38fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb90d86f66ea25e7ab5d0151df38fab">&#9670;&#160;</a></span>CdiQueueIsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueueIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the queue is empty, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a2b85d94d83745d50b6ccf6f254be15da" name="a2b85d94d83745d50b6ccf6f254be15da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b85d94d83745d50b6ccf6f254be15da">&#9670;&#160;</a></span>CdiQueuePop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueuePop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item_dest_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop an item from the queue buffer and copy to item_dest_ptr. If the queue is empty, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">item_dest_ptr</td><td>Pointer to buffer where to copy the item to. Size of buffer must be large enough to hold the data. Data size was set when the queue was created (see item_byte_size). This is an optional parameter, you can pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is empty). </dd></dl>

</div>
</div>
<a id="a1ff1c51f0b23fe1813a41bc70012b352" name="a1ff1c51f0b23fe1813a41bc70012b352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff1c51f0b23fe1813a41bc70012b352">&#9670;&#160;</a></span>CdiQueuePopWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueuePopWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item_dest_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop an item from the queue buffer and copy to the address item_dest_ptr. If the queue is empty, wait until the specified timeout expires or the optional signal gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely </td></tr>
    <tr><td class="paramname">abort_wait_signal</td><td>Signal used to abort waiting. </td></tr>
    <tr><td class="paramname">item_dest_ptr</td><td>Pointer to buffer where to copy the item to. Size of buffer must be large enough to hold the data. Data size was set when the queue was created (see item_byte_size). This is an optional parameter. Pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is empty and timeout expired or signal got set). </dd></dl>

</div>
</div>
<a id="abbdd2a5ae661ccaf82fbb49e2da3be45" name="abbdd2a5ae661ccaf82fbb49e2da3be45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdd2a5ae661ccaf82fbb49e2da3be45">&#9670;&#160;</a></span>CdiQueuePopWaitMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueuePopWaitMultiple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_signals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ret_signal_index_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item_dest_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pop an item from the queue buffer and copy to the address item_dest_ptr. If the queue is empty, wait until the specified timeout expires or one of the signals in the signal array gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">abort_wait_signal_array</td><td>Array of signals used to abort waiting. </td></tr>
    <tr><td class="paramname">num_signals</td><td>Number of signals in the array. </td></tr>
    <tr><td class="paramname">ret_signal_index_ptr</td><td>Pointer to the returned signal index that caused the wait to abort. If a timeout occurred, CDI_OS_SIG_TIMEOUT is returned. This is an optional parameter. Pass NULL if you don't care. </td></tr>
    <tr><td class="paramname">item_dest_ptr</td><td>Pointer to buffer where to copy the item to. Size of buffer must be large enough to hold the data. Data size was set when the queue was created (see item_byte_size). This is an optional parameter. Pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is empty and timeout expired or signal got set). </dd></dl>

</div>
</div>
<a id="a1056fe5c8b539246f781c99b7016618e" name="a1056fe5c8b539246f781c99b7016618e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056fe5c8b539246f781c99b7016618e">&#9670;&#160;</a></span>CdiQueuePush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueuePush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>item_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push an item on the queue. If the queue is full, false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>Pointer where to copy the item from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is full). </dd></dl>

</div>
</div>
<a id="af5a0f9915733f135f6586044e4cf2ed9" name="af5a0f9915733f135f6586044e4cf2ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a0f9915733f135f6586044e4cf2ed9">&#9670;&#160;</a></span>CdiQueuePushWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueuePushWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>item_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push an item on the queue. If the queue is full, wait until the specified timeout expires or the optional signal gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">abort_wait_signal</td><td>Signal used to abort waiting. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>Address where to copy the item from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is full and timeout expired or signal got set). </dd></dl>

</div>
</div>
<a id="aea866b4d65d0d5ee5cfad09ea7072a35" name="aea866b4d65d0d5ee5cfad09ea7072a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea866b4d65d0d5ee5cfad09ea7072a35">&#9670;&#160;</a></span>CdiQueuePushWaitMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiQueuePushWaitMultiple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8f6efa6070786580a9c41ee4fc85c2b">CdiQueueHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__os__api_8h.html#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>abort_wait_signal_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_signals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ret_signal_index_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>item_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push an item on the queue. If the queue is full, wait until the specified timeout expires or one of the signals in the signal array gets set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Queue handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">abort_wait_signal_array</td><td>Array of signals used to abort waiting. </td></tr>
    <tr><td class="paramname">num_signals</td><td>Number of signals in the array. </td></tr>
    <tr><td class="paramname">ret_signal_index_ptr</td><td>Pointer to the returned signal index that caused the wait to abort. If a timeout occurred, CDI_OS_SIG_TIMEOUT is returned. This is an optional parameter. Pass NULL if you don't care. </td></tr>
    <tr><td class="paramname">item_ptr</td><td>Address where to copy the item from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false (queue is full and timeout expired or signal got set). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
