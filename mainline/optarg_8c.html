<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: src/test/optarg.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_120ed4da3e3217b1e7fc0b4f48568e79.html">test</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">optarg.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the definitions of the functions used for option parsing, originally designed for the cdi_test program.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="optarg_8h_source.html">optarg.h</a>&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cdi__logger__api_8h_source.html">cdi_logger_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cdi__test_8h_source.html">cdi_test.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="test__console_8h_source.html">test_console.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="test__common_8h_source.html">test_common.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae927e970cbdd7f1fa723b8c648fe633a" id="r_ae927e970cbdd7f1fa723b8c648fe633a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae927e970cbdd7f1fa723b8c648fe633a">OptionTypes</a> { <a class="el" href="#ae927e970cbdd7f1fa723b8c648fe633aad6701d8d59ab01c308c6b5bc8edd06ee">kArgError</a>
, <a class="el" href="#ae927e970cbdd7f1fa723b8c648fe633aad60e6a3574a919a5cc7b271c7cfaeddf">kArgOnly</a>
, <a class="el" href="#ae927e970cbdd7f1fa723b8c648fe633aa113b08b553e8653a107c5b33e263a2c1">kOptShort</a>
, <a class="el" href="#ae927e970cbdd7f1fa723b8c648fe633aa9b448a78f680bfda2d885640131e91c4">kOptLong</a>
 }</td></tr>
<tr class="memdesc:ae927e970cbdd7f1fa723b8c648fe633a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for labeling different command line arguments as the command line is parsed.  <a href="#ae927e970cbdd7f1fa723b8c648fe633a">More...</a><br /></td></tr>
<tr class="separator:ae927e970cbdd7f1fa723b8c648fe633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65ed64e1918da0cfe92a7cd87682adb1" id="r_a65ed64e1918da0cfe92a7cd87682adb1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65ed64e1918da0cfe92a7cd87682adb1">SearchOptions</a> (const char *opt_str, int type, const <a class="el" href="structOptDef.html">OptDef</a> *opt_array_ptr, <a class="el" href="structOptArg.html">OptArg</a> *found_opt_ptr)</td></tr>
<tr class="memdesc:a65ed64e1918da0cfe92a7cd87682adb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the user options array for a given option. The type (long/short) indicates which option array to search (the long options or the short ones), and the len indicates how many characters to match.  <br /></td></tr>
<tr class="separator:a65ed64e1918da0cfe92a7cd87682adb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bd43bb3c66b1fbf8faedd6387ab67d" id="r_ae9bd43bb3c66b1fbf8faedd6387ab67d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9bd43bb3c66b1fbf8faedd6387ab67d">CheckArg</a> (const char *arg_str, const <a class="el" href="structOptDef.html">OptDef</a> *opt_array_ptr, <a class="el" href="structOptArg.html">OptArg</a> *found_opt_ptr, bool expecting_opt)</td></tr>
<tr class="memdesc:ae9bd43bb3c66b1fbf8faedd6387ab67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a command line argument and checks if it conforms to expected formatting and if it is a valid option or argument. If it is formatted as an option, check the user-defined options array. If it is a valid user option, then fill out the found_opt_ptr structure with name and number of arguments.  <br /></td></tr>
<tr class="separator:ae9bd43bb3c66b1fbf8faedd6387ab67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b6735ef1d52c8f4e4201b96902aa8" id="r_adf6b6735ef1d52c8f4e4201b96902aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf6b6735ef1d52c8f4e4201b96902aa8">RigWhitespaces</a> (const char *long_name_str, const char *argument_str, int *max_long_name_length_ptr, int *max_argument_length_ptr)</td></tr>
<tr class="separator:adf6b6735ef1d52c8f4e4201b96902aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb03b184dcde4a7c60f64e23063dfd14" id="r_adb03b184dcde4a7c60f64e23063dfd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb03b184dcde4a7c60f64e23063dfd14">PrintKeyArrayNames</a> (const <a class="el" href="structCdiEnumStringKey.html">CdiEnumStringKey</a> *key_array, const int indent)</td></tr>
<tr class="separator:adb03b184dcde4a7c60f64e23063dfd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e72408b9678cc815a63495bf8a3fa4" id="r_a51e72408b9678cc815a63495bf8a3fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e72408b9678cc815a63495bf8a3fa4">PrintOption</a> (const <a class="el" href="structOptDef.html">OptDef</a> *option_ptr)</td></tr>
<tr class="separator:a51e72408b9678cc815a63495bf8a3fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2d31ebe2102b880a795ecc0fc006ea" id="r_a8d2d31ebe2102b880a795ecc0fc006ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d2d31ebe2102b880a795ecc0fc006ea">PrintUsage</a> (const <a class="el" href="structOptDef.html">OptDef</a> *opt_array_ptr, bool has_error)</td></tr>
<tr class="separator:a8d2d31ebe2102b880a795ecc0fc006ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8068fd374430436bb7c2a70e481abc" id="r_a5f8068fd374430436bb7c2a70e481abc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8068fd374430436bb7c2a70e481abc">GetOpt</a> (int argc, const char *argv[], int *index_ptr, <a class="el" href="structOptDef.html">OptDef</a> *opt_array_ptr, <a class="el" href="structOptArg.html">OptArg</a> *this_opt_ptr)</td></tr>
<tr class="separator:a5f8068fd374430436bb7c2a70e481abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the definitions of the functions used for option parsing, originally designed for the cdi_test program. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae927e970cbdd7f1fa723b8c648fe633a" name="ae927e970cbdd7f1fa723b8c648fe633a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae927e970cbdd7f1fa723b8c648fe633a">&#9670;&#160;</a></span>OptionTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae927e970cbdd7f1fa723b8c648fe633a">OptionTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for labeling different command line arguments as the command line is parsed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae927e970cbdd7f1fa723b8c648fe633aad6701d8d59ab01c308c6b5bc8edd06ee" name="ae927e970cbdd7f1fa723b8c648fe633aad6701d8d59ab01c308c6b5bc8edd06ee"></a>kArgError&#160;</td><td class="fielddoc"><p>An argument error was detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae927e970cbdd7f1fa723b8c648fe633aad60e6a3574a919a5cc7b271c7cfaeddf" name="ae927e970cbdd7f1fa723b8c648fe633aad60e6a3574a919a5cc7b271c7cfaeddf"></a>kArgOnly&#160;</td><td class="fielddoc"><p>An orphaned argument has been found without a parent option. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae927e970cbdd7f1fa723b8c648fe633aa113b08b553e8653a107c5b33e263a2c1" name="ae927e970cbdd7f1fa723b8c648fe633aa113b08b553e8653a107c5b33e263a2c1"></a>kOptShort&#160;</td><td class="fielddoc"><p>A short option has been found on the command line. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae927e970cbdd7f1fa723b8c648fe633aa9b448a78f680bfda2d885640131e91c4" name="ae927e970cbdd7f1fa723b8c648fe633aa9b448a78f680bfda2d885640131e91c4"></a>kOptLong&#160;</td><td class="fielddoc"><p>A long option has been found on the command line. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae9bd43bb3c66b1fbf8faedd6387ab67d" name="ae9bd43bb3c66b1fbf8faedd6387ab67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bd43bb3c66b1fbf8faedd6387ab67d">&#9670;&#160;</a></span>CheckArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int CheckArg </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>arg_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOptDef.html">OptDef</a> *</td>          <td class="paramname"><span class="paramname"><em>opt_array_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOptArg.html">OptArg</a> *</td>          <td class="paramname"><span class="paramname"><em>found_opt_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>expecting_opt</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a command line argument and checks if it conforms to expected formatting and if it is a valid option or argument. If it is formatted as an option, check the user-defined options array. If it is a valid user option, then fill out the found_opt_ptr structure with name and number of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg_str</td><td>The command line argument we want to check. </td></tr>
    <tr><td class="paramname">opt_array_ptr</td><td>The user-defined options array we will search if we determine arg_str is a properly-formatted option. </td></tr>
    <tr><td class="paramname">found_opt_ptr</td><td>If a match is found, this is a structure describing the option. </td></tr>
    <tr><td class="paramname">expecting_opt</td><td>When true, we are expecting the arg_str input is a long or short option; when false, we are expecting it to be an argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 1 if we get an error; 0 if arg_str is valid. </dd></dl>

</div>
</div>
<a id="a5f8068fd374430436bb7c2a70e481abc" name="a5f8068fd374430436bb7c2a70e481abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8068fd374430436bb7c2a70e481abc">&#9670;&#160;</a></span>GetOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GetOpt </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argv_ptr</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOptDef.html">OptDef</a> *</td>          <td class="paramname"><span class="paramname"><em>opt_array_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOptArg.html">OptArg</a> *</td>          <td class="paramname"><span class="paramname"><em>this_opt_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A user-facing function that takes in the argv system command line args array and an index and finds the next option and its associated arguments, incrementing the index accordingly. Returns false for any error condition or if the end of the arguments array has been reached. The contents of index_ptr are incremented as options and arguments are processed and will be equal to argc on a normal exit after processing all options and arguments. However, if we hit the end of the argv array and are still expecting arguments to the last option, we will increment the contents of index_ptr beyond argc so that the calling routine can detect that it was not a normal exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>The system command line argument count variable. </td></tr>
    <tr><td class="paramname">argv_ptr</td><td>The pointer to the system command line arguments array. </td></tr>
    <tr><td class="paramname">index_ptr</td><td>The pointer to the current argv index, which gets incremented by the function as options and arguments are retrieved. Should match argc after all argv elements have been processed. </td></tr>
    <tr><td class="paramname">opt_array_ptr</td><td>Pointer to array of user-defined options. </td></tr>
    <tr><td class="paramname">this_opt_ptr</td><td>A structure describing the single option (and arguments) retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success; false for failure or if we are at the end of argv. </dd></dl>

</div>
</div>
<a id="adb03b184dcde4a7c60f64e23063dfd14" name="adb03b184dcde4a7c60f64e23063dfd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb03b184dcde4a7c60f64e23063dfd14">&#9670;&#160;</a></span>PrintKeyArrayNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintKeyArrayNames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCdiEnumStringKey.html">CdiEnumStringKey</a> *</td>          <td class="paramname"><span class="paramname"><em>key_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>indent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all the name_str elements of a key-value array in the format: &lt;key_array[0].name_str, key_array[1].name_str ... &gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_array</td><td>A key-value array to search for name_str. </td></tr>
    <tr><td class="paramname">indent</td><td>The number of space to indent before printing the array of names from the name_str member of each key-value pair. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51e72408b9678cc815a63495bf8a3fa4" name="a51e72408b9678cc815a63495bf8a3fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e72408b9678cc815a63495bf8a3fa4">&#9670;&#160;</a></span>PrintOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOptDef.html">OptDef</a> *</td>          <td class="paramname"><span class="paramname"><em>option_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the usage message of a single option based on the user-defined usage options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_ptr</td><td>Pointer to a single user-defined option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d2d31ebe2102b880a795ecc0fc006ea" name="a8d2d31ebe2102b880a795ecc0fc006ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2d31ebe2102b880a795ecc0fc006ea">&#9670;&#160;</a></span>PrintUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintUsage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOptDef.html">OptDef</a> *</td>          <td class="paramname"><span class="paramname"><em>opt_array_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_error</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the usage message based on the user-defined usage options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_array_ptr</td><td>Pointer to array of user-defined options. </td></tr>
    <tr><td class="paramname">has_error</td><td>True if we got an error and wish to print an error statement after printing usage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf6b6735ef1d52c8f4e4201b96902aa8" name="adf6b6735ef1d52c8f4e4201b96902aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6b6735ef1d52c8f4e4201b96902aa8">&#9670;&#160;</a></span>RigWhitespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RigWhitespaces </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>long_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argument_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>max_long_name_length_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>max_argument_length_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When the length of either the long option string or the argument string exceed their allotted length, but taken together they don't exceed the combined allotted lengh, then we adjust the whitespaces so that the printout meets the target length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">long_name_str</td><td>Long option string to be printed. May be NULL. </td></tr>
    <tr><td class="paramname">argument_str</td><td>Argument description to be printed. May be NULL. </td></tr>
    <tr><td class="paramname">max_long_name_length_ptr</td><td>Pointer to alloted length on input. Pointer to adjusted length on output. </td></tr>
    <tr><td class="paramname">max_argument_length_ptr</td><td>Pointer to alloted length on input. Pointer to adjuted length on output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65ed64e1918da0cfe92a7cd87682adb1" name="a65ed64e1918da0cfe92a7cd87682adb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ed64e1918da0cfe92a7cd87682adb1">&#9670;&#160;</a></span>SearchOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SearchOptions </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>opt_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOptDef.html">OptDef</a> *</td>          <td class="paramname"><span class="paramname"><em>opt_array_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOptArg.html">OptArg</a> *</td>          <td class="paramname"><span class="paramname"><em>found_opt_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search the user options array for a given option. The type (long/short) indicates which option array to search (the long options or the short ones), and the len indicates how many characters to match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_str</td><td>The option we are going to search for in the user options array. </td></tr>
    <tr><td class="paramname">type</td><td>The type of option we are searching for; long or short. </td></tr>
    <tr><td class="paramname">opt_array_ptr</td><td>The user-defined options array we will search. </td></tr>
    <tr><td class="paramname">found_opt_ptr</td><td>If a match is found, this is a structure describing the option short name and number of expected arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if a match is found, otherwise return false. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
