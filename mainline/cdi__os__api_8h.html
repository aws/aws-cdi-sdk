<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: include/cdi_os_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cdi_os_api.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the declarations for OS functions for creating/managing/freeing threads, semaphores, mutexes, critical sections, signals, memory and sockets. There are also abstractions for atomic operations as well as some time, sleep and string operations. These definitions in this module are here to account for differences between Linux and Windows.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;semaphore.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;strings.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cdi__utility__api_8h_source.html">cdi_utility_api.h</a>&quot;</code><br />
</div>
<p><a href="cdi__os__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCdiSignalHandlerInfo.html">CdiSignalHandlerInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold signal handler data.  <a href="structCdiSignalHandlerInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4cee9c8568a9f5393319ab87a81a447d" id="r_a4cee9c8568a9f5393319ab87a81a447d"><td class="memItemLeft" align="right" valign="top"><a id="a4cee9c8568a9f5393319ab87a81a447d" name="a4cee9c8568a9f5393319ab87a81a447d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STDIN</b>&#160;&#160;&#160;stdin</td></tr>
<tr class="memdesc:a4cee9c8568a9f5393319ab87a81a447d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of OS agnostic standard input stream. <br /></td></tr>
<tr class="separator:a4cee9c8568a9f5393319ab87a81a447d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9372b2d34927b6146c65fa1404e8b6a" id="r_ad9372b2d34927b6146c65fa1404e8b6a"><td class="memItemLeft" align="right" valign="top"><a id="ad9372b2d34927b6146c65fa1404e8b6a" name="ad9372b2d34927b6146c65fa1404e8b6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STDOUT</b>&#160;&#160;&#160;stdout</td></tr>
<tr class="memdesc:ad9372b2d34927b6146c65fa1404e8b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of OS agnostic standard output stream. <br /></td></tr>
<tr class="separator:ad9372b2d34927b6146c65fa1404e8b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5593f14860437de71b0648c91c013190" id="r_a5593f14860437de71b0648c91c013190"><td class="memItemLeft" align="right" valign="top"><a id="a5593f14860437de71b0648c91c013190" name="a5593f14860437de71b0648c91c013190"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STDERR</b>&#160;&#160;&#160;stderr</td></tr>
<tr class="memdesc:a5593f14860437de71b0648c91c013190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of OS agnostic standard error output stream. <br /></td></tr>
<tr class="separator:a5593f14860437de71b0648c91c013190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9f124fd1b788b8d48d69579788f5e9" id="r_a1e9f124fd1b788b8d48d69579788f5e9"><td class="memItemLeft" align="right" valign="top"><a id="a1e9f124fd1b788b8d48d69579788f5e9" name="a1e9f124fd1b788b8d48d69579788f5e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STDIN_FILENO</b>&#160;&#160;&#160;STDIN_FILENO</td></tr>
<tr class="memdesc:a1e9f124fd1b788b8d48d69579788f5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of OS agnostic standard input file number. <br /></td></tr>
<tr class="separator:a1e9f124fd1b788b8d48d69579788f5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e506a83e6b7ede0a081866da03334e4" id="r_a0e506a83e6b7ede0a081866da03334e4"><td class="memItemLeft" align="right" valign="top"><a id="a0e506a83e6b7ede0a081866da03334e4" name="a0e506a83e6b7ede0a081866da03334e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STDOUT_FILENO</b>&#160;&#160;&#160;STDOUT_FILENO</td></tr>
<tr class="memdesc:a0e506a83e6b7ede0a081866da03334e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of OS agnostic standard output file number. <br /></td></tr>
<tr class="separator:a0e506a83e6b7ede0a081866da03334e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86de1c1b35596c07270a7d2259060e7" id="r_ae86de1c1b35596c07270a7d2259060e7"><td class="memItemLeft" align="right" valign="top"><a id="ae86de1c1b35596c07270a7d2259060e7" name="ae86de1c1b35596c07270a7d2259060e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STDERR_FILENO</b>&#160;&#160;&#160;STDERR_FILENO</td></tr>
<tr class="memdesc:ae86de1c1b35596c07270a7d2259060e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of OS agnostic standard error file number. <br /></td></tr>
<tr class="separator:ae86de1c1b35596c07270a7d2259060e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab844c6be7fd8f0472045ee71feaebeb" id="r_aab844c6be7fd8f0472045ee71feaebeb"><td class="memItemLeft" align="right" valign="top"><a id="aab844c6be7fd8f0472045ee71feaebeb" name="aab844c6be7fd8f0472045ee71feaebeb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_THREAD_PARAM</b>&#160;&#160;&#160;void*</td></tr>
<tr class="memdesc:aab844c6be7fd8f0472045ee71feaebeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable thread function parameter type. <br /></td></tr>
<tr class="separator:aab844c6be7fd8f0472045ee71feaebeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54546942bb91b024de5fae2a253564d" id="r_af54546942bb91b024de5fae2a253564d"><td class="memItemLeft" align="right" valign="top"><a id="af54546942bb91b024de5fae2a253564d" name="af54546942bb91b024de5fae2a253564d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_THREAD</b>&#160;&#160;&#160;int</td></tr>
<tr class="memdesc:af54546942bb91b024de5fae2a253564d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable thread function return type. <br /></td></tr>
<tr class="separator:af54546942bb91b024de5fae2a253564d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd7167829c9749b781907dc23ab366e" id="r_accd7167829c9749b781907dc23ab366e"><td class="memItemLeft" align="right" valign="top"><a id="accd7167829c9749b781907dc23ab366e" name="accd7167829c9749b781907dc23ab366e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_INFINITE</b>&#160;&#160;&#160;0xFFFFFFFF</td></tr>
<tr class="memdesc:accd7167829c9749b781907dc23ab366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinity used as wait arguments, i.e "wait for infinity". <br /></td></tr>
<tr class="separator:accd7167829c9749b781907dc23ab366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cdf680b1a46e51e097cf18d43499f9" id="r_a27cdf680b1a46e51e097cf18d43499f9"><td class="memItemLeft" align="right" valign="top"><a id="a27cdf680b1a46e51e097cf18d43499f9" name="a27cdf680b1a46e51e097cf18d43499f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicInc16</b>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 1)</td></tr>
<tr class="memdesc:a27cdf680b1a46e51e097cf18d43499f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment a 16-bit value by 1 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:a27cdf680b1a46e51e097cf18d43499f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b5321988c054c35a8fc4139eb9090" id="r_acf4b5321988c054c35a8fc4139eb9090"><td class="memItemLeft" align="right" valign="top"><a id="acf4b5321988c054c35a8fc4139eb9090" name="acf4b5321988c054c35a8fc4139eb9090"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicDec16</b>(x)&#160;&#160;&#160;__sync_sub_and_fetch((x), 1)</td></tr>
<tr class="memdesc:acf4b5321988c054c35a8fc4139eb9090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement a 16-bit value by 1 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:acf4b5321988c054c35a8fc4139eb9090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ac4bd636d8d4ddb1a81bccb652c6ca" id="r_af8ac4bd636d8d4ddb1a81bccb652c6ca"><td class="memItemLeft" align="right" valign="top"><a id="af8ac4bd636d8d4ddb1a81bccb652c6ca" name="af8ac4bd636d8d4ddb1a81bccb652c6ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicRead16</b>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 0)</td></tr>
<tr class="memdesc:af8ac4bd636d8d4ddb1a81bccb652c6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic read a 16-bit value (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:af8ac4bd636d8d4ddb1a81bccb652c6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ce7765e73cb208246c6a207b988f76" id="r_a11ce7765e73cb208246c6a207b988f76"><td class="memItemLeft" align="right" valign="top"><a id="a11ce7765e73cb208246c6a207b988f76" name="a11ce7765e73cb208246c6a207b988f76"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicAdd16</b>(x,  b)&#160;&#160;&#160;__sync_add_and_fetch((x), (b))</td></tr>
<tr class="memdesc:a11ce7765e73cb208246c6a207b988f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add a 16-bit value by a 16-bit value sent (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:a11ce7765e73cb208246c6a207b988f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa211638a00b3262169c43fd79987fea4" id="r_aa211638a00b3262169c43fd79987fea4"><td class="memItemLeft" align="right" valign="top"><a id="aa211638a00b3262169c43fd79987fea4" name="aa211638a00b3262169c43fd79987fea4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicInc32</b>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 1)</td></tr>
<tr class="memdesc:aa211638a00b3262169c43fd79987fea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment a 32-bit value by 1 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:aa211638a00b3262169c43fd79987fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454cabefde0be10a2fdfb8daf8ecd5f2" id="r_a454cabefde0be10a2fdfb8daf8ecd5f2"><td class="memItemLeft" align="right" valign="top"><a id="a454cabefde0be10a2fdfb8daf8ecd5f2" name="a454cabefde0be10a2fdfb8daf8ecd5f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicDec32</b>(x)&#160;&#160;&#160;__sync_sub_and_fetch((x), 1)</td></tr>
<tr class="memdesc:a454cabefde0be10a2fdfb8daf8ecd5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement a 32-bit value by 1 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:a454cabefde0be10a2fdfb8daf8ecd5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d63a1b2d0be88b5fb2cdc5c512d503a" id="r_a4d63a1b2d0be88b5fb2cdc5c512d503a"><td class="memItemLeft" align="right" valign="top"><a id="a4d63a1b2d0be88b5fb2cdc5c512d503a" name="a4d63a1b2d0be88b5fb2cdc5c512d503a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicRead32</b>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 0)</td></tr>
<tr class="memdesc:a4d63a1b2d0be88b5fb2cdc5c512d503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic read a 32-bit value (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:a4d63a1b2d0be88b5fb2cdc5c512d503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67214a0b7033d6a6f0d11598114b234" id="r_ad67214a0b7033d6a6f0d11598114b234"><td class="memItemLeft" align="right" valign="top"><a id="ad67214a0b7033d6a6f0d11598114b234" name="ad67214a0b7033d6a6f0d11598114b234"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicAdd32</b>(x,  b)&#160;&#160;&#160;__sync_add_and_fetch((x), (b))</td></tr>
<tr class="memdesc:ad67214a0b7033d6a6f0d11598114b234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add a 32-bit value by a 32-bit value sent (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:ad67214a0b7033d6a6f0d11598114b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410df78a5206e91ff85b6e3396f82143" id="r_a410df78a5206e91ff85b6e3396f82143"><td class="memItemLeft" align="right" valign="top"><a id="a410df78a5206e91ff85b6e3396f82143" name="a410df78a5206e91ff85b6e3396f82143"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicInc64</b>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 1)</td></tr>
<tr class="memdesc:a410df78a5206e91ff85b6e3396f82143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment a 64-bit value by 1 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:a410df78a5206e91ff85b6e3396f82143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67804e8711bf5f37fe87bef998b1851" id="r_aa67804e8711bf5f37fe87bef998b1851"><td class="memItemLeft" align="right" valign="top"><a id="aa67804e8711bf5f37fe87bef998b1851" name="aa67804e8711bf5f37fe87bef998b1851"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicDec64</b>(x)&#160;&#160;&#160;__sync_sub_and_fetch((x), 1)</td></tr>
<tr class="memdesc:aa67804e8711bf5f37fe87bef998b1851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement a 64-bit value by 1 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:aa67804e8711bf5f37fe87bef998b1851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ef25ff1dd8cb6758997de8f9f0d898" id="r_af7ef25ff1dd8cb6758997de8f9f0d898"><td class="memItemLeft" align="right" valign="top"><a id="af7ef25ff1dd8cb6758997de8f9f0d898" name="af7ef25ff1dd8cb6758997de8f9f0d898"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicRead64</b>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 0)</td></tr>
<tr class="memdesc:af7ef25ff1dd8cb6758997de8f9f0d898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic read a 64-bit value (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:af7ef25ff1dd8cb6758997de8f9f0d898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192690bc56f30e4e66dd4f08139a1dbd" id="r_a192690bc56f30e4e66dd4f08139a1dbd"><td class="memItemLeft" align="right" valign="top"><a id="a192690bc56f30e4e66dd4f08139a1dbd" name="a192690bc56f30e4e66dd4f08139a1dbd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicAdd64</b>(x,  b)&#160;&#160;&#160;__sync_add_and_fetch((x), (b))</td></tr>
<tr class="memdesc:a192690bc56f30e4e66dd4f08139a1dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add a 64-bit value by a 64-bit value sent (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:a192690bc56f30e4e66dd4f08139a1dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e6eddf2fb4d5d160bcd0d9e59a147f" id="r_a66e6eddf2fb4d5d160bcd0d9e59a147f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66e6eddf2fb4d5d160bcd0d9e59a147f">CdiOsAtomicLoad16</a>(x)&#160;&#160;&#160;__atomic_load_n((x), __ATOMIC_CONSUME)</td></tr>
<tr class="memdesc:a66e6eddf2fb4d5d160bcd0d9e59a147f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic load value. Valid memory models are:  <br /></td></tr>
<tr class="separator:a66e6eddf2fb4d5d160bcd0d9e59a147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd79662ca6a1f9414aec4424bc0993b8" id="r_abd79662ca6a1f9414aec4424bc0993b8"><td class="memItemLeft" align="right" valign="top"><a id="abd79662ca6a1f9414aec4424bc0993b8" name="abd79662ca6a1f9414aec4424bc0993b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicLoad32</b>(x)&#160;&#160;&#160;__atomic_load_n((x), __ATOMIC_CONSUME)</td></tr>
<tr class="memdesc:abd79662ca6a1f9414aec4424bc0993b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit version of CdiOsAtomicLoad16 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:abd79662ca6a1f9414aec4424bc0993b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae568d17abf0d97550e5a596121a2138" id="r_aae568d17abf0d97550e5a596121a2138"><td class="memItemLeft" align="right" valign="top"><a id="aae568d17abf0d97550e5a596121a2138" name="aae568d17abf0d97550e5a596121a2138"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicLoad64</b>(x)&#160;&#160;&#160;__atomic_load_n((x), __ATOMIC_CONSUME)</td></tr>
<tr class="memdesc:aae568d17abf0d97550e5a596121a2138"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit version of CdiOsAtomicLoad16 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:aae568d17abf0d97550e5a596121a2138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a46959d5de6b92d372b2b5668a775" id="r_ac14a46959d5de6b92d372b2b5668a775"><td class="memItemLeft" align="right" valign="top"><a id="ac14a46959d5de6b92d372b2b5668a775" name="ac14a46959d5de6b92d372b2b5668a775"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicLoadPointer</b>(x)&#160;&#160;&#160;__atomic_load_n((x), __ATOMIC_CONSUME)</td></tr>
<tr class="memdesc:ac14a46959d5de6b92d372b2b5668a775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer version of CdiOsAtomicLoad16 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:ac14a46959d5de6b92d372b2b5668a775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f13138ad4be64b903f8f6b41b2a004" id="r_ab6f13138ad4be64b903f8f6b41b2a004"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6f13138ad4be64b903f8f6b41b2a004">CdiOsAtomicStore16</a>(x,  v)&#160;&#160;&#160;__atomic_store_n((x), (v), __ATOMIC_RELEASE)</td></tr>
<tr class="memdesc:ab6f13138ad4be64b903f8f6b41b2a004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic store value. Valid memory models are:  <br /></td></tr>
<tr class="separator:ab6f13138ad4be64b903f8f6b41b2a004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128078e33b6e606e68870f9a7880ccb9" id="r_a128078e33b6e606e68870f9a7880ccb9"><td class="memItemLeft" align="right" valign="top"><a id="a128078e33b6e606e68870f9a7880ccb9" name="a128078e33b6e606e68870f9a7880ccb9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicStore32</b>(x,  v)&#160;&#160;&#160;__atomic_store_n((x), (v), __ATOMIC_RELEASE)</td></tr>
<tr class="memdesc:a128078e33b6e606e68870f9a7880ccb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit version of CdiOsAtomicStore16 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:a128078e33b6e606e68870f9a7880ccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5328fb437f22834a38f66a859705d1" id="r_ada5328fb437f22834a38f66a859705d1"><td class="memItemLeft" align="right" valign="top"><a id="ada5328fb437f22834a38f66a859705d1" name="ada5328fb437f22834a38f66a859705d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicStore64</b>(x,  v)&#160;&#160;&#160;__atomic_store_n((x), (v), __ATOMIC_RELEASE)</td></tr>
<tr class="memdesc:ada5328fb437f22834a38f66a859705d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit version of CdiOsAtomicStore16 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:ada5328fb437f22834a38f66a859705d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb546371b1acb8bfda4b3e1b1e1ecc0a" id="r_afb546371b1acb8bfda4b3e1b1e1ecc0a"><td class="memItemLeft" align="right" valign="top"><a id="afb546371b1acb8bfda4b3e1b1e1ecc0a" name="afb546371b1acb8bfda4b3e1b1e1ecc0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsAtomicStorePointer</b>(x,  v)&#160;&#160;&#160;__atomic_store_n((x), (v), __ATOMIC_RELEASE)</td></tr>
<tr class="memdesc:afb546371b1acb8bfda4b3e1b1e1ecc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer version of CdiOsAtomicStore16 (matches windows variant, which uses functions). <br /></td></tr>
<tr class="separator:afb546371b1acb8bfda4b3e1b1e1ecc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6ab24c722d986db44472660a6bdf9d" id="r_a6f6ab24c722d986db44472660a6bdf9d"><td class="memItemLeft" align="right" valign="top"><a id="a6f6ab24c722d986db44472660a6bdf9d" name="a6f6ab24c722d986db44472660a6bdf9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_INVALID_HANDLE_VALUE</b>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:a6f6ab24c722d986db44472660a6bdf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable invalid handle. <br /></td></tr>
<tr class="separator:a6f6ab24c722d986db44472660a6bdf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162c6f627e7659fc6944a62787e21bbf" id="r_a162c6f627e7659fc6944a62787e21bbf"><td class="memItemLeft" align="right" valign="top"><a id="a162c6f627e7659fc6944a62787e21bbf" name="a162c6f627e7659fc6944a62787e21bbf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STATIC_MUTEX_INITIALIZER</b>&#160;&#160;&#160;PTHREAD_MUTEX_INITIALIZER</td></tr>
<tr class="memdesc:a162c6f627e7659fc6944a62787e21bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization value used to initialize the value of a static mutex variable. <br /></td></tr>
<tr class="separator:a162c6f627e7659fc6944a62787e21bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785ae1f312513983ebb98d06dd7b0f0c" id="r_a785ae1f312513983ebb98d06dd7b0f0c"><td class="memItemLeft" align="right" valign="top"><a id="a785ae1f312513983ebb98d06dd7b0f0c" name="a785ae1f312513983ebb98d06dd7b0f0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsStaticMutexLock</b>(x)&#160;&#160;&#160;pthread_mutex_lock(&amp;(x))</td></tr>
<tr class="memdesc:a785ae1f312513983ebb98d06dd7b0f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a statically generated mutex. <br /></td></tr>
<tr class="separator:a785ae1f312513983ebb98d06dd7b0f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b7e85c9d3796e6edd69fa9bc7968da" id="r_a19b7e85c9d3796e6edd69fa9bc7968da"><td class="memItemLeft" align="right" valign="top"><a id="a19b7e85c9d3796e6edd69fa9bc7968da" name="a19b7e85c9d3796e6edd69fa9bc7968da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsStaticMutexUnlock</b>(x)&#160;&#160;&#160;pthread_mutex_unlock(&amp;(x))</td></tr>
<tr class="memdesc:a19b7e85c9d3796e6edd69fa9bc7968da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a statically generated mutex. <br /></td></tr>
<tr class="separator:a19b7e85c9d3796e6edd69fa9bc7968da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bfbd7161f4832bb100bc62365ff44c" id="r_af6bfbd7161f4832bb100bc62365ff44c"><td class="memItemLeft" align="right" valign="top"><a id="af6bfbd7161f4832bb100bc62365ff44c" name="af6bfbd7161f4832bb100bc62365ff44c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_HUGE_PAGES_BYTE_SIZE</b>&#160;&#160;&#160;(2 * 1024 * 1024)</td></tr>
<tr class="memdesc:af6bfbd7161f4832bb100bc62365ff44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of huge pages. Memory must be a multiple of this size when using the <a class="el" href="#aef4f8a9b96f712a5a22029d059b0e01c">CdiOsMemAllocHugePage()</a> and <a class="el" href="#a65e895fcc0d143ad5a4b435a988b3adf">CdiOsMemFreeHugePage()</a> APIs. NOTE: Must match the "Hugepagesize" setting in /proc/meminfo. <br /></td></tr>
<tr class="separator:af6bfbd7161f4832bb100bc62365ff44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6866fde7f45f294b87aa255ecca1d1" id="r_a7a6866fde7f45f294b87aa255ecca1d1"><td class="memItemLeft" align="right" valign="top"><a id="a7a6866fde7f45f294b87aa255ecca1d1" name="a7a6866fde7f45f294b87aa255ecca1d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_STATIC_ASSERT</b>(condition,  message)&#160;&#160;&#160;_Static_assert(condition, message)</td></tr>
<tr class="memdesc:a7a6866fde7f45f294b87aa255ecca1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used to halt due to condition not being met during compile time. NOTE: Depending on GCC version, an assert failure may not use the specified message and instead generate an error similar to this: "error: negative width in bit-field ‘__error_if_negative". In this case, to see the specified message, see the next error in the compiler output. <br /></td></tr>
<tr class="separator:a7a6866fde7f45f294b87aa255ecca1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c4e1fa40265f0219058954e2bde196" id="r_a14c4e1fa40265f0219058954e2bde196"><td class="memItemLeft" align="right" valign="top"><a id="a14c4e1fa40265f0219058954e2bde196" name="a14c4e1fa40265f0219058954e2bde196"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_MAX_THREAD_NAME</b>&#160;&#160;&#160;(50)</td></tr>
<tr class="memdesc:a14c4e1fa40265f0219058954e2bde196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum thread name size. <br /></td></tr>
<tr class="separator:a14c4e1fa40265f0219058954e2bde196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9422f4615ea4927c720d07e81294c68c" id="r_a9422f4615ea4927c720d07e81294c68c"><td class="memItemLeft" align="right" valign="top"><a id="a9422f4615ea4927c720d07e81294c68c" name="a9422f4615ea4927c720d07e81294c68c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_OS_SIG_TIMEOUT</b>&#160;&#160;&#160;(0xFFFFFFFF)</td></tr>
<tr class="memdesc:a9422f4615ea4927c720d07e81294c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout value returned when waiting on a signal using <a class="el" href="#a439f7c7ae192a5a5bbf2976b82b302a7">CdiOsSignalsWait()</a>. <br /></td></tr>
<tr class="separator:a9422f4615ea4927c720d07e81294c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d461d2161ca7630e08ea5675d7885a5" id="r_a8d461d2161ca7630e08ea5675d7885a5"><td class="memItemLeft" align="right" valign="top"><a id="a8d461d2161ca7630e08ea5675d7885a5" name="a8d461d2161ca7630e08ea5675d7885a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_MAX_WAIT_MULTIPLE</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="memdesc:a8d461d2161ca7630e08ea5675d7885a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of signals that can be passed to <a class="el" href="#a439f7c7ae192a5a5bbf2976b82b302a7">CdiOsSignalsWait()</a>. <br /></td></tr>
<tr class="separator:a8d461d2161ca7630e08ea5675d7885a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed8a82ee09644081c2b36d6a1181147" id="r_a5ed8a82ee09644081c2b36d6a1181147"><td class="memItemLeft" align="right" valign="top"><a id="a5ed8a82ee09644081c2b36d6a1181147" name="a5ed8a82ee09644081c2b36d6a1181147"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_OS_SOCKET_MAX_IOVCNT</b>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:a5ed8a82ee09644081c2b36d6a1181147"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of iovec array that can be passed in to <a class="el" href="#a70a3e87ac6f485f1ae44e58c307f2b8d">CdiOsSocketWrite()</a>. <br /></td></tr>
<tr class="separator:a5ed8a82ee09644081c2b36d6a1181147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac042d8501b00160c33330c61dc2fe6d6" id="r_ac042d8501b00160c33330c61dc2fe6d6"><td class="memItemLeft" align="right" valign="top"><a id="ac042d8501b00160c33330c61dc2fe6d6" name="ac042d8501b00160c33330c61dc2fe6d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_MAX_SIGNAL_HANDLERS</b>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:ac042d8501b00160c33330c61dc2fe6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of signal handlers. <br /></td></tr>
<tr class="separator:ac042d8501b00160c33330c61dc2fe6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614fe72455471ef528d914f65783dea0" id="r_a614fe72455471ef528d914f65783dea0"><td class="memItemLeft" align="right" valign="top"><a id="a614fe72455471ef528d914f65783dea0" name="a614fe72455471ef528d914f65783dea0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CDI_MAX_FORMATTED_TIMEZONE_STRING_LENGTH</b>&#160;&#160;&#160;(128)</td></tr>
<tr class="memdesc:a614fe72455471ef528d914f65783dea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a single formatted time string. <br /></td></tr>
<tr class="separator:a614fe72455471ef528d914f65783dea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9b99449894772f1340310dfecb95e1" id="r_adc9b99449894772f1340310dfecb95e1"><td class="memItemLeft" align="right" valign="top"><a id="adc9b99449894772f1340310dfecb95e1" name="adc9b99449894772f1340310dfecb95e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsStrTokR</b>&#160;&#160;&#160;strtok_r</td></tr>
<tr class="memdesc:adc9b99449894772f1340310dfecb95e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; get a string token <br /></td></tr>
<tr class="separator:adc9b99449894772f1340310dfecb95e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6afef7fc59acff130e5da7156a1094" id="r_aac6afef7fc59acff130e5da7156a1094"><td class="memItemLeft" align="right" valign="top"><a id="aac6afef7fc59acff130e5da7156a1094" name="aac6afef7fc59acff130e5da7156a1094"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsStrNCaseCmp</b>&#160;&#160;&#160;strncasecmp</td></tr>
<tr class="memdesc:aac6afef7fc59acff130e5da7156a1094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to compare two strings specifying the number of characters to compare, ignoring the case of the characters. <br /></td></tr>
<tr class="separator:aac6afef7fc59acff130e5da7156a1094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc77a1164915026b553eabfcac49a9" id="r_a7fdc77a1164915026b553eabfcac49a9"><td class="memItemLeft" align="right" valign="top"><a id="a7fdc77a1164915026b553eabfcac49a9" name="a7fdc77a1164915026b553eabfcac49a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CdiOsStrCaseCmp</b>&#160;&#160;&#160;strcasecmp</td></tr>
<tr class="memdesc:a7fdc77a1164915026b553eabfcac49a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to compare two strings, ignoring the case of the characters. <br /></td></tr>
<tr class="separator:a7fdc77a1164915026b553eabfcac49a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c759ed3a427a82320c6f570a0db599" id="r_a33c759ed3a427a82320c6f570a0db599"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33c759ed3a427a82320c6f570a0db599">CdiOsStrCmp</a>&#160;&#160;&#160;strcmp</td></tr>
<tr class="memdesc:a33c759ed3a427a82320c6f570a0db599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to compare two strings.  <br /></td></tr>
<tr class="separator:a33c759ed3a427a82320c6f570a0db599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44a50ecac5f9c09f6dc42cfe93b438a" id="r_ad44a50ecac5f9c09f6dc42cfe93b438a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad44a50ecac5f9c09f6dc42cfe93b438a">CdiOsStrNCmp</a>&#160;&#160;&#160;strncmp</td></tr>
<tr class="memdesc:ad44a50ecac5f9c09f6dc42cfe93b438a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to compare two strings specifying the number of characters to compare.  <br /></td></tr>
<tr class="separator:ad44a50ecac5f9c09f6dc42cfe93b438a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7826a62f782cd5c4fa6de317ff49ae1a" id="r_a7826a62f782cd5c4fa6de317ff49ae1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7826a62f782cd5c4fa6de317ff49ae1a">CdiOsGetMilliseconds</a>()&#160;&#160;&#160;(<a class="el" href="#a2bb605674813adf81812173fb70731f4">CdiOsGetMicroseconds</a>()/1000)</td></tr>
<tr class="memdesc:a7826a62f782cd5c4fa6de317ff49ae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get OS time in milliseconds that uses <a class="el" href="#a2bb605674813adf81812173fb70731f4" title="Timers get a microsecond timestamp from CLOCK_MONOTONIC on linux or from the performance counter on W...">CdiOsGetMicroseconds()</a>.  <br /></td></tr>
<tr class="separator:a7826a62f782cd5c4fa6de317ff49ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae81e397cf8839b0315e33bcc5d662b97" id="r_ae81e397cf8839b0315e33bcc5d662b97"><td class="memItemLeft" align="right" valign="top"><a id="ae81e397cf8839b0315e33bcc5d662b97" name="ae81e397cf8839b0315e33bcc5d662b97"></a>
typedef <a class="el" href="#af54546942bb91b024de5fae2a253564d">CDI_THREAD</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>CdiThreadFuncName</b>) (<a class="el" href="#aab844c6be7fd8f0472045ee71feaebeb">CDI_THREAD_PARAM</a>)</td></tr>
<tr class="memdesc:ae81e397cf8839b0315e33bcc5d662b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable thread function. <br /></td></tr>
<tr class="separator:ae81e397cf8839b0315e33bcc5d662b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05504fce619e2bf1a163b97d69e02dc1" id="r_a05504fce619e2bf1a163b97d69e02dc1"><td class="memItemLeft" align="right" valign="top"><a id="a05504fce619e2bf1a163b97d69e02dc1" name="a05504fce619e2bf1a163b97d69e02dc1"></a>
typedef pthread_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>CdiThreadData</b></td></tr>
<tr class="memdesc:a05504fce619e2bf1a163b97d69e02dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable thread data type. <br /></td></tr>
<tr class="separator:a05504fce619e2bf1a163b97d69e02dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65ad531722c47e738976d8cf899590c" id="r_ac65ad531722c47e738976d8cf899590c"><td class="memItemLeft" align="right" valign="top"><a id="ac65ad531722c47e738976d8cf899590c" name="ac65ad531722c47e738976d8cf899590c"></a>
typedef sem_t *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiSemID</b></td></tr>
<tr class="memdesc:ac65ad531722c47e738976d8cf899590c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable semaphore. <br /></td></tr>
<tr class="separator:ac65ad531722c47e738976d8cf899590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22200be4dcff65ba7189ecad9939c350" id="r_a22200be4dcff65ba7189ecad9939c350"><td class="memItemLeft" align="right" valign="top"><a id="a22200be4dcff65ba7189ecad9939c350" name="a22200be4dcff65ba7189ecad9939c350"></a>
typedef struct CdiSignalType_t *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiSignalType</b></td></tr>
<tr class="memdesc:a22200be4dcff65ba7189ecad9939c350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable signal type. Don't use void* here, which prevents the compiler from type checking. <br /></td></tr>
<tr class="separator:a22200be4dcff65ba7189ecad9939c350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe150a0bce0df701ef7ca559856156" id="r_a3ffe150a0bce0df701ef7ca559856156"><td class="memItemLeft" align="right" valign="top"><a id="a3ffe150a0bce0df701ef7ca559856156" name="a3ffe150a0bce0df701ef7ca559856156"></a>
typedef pthread_mutex_t *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiCsID</b></td></tr>
<tr class="memdesc:a3ffe150a0bce0df701ef7ca559856156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable critical section. <br /></td></tr>
<tr class="separator:a3ffe150a0bce0df701ef7ca559856156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d356ccbabe4d7e4a83db098dce96ab" id="r_a66d356ccbabe4d7e4a83db098dce96ab"><td class="memItemLeft" align="right" valign="top"><a id="a66d356ccbabe4d7e4a83db098dce96ab" name="a66d356ccbabe4d7e4a83db098dce96ab"></a>
typedef FILE *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiFileID</b></td></tr>
<tr class="memdesc:a66d356ccbabe4d7e4a83db098dce96ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable File ID type. <br /></td></tr>
<tr class="separator:a66d356ccbabe4d7e4a83db098dce96ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0503ea49922e76cca6be2b8261ad3ce" id="r_ad0503ea49922e76cca6be2b8261ad3ce"><td class="memItemLeft" align="right" valign="top">typedef pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0503ea49922e76cca6be2b8261ad3ce">CdiStaticMutexType</a></td></tr>
<tr class="memdesc:ad0503ea49922e76cca6be2b8261ad3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable static mutex type. An example implementation:  <br /></td></tr>
<tr class="separator:ad0503ea49922e76cca6be2b8261ad3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75656dffadf2d578ae0316591674bef3" id="r_a75656dffadf2d578ae0316591674bef3"><td class="memItemLeft" align="right" valign="top"><a id="a75656dffadf2d578ae0316591674bef3" name="a75656dffadf2d578ae0316591674bef3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>CdiSignalHandlerFunction</b>) (int sig, siginfo_t *siginfo, void *context)</td></tr>
<tr class="memdesc:a75656dffadf2d578ae0316591674bef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for signal handler. <br /></td></tr>
<tr class="separator:a75656dffadf2d578ae0316591674bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92339de6da4ce07a2b1c061508ba51f" id="r_ab92339de6da4ce07a2b1c061508ba51f"><td class="memItemLeft" align="right" valign="top"><a id="ab92339de6da4ce07a2b1c061508ba51f" name="ab92339de6da4ce07a2b1c061508ba51f"></a>
typedef struct CdiThreadID_t *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiThreadID</b></td></tr>
<tr class="memdesc:ab92339de6da4ce07a2b1c061508ba51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable thread type. Separate name from type, otherwise the typedef that follows it will generate a compile error (duplicate typedef). <br /></td></tr>
<tr class="separator:ab92339de6da4ce07a2b1c061508ba51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed48bb9368e3a457a430489e7d98aa" id="r_a98ed48bb9368e3a457a430489e7d98aa"><td class="memItemLeft" align="right" valign="top"><a id="a98ed48bb9368e3a457a430489e7d98aa" name="a98ed48bb9368e3a457a430489e7d98aa"></a>
typedef struct CdiSocket_t *&#160;</td><td class="memItemRight" valign="bottom"><b>CdiSocket</b></td></tr>
<tr class="memdesc:a98ed48bb9368e3a457a430489e7d98aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define portable socket type. <br /></td></tr>
<tr class="separator:a98ed48bb9368e3a457a430489e7d98aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86f1238e2b904870c23f5a1b773e271a" id="r_a86f1238e2b904870c23f5a1b773e271a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86f1238e2b904870c23f5a1b773e271a">CdiOsUseLogger</a> (void)</td></tr>
<tr class="separator:a86f1238e2b904870c23f5a1b773e271a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34162959674f22cf28be6854c96a865e" id="r_a34162959674f22cf28be6854c96a865e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34162959674f22cf28be6854c96a865e">CdiOsSignalHandlerSet</a> (int signal_num, <a class="el" href="#a75656dffadf2d578ae0316591674bef3">CdiSignalHandlerFunction</a> func_ptr)</td></tr>
<tr class="separator:a34162959674f22cf28be6854c96a865e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf0876a49820a51991452ac6e282537" id="r_aadf0876a49820a51991452ac6e282537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadf0876a49820a51991452ac6e282537">CdiOsThreadCreatePinned</a> (<a class="el" href="#ae81e397cf8839b0315e33bcc5d662b97">CdiThreadFuncName</a> thread_func, <a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> *thread_id_out_ptr, const char *thread_name_str, void *thread_func_arg_ptr, <a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> start_signal, int cpu_affinity)</td></tr>
<tr class="separator:aadf0876a49820a51991452ac6e282537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5f16b52a3aa133873f908ec9ae9c1d" id="r_a4b5f16b52a3aa133873f908ec9ae9c1d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b5f16b52a3aa133873f908ec9ae9c1d">CdiOsThreadCreate</a> (<a class="el" href="#ae81e397cf8839b0315e33bcc5d662b97">CdiThreadFuncName</a> thread_func, <a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> *thread_id_out_ptr, const char *thread_name_str, void *thread_func_arg_ptr, <a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> start_signal)</td></tr>
<tr class="separator:a4b5f16b52a3aa133873f908ec9ae9c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c514d38203d227ebc64f6e8829d9071" id="r_a9c514d38203d227ebc64f6e8829d9071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c514d38203d227ebc64f6e8829d9071">CdiOsThreadAllocData</a> (<a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> *handle_out_ptr)</td></tr>
<tr class="separator:a9c514d38203d227ebc64f6e8829d9071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdd7e451e2a4d2b50a8e0b63d9ab62b" id="r_a4fdd7e451e2a4d2b50a8e0b63d9ab62b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fdd7e451e2a4d2b50a8e0b63d9ab62b">CdiOsThreadFreeData</a> (<a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> handle)</td></tr>
<tr class="separator:a4fdd7e451e2a4d2b50a8e0b63d9ab62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d7ae999ef2eca07059aa20c677d5fe" id="r_a01d7ae999ef2eca07059aa20c677d5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01d7ae999ef2eca07059aa20c677d5fe">CdiOsThreadSetData</a> (<a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> handle, void *content_ptr)</td></tr>
<tr class="separator:a01d7ae999ef2eca07059aa20c677d5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e85c4f7d1407872a71e4fa63f344e1" id="r_af3e85c4f7d1407872a71e4fa63f344e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e85c4f7d1407872a71e4fa63f344e1">CdiOsThreadGetData</a> (<a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> handle, void **content_out_ptr)</td></tr>
<tr class="separator:af3e85c4f7d1407872a71e4fa63f344e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd364dca40b9e85b3cf856e4b51c51b5" id="r_afd364dca40b9e85b3cf856e4b51c51b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd364dca40b9e85b3cf856e4b51c51b5">CdiOsThreadGetName</a> (<a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> thread_id)</td></tr>
<tr class="separator:afd364dca40b9e85b3cf856e4b51c51b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62483a5790e5687bcffdbcf03acbee1e" id="r_a62483a5790e5687bcffdbcf03acbee1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62483a5790e5687bcffdbcf03acbee1e">CdiOsThreadJoin</a> (<a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> thread_id, uint32_t timeout_in_ms, bool *timed_out_ptr)</td></tr>
<tr class="separator:a62483a5790e5687bcffdbcf03acbee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc03e47099e61e3f70211918adf61606" id="r_afc03e47099e61e3f70211918adf61606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc03e47099e61e3f70211918adf61606">CdiOsSemaphoreCreate</a> (<a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> *ret_sem_handle_ptr, int sem_count)</td></tr>
<tr class="separator:afc03e47099e61e3f70211918adf61606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b04a1651c142ce9ccc0f75b3bd0e4a6" id="r_a6b04a1651c142ce9ccc0f75b3bd0e4a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b04a1651c142ce9ccc0f75b3bd0e4a6">CdiOsSemaphoreDelete</a> (<a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle)</td></tr>
<tr class="separator:a6b04a1651c142ce9ccc0f75b3bd0e4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16234a41bac735537b7d3351b576bebf" id="r_a16234a41bac735537b7d3351b576bebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16234a41bac735537b7d3351b576bebf">CdiOsSemaphoreRelease</a> (<a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle)</td></tr>
<tr class="separator:a16234a41bac735537b7d3351b576bebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbda849e60559597b673d7e9b1150377" id="r_acbda849e60559597b673d7e9b1150377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbda849e60559597b673d7e9b1150377">CdiOsSemaphoreReserve</a> (<a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle, int timeout_in_ms)</td></tr>
<tr class="separator:acbda849e60559597b673d7e9b1150377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8076e3f90e57bd1bee6879a23e60dad" id="r_ae8076e3f90e57bd1bee6879a23e60dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8076e3f90e57bd1bee6879a23e60dad">CdiOsSemaphoreValueGet</a> (<a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> sem_handle)</td></tr>
<tr class="separator:ae8076e3f90e57bd1bee6879a23e60dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08b9eb28c1604b208b899bc82ae9419" id="r_aa08b9eb28c1604b208b899bc82ae9419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa08b9eb28c1604b208b899bc82ae9419">CdiOsCritSectionCreate</a> (<a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> *cs_handle_ptr)</td></tr>
<tr class="separator:aa08b9eb28c1604b208b899bc82ae9419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057de9e2464a5e0ae15d5969e4151936" id="r_a057de9e2464a5e0ae15d5969e4151936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a057de9e2464a5e0ae15d5969e4151936">CdiOsCritSectionReserve</a> (<a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> cs_handle)</td></tr>
<tr class="separator:a057de9e2464a5e0ae15d5969e4151936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb03440c9538b561d6405a1b0610fd44" id="r_acb03440c9538b561d6405a1b0610fd44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb03440c9538b561d6405a1b0610fd44">CdiOsCritSectionRelease</a> (<a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> cs_handle)</td></tr>
<tr class="separator:acb03440c9538b561d6405a1b0610fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382cdbaff43614053d92cfd6a6974683" id="r_a382cdbaff43614053d92cfd6a6974683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a382cdbaff43614053d92cfd6a6974683">CdiOsCritSectionDelete</a> (<a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> cs_handle)</td></tr>
<tr class="separator:a382cdbaff43614053d92cfd6a6974683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211a289a2cc87ac4e72a11a0a823b2ea" id="r_a211a289a2cc87ac4e72a11a0a823b2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a211a289a2cc87ac4e72a11a0a823b2ea">CdiOsSignalCreate</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *signal_handle_ptr)</td></tr>
<tr class="separator:a211a289a2cc87ac4e72a11a0a823b2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d4c44ed9cf5c33bcf953f4b9c2a9e2" id="r_ab1d4c44ed9cf5c33bcf953f4b9c2a9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1d4c44ed9cf5c33bcf953f4b9c2a9e2">CdiOsSignalDelete</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:ab1d4c44ed9cf5c33bcf953f4b9c2a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cae02af10bdf519ea34c52cf6a10113" id="r_a3cae02af10bdf519ea34c52cf6a10113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cae02af10bdf519ea34c52cf6a10113">CdiOsSignalClear</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:a3cae02af10bdf519ea34c52cf6a10113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd3a88a7e652034d6f1f0b081f3026" id="r_ae2dd3a88a7e652034d6f1f0b081f3026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2dd3a88a7e652034d6f1f0b081f3026">CdiOsSignalSet</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:ae2dd3a88a7e652034d6f1f0b081f3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac273336e3782ede9895b1e8aa24caa84" id="r_ac273336e3782ede9895b1e8aa24caa84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac273336e3782ede9895b1e8aa24caa84">CdiOsSignalGet</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:ac273336e3782ede9895b1e8aa24caa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb324162fa22e2b27b4cedf3bd95552e" id="r_abb324162fa22e2b27b4cedf3bd95552e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb324162fa22e2b27b4cedf3bd95552e">CdiOsSignalReadState</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle)</td></tr>
<tr class="separator:abb324162fa22e2b27b4cedf3bd95552e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09395adb02b49b2a9fc83fd55e41060f" id="r_a09395adb02b49b2a9fc83fd55e41060f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09395adb02b49b2a9fc83fd55e41060f">CdiOsSignalWait</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> signal_handle, uint32_t timeout_in_ms, bool *timed_out_ptr)</td></tr>
<tr class="separator:a09395adb02b49b2a9fc83fd55e41060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439f7c7ae192a5a5bbf2976b82b302a7" id="r_a439f7c7ae192a5a5bbf2976b82b302a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a439f7c7ae192a5a5bbf2976b82b302a7">CdiOsSignalsWait</a> (<a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *signal_array, uint8_t num_signals, bool wait_all, uint32_t timeout_in_ms, uint32_t *ret_signal_index_ptr)</td></tr>
<tr class="separator:a439f7c7ae192a5a5bbf2976b82b302a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88131b25449508dd80bb2060e269b6" id="r_a8a88131b25449508dd80bb2060e269b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a88131b25449508dd80bb2060e269b6">CdiOsMemAlloc</a> (int64_t mem_size)</td></tr>
<tr class="separator:a8a88131b25449508dd80bb2060e269b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a371d81aa8b16257cac506c739e74b" id="r_ab7a371d81aa8b16257cac506c739e74b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7a371d81aa8b16257cac506c739e74b">CdiOsMemAllocZero</a> (int64_t mem_size)</td></tr>
<tr class="separator:ab7a371d81aa8b16257cac506c739e74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c83677e3fb0a346badc0b127417814b" id="r_a1c83677e3fb0a346badc0b127417814b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c83677e3fb0a346badc0b127417814b">CdiOsMemFree</a> (void *mem_ptr)</td></tr>
<tr class="separator:a1c83677e3fb0a346badc0b127417814b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4f8a9b96f712a5a22029d059b0e01c" id="r_aef4f8a9b96f712a5a22029d059b0e01c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef4f8a9b96f712a5a22029d059b0e01c">CdiOsMemAllocHugePage</a> (int64_t mem_size)</td></tr>
<tr class="separator:aef4f8a9b96f712a5a22029d059b0e01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e895fcc0d143ad5a4b435a988b3adf" id="r_a65e895fcc0d143ad5a4b435a988b3adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65e895fcc0d143ad5a4b435a988b3adf">CdiOsMemFreeHugePage</a> (void *mem_ptr, int64_t mem_size)</td></tr>
<tr class="separator:a65e895fcc0d143ad5a4b435a988b3adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1c662327b13bf5fed22a0dbadc9186" id="r_a2e1c662327b13bf5fed22a0dbadc9186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e1c662327b13bf5fed22a0dbadc9186">CdiOsOpenForWrite</a> (const char *file_name_str, <a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *file_handle_ptr)</td></tr>
<tr class="separator:a2e1c662327b13bf5fed22a0dbadc9186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef240836ccac0f72e882ed646eb97b1d" id="r_aef240836ccac0f72e882ed646eb97b1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef240836ccac0f72e882ed646eb97b1d">CdiOsOpenForRead</a> (const char *file_name_str, <a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *file_handle_ptr)</td></tr>
<tr class="separator:aef240836ccac0f72e882ed646eb97b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa221b41006ef8e2876970cec559d9949" id="r_aa221b41006ef8e2876970cec559d9949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa221b41006ef8e2876970cec559d9949">CdiOsClose</a> (<a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle)</td></tr>
<tr class="separator:aa221b41006ef8e2876970cec559d9949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9f20c96abcb847b91f7327036da544" id="r_ace9f20c96abcb847b91f7327036da544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9f20c96abcb847b91f7327036da544">CdiOsRead</a> (<a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, void *buffer_ptr, uint32_t byte_count, uint32_t *bytes_read_ptr)</td></tr>
<tr class="separator:ace9f20c96abcb847b91f7327036da544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff079ac1bf667a23ec396226493025c" id="r_a1ff079ac1bf667a23ec396226493025c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff079ac1bf667a23ec396226493025c">CdiOsWrite</a> (<a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, const void *data_ptr, uint32_t byte_count)</td></tr>
<tr class="separator:a1ff079ac1bf667a23ec396226493025c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda343e9cfa825313fca87c8b0589611" id="r_adda343e9cfa825313fca87c8b0589611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda343e9cfa825313fca87c8b0589611">CdiOsFlush</a> (<a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle)</td></tr>
<tr class="separator:adda343e9cfa825313fca87c8b0589611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93138500a097d99972181942fce734c0" id="r_a93138500a097d99972181942fce734c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93138500a097d99972181942fce734c0">CdiOsFTell</a> (<a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, uint64_t *current_position_ptr)</td></tr>
<tr class="separator:a93138500a097d99972181942fce734c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e075ba4c7828c8d89dc275843c6a35" id="r_ad8e075ba4c7828c8d89dc275843c6a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8e075ba4c7828c8d89dc275843c6a35">CdiOsFSeek</a> (<a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> file_handle, int64_t offset, int position)</td></tr>
<tr class="separator:ad8e075ba4c7828c8d89dc275843c6a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27e262410a0072d672cc981b053c746" id="r_ac27e262410a0072d672cc981b053c746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac27e262410a0072d672cc981b053c746">CdiOsSplitPath</a> (const char *filepath_str, char *filename_str, int filename_buf_size, char *directory_str, int directory_buf_size)</td></tr>
<tr class="separator:ac27e262410a0072d672cc981b053c746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8edf4100b3c804834da4075d50a0ecd" id="r_ab8edf4100b3c804834da4075d50a0ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8edf4100b3c804834da4075d50a0ecd">CdiOsIsPathWriteable</a> (const char *directory_str)</td></tr>
<tr class="separator:ab8edf4100b3c804834da4075d50a0ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7419c2c17e985dd70f789220e64aea31" id="r_a7419c2c17e985dd70f789220e64aea31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7419c2c17e985dd70f789220e64aea31">CdiOsStrCpy</a> (char *dest_str, uint32_t max_str_len, const char *src_str)</td></tr>
<tr class="separator:a7419c2c17e985dd70f789220e64aea31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf41b619e308c9d7380f0d402b29bb0c" id="r_aaf41b619e308c9d7380f0d402b29bb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf41b619e308c9d7380f0d402b29bb0c">CdiOsSleep</a> (uint32_t milliseconds)</td></tr>
<tr class="separator:aaf41b619e308c9d7380f0d402b29bb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639cd6680111ab37344a16fb45a81842" id="r_a639cd6680111ab37344a16fb45a81842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a639cd6680111ab37344a16fb45a81842">CdiOsSleepMicroseconds</a> (uint32_t microseconds)</td></tr>
<tr class="separator:a639cd6680111ab37344a16fb45a81842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb605674813adf81812173fb70731f4" id="r_a2bb605674813adf81812173fb70731f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bb605674813adf81812173fb70731f4">CdiOsGetMicroseconds</a> (void)</td></tr>
<tr class="memdesc:a2bb605674813adf81812173fb70731f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timers get a microsecond timestamp from CLOCK_MONOTONIC on linux or from the performance counter on Windows.  <br /></td></tr>
<tr class="separator:a2bb605674813adf81812173fb70731f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a2615f7fbf5ff8f73a824f94eb3d9e" id="r_ad9a2615f7fbf5ff8f73a824f94eb3d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9a2615f7fbf5ff8f73a824f94eb3d9e">CdiOsGetUtcTime</a> (struct timespec *ret_time_ptr)</td></tr>
<tr class="memdesc:ad9a2615f7fbf5ff8f73a824f94eb3d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an OS call to get the current synced AWS network time in UTC format.  <br /></td></tr>
<tr class="separator:ad9a2615f7fbf5ff8f73a824f94eb3d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540403682510dc95be3ecf7a5f1e85a2" id="r_a540403682510dc95be3ecf7a5f1e85a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a540403682510dc95be3ecf7a5f1e85a2">CdiOsGetLocalTime</a> (struct tm *local_time_ret_ptr)</td></tr>
<tr class="separator:a540403682510dc95be3ecf7a5f1e85a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a13dd30f1bb45a6c7769260b1b9ece1" id="r_a4a13dd30f1bb45a6c7769260b1b9ece1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a13dd30f1bb45a6c7769260b1b9ece1">CdiOsGetLocalTimeString</a> (char *time_str, int max_string_len)</td></tr>
<tr class="separator:a4a13dd30f1bb45a6c7769260b1b9ece1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab467f10c926b1ad41abb02ed0934d" id="r_a51ab467f10c926b1ad41abb02ed0934d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51ab467f10c926b1ad41abb02ed0934d">CdiOsSocketOpen</a> (const char *host_address_str, int port_number, const char *bind_address_str, <a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> *new_socket_ptr)</td></tr>
<tr class="separator:a51ab467f10c926b1ad41abb02ed0934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ef666f0a782ae687d62681f419c4e" id="r_af52ef666f0a782ae687d62681f419c4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af52ef666f0a782ae687d62681f419c4e">CdiOsSocketGetPort</a> (<a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, int *port_number_ptr)</td></tr>
<tr class="separator:af52ef666f0a782ae687d62681f419c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53e90ed7e80796494db57c09b155303" id="r_af53e90ed7e80796494db57c09b155303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af53e90ed7e80796494db57c09b155303">CdiOsSocketGetSockAddrIn</a> (<a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, struct sockaddr_in *sockaddr_in_ptr)</td></tr>
<tr class="separator:af53e90ed7e80796494db57c09b155303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec61218a957d635125cbc2d43f9b413" id="r_a3ec61218a957d635125cbc2d43f9b413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec61218a957d635125cbc2d43f9b413">CdiOsSocketClose</a> (<a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle)</td></tr>
<tr class="separator:a3ec61218a957d635125cbc2d43f9b413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59ea85ac754fcd00570947c88400245" id="r_ac59ea85ac754fcd00570947c88400245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac59ea85ac754fcd00570947c88400245">CdiOsSocketRead</a> (<a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, void *buffer_ptr, int *byte_count_ptr)</td></tr>
<tr class="separator:ac59ea85ac754fcd00570947c88400245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccd2528a80d9d2b78b6f9b803047a4e" id="r_a9ccd2528a80d9d2b78b6f9b803047a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ccd2528a80d9d2b78b6f9b803047a4e">CdiOsSocketReadFrom</a> (<a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, void *buffer_ptr, int *byte_count_ptr, struct sockaddr_in *source_address_ptr)</td></tr>
<tr class="separator:a9ccd2528a80d9d2b78b6f9b803047a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a3e87ac6f485f1ae44e58c307f2b8d" id="r_a70a3e87ac6f485f1ae44e58c307f2b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70a3e87ac6f485f1ae44e58c307f2b8d">CdiOsSocketWrite</a> (<a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, struct iovec *iov, int iovcnt, int *byte_count_ptr)</td></tr>
<tr class="separator:a70a3e87ac6f485f1ae44e58c307f2b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbddbe739d3b8ec2ad256722a58f4944" id="r_acbddbe739d3b8ec2ad256722a58f4944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbddbe739d3b8ec2ad256722a58f4944">CdiOsSocketWriteTo</a> (<a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> socket_handle, struct iovec *iov, int iovcnt, const struct sockaddr_in *destination_address_ptr, int *byte_count_ptr)</td></tr>
<tr class="separator:acbddbe739d3b8ec2ad256722a58f4944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056467cb8e0194d783940c06f1d72c09" id="r_a056467cb8e0194d783940c06f1d72c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a056467cb8e0194d783940c06f1d72c09">CdiOsEnvironmentVariableSet</a> (const char *name_str, const char *value_str)</td></tr>
<tr class="separator:a056467cb8e0194d783940c06f1d72c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deb011a7c12b297491598e790eb8db0" id="r_a9deb011a7c12b297491598e790eb8db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9deb011a7c12b297491598e790eb8db0">CdiOsShutdown</a> (void)</td></tr>
<tr class="separator:a9deb011a7c12b297491598e790eb8db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the declarations for OS functions for creating/managing/freeing threads, semaphores, mutexes, critical sections, signals, memory and sockets. There are also abstractions for atomic operations as well as some time, sleep and string operations. These definitions in this module are here to account for differences between Linux and Windows. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a66e6eddf2fb4d5d160bcd0d9e59a147f" name="a66e6eddf2fb4d5d160bcd0d9e59a147f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e6eddf2fb4d5d160bcd0d9e59a147f">&#9670;&#160;</a></span>CdiOsAtomicLoad16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CdiOsAtomicLoad16</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">x</span></td><td>)</td>
          <td>&#160;&#160;&#160;__atomic_load_n((x), __ATOMIC_CONSUME)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic load value. Valid memory models are: </p>
<div class="fragment"><div class="line">__ATOMIC_RELAXED : No barriers or synchronization.</div>
<div class="line">__ATOMIC_CONSUME : Data dependency only <span class="keywordflow">for</span> both barrier and synchronization with another thread.</div>
<div class="line">__ATOMIC_ACQUIRE : Barrier to hoisting of code and synchronizes with release (or stronger) semantic stores from</div>
<div class="line">                   another thread.</div>
<div class="line">__ATOMIC_SEQ_CST : Full barrier in both directions and synchronizes with acquire loads and release stores in</div>
<div class="line">                   all threads.</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab6f13138ad4be64b903f8f6b41b2a004" name="ab6f13138ad4be64b903f8f6b41b2a004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f13138ad4be64b903f8f6b41b2a004">&#9670;&#160;</a></span>CdiOsAtomicStore16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CdiOsAtomicStore16</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">x, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">v</span>&#160;)&#160;&#160;&#160;__atomic_store_n((x), (v), __ATOMIC_RELEASE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic store value. Valid memory models are: </p>
<div class="fragment"><div class="line">__ATOMIC_RELAXED : No barriers or synchronization.</div>
<div class="line">__ATOMIC_RELEASE : Barrier to sinking of code and synchronizes with acquire (or stronger) semantic loads from</div>
<div class="line">                   another thread.</div>
<div class="line">__ATOMIC_SEQ_CST : Full barrier in both directions and synchronizes with acquire loads and release stores in</div>
<div class="line">                   all threads.</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7826a62f782cd5c4fa6de317ff49ae1a" name="a7826a62f782cd5c4fa6de317ff49ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7826a62f782cd5c4fa6de317ff49ae1a">&#9670;&#160;</a></span>CdiOsGetMilliseconds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CdiOsGetMilliseconds</td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="#a2bb605674813adf81812173fb70731f4">CdiOsGetMicroseconds</a>()/1000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to get OS time in milliseconds that uses <a class="el" href="#a2bb605674813adf81812173fb70731f4" title="Timers get a microsecond timestamp from CLOCK_MONOTONIC on linux or from the performance counter on W...">CdiOsGetMicroseconds()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Millisecond timestamp. </dd></dl>

</div>
</div>
<a id="a33c759ed3a427a82320c6f570a0db599" name="a33c759ed3a427a82320c6f570a0db599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c759ed3a427a82320c6f570a0db599">&#9670;&#160;</a></span>CdiOsStrCmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CdiOsStrCmp&#160;&#160;&#160;strcmp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to compare two strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>C string to be compared with string2. </td></tr>
    <tr><td class="paramname">string2</td><td>C string to be compared with string1. </td></tr>
    <tr><td class="paramname">num</td><td>Maximum number of characters to compare. NOTE: num is size_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns int = 0 both substrings are identical, &lt;0 string1 first non-matching character has a lower value than string2, &gt;0 string1 first non-matching character has a higher value than string2. </dd></dl>

</div>
</div>
<a id="ad44a50ecac5f9c09f6dc42cfe93b438a" name="ad44a50ecac5f9c09f6dc42cfe93b438a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44a50ecac5f9c09f6dc42cfe93b438a">&#9670;&#160;</a></span>CdiOsStrNCmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CdiOsStrNCmp&#160;&#160;&#160;strncmp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to compare two strings specifying the number of characters to compare. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>C string to be compared with string2. </td></tr>
    <tr><td class="paramname">string2</td><td>C string to be compared with string1. </td></tr>
    <tr><td class="paramname">num</td><td>Maximum number of characters to compare. NOTE: num is size_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns int =0 both substrings are identical, &lt;0 string1 first non-matching character has a lower value than string2, &gt;0 string1 first non-matching character has a higher value than string2. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad0503ea49922e76cca6be2b8261ad3ce" name="ad0503ea49922e76cca6be2b8261ad3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0503ea49922e76cca6be2b8261ad3ce">&#9670;&#160;</a></span>CdiStaticMutexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pthread_mutex_t <a class="el" href="#ad0503ea49922e76cca6be2b8261ad3ce">CdiStaticMutexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define portable static mutex type. An example implementation: </p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="#ad0503ea49922e76cca6be2b8261ad3ce">CdiStaticMutexType</a> my_lock = <a class="code hl_define" href="#a162c6f627e7659fc6944a62787e21bbf">CDI_STATIC_MUTEX_INITIALIZER</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Foo() {</div>
<div class="line">    <a class="code hl_define" href="#a785ae1f312513983ebb98d06dd7b0f0c">CdiOsStaticMutexLock</a>(my_lock);</div>
<div class="line">    <span class="comment">// Do something that uses a shared resource.</span></div>
<div class="line">    <a class="code hl_define" href="#a785ae1f312513983ebb98d06dd7b0f0c">CdiOsStaticMutexLock</a>(my_lock);</div>
<div class="line">}</div>
<div class="ttc" id="acdi__os__api_8h_html_a162c6f627e7659fc6944a62787e21bbf"><div class="ttname"><a href="#a162c6f627e7659fc6944a62787e21bbf">CDI_STATIC_MUTEX_INITIALIZER</a></div><div class="ttdeci">#define CDI_STATIC_MUTEX_INITIALIZER</div><div class="ttdoc">Initialization value used to initialize the value of a static mutex variable.</div><div class="ttdef"><b>Definition</b> cdi_os_api.h:274</div></div>
<div class="ttc" id="acdi__os__api_8h_html_a785ae1f312513983ebb98d06dd7b0f0c"><div class="ttname"><a href="#a785ae1f312513983ebb98d06dd7b0f0c">CdiOsStaticMutexLock</a></div><div class="ttdeci">#define CdiOsStaticMutexLock(x)</div><div class="ttdoc">Lock a statically generated mutex.</div><div class="ttdef"><b>Definition</b> cdi_os_api.h:276</div></div>
<div class="ttc" id="acdi__os__api_8h_html_ad0503ea49922e76cca6be2b8261ad3ce"><div class="ttname"><a href="#ad0503ea49922e76cca6be2b8261ad3ce">CdiStaticMutexType</a></div><div class="ttdeci">pthread_mutex_t CdiStaticMutexType</div><div class="ttdoc">Define portable static mutex type. An example implementation:</div><div class="ttdef"><b>Definition</b> cdi_os_api.h:272</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa221b41006ef8e2876970cec559d9949" name="aa221b41006ef8e2876970cec559d9949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa221b41006ef8e2876970cec559d9949">&#9670;&#160;</a></span>CdiOsClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of file to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="aa08b9eb28c1604b208b899bc82ae9419" name="aa08b9eb28c1604b208b899bc82ae9419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08b9eb28c1604b208b899bc82ae9419">&#9670;&#160;</a></span>CdiOsCritSectionCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsCritSectionCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a> *</td>          <td class="paramname"><span class="paramname"><em>cs_handle_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes a critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle_ptr</td><td>Pointer to critical section ID to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a382cdbaff43614053d92cfd6a6974683" name="a382cdbaff43614053d92cfd6a6974683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382cdbaff43614053d92cfd6a6974683">&#9670;&#160;</a></span>CdiOsCritSectionDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsCritSectionDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a></td>          <td class="paramname"><span class="paramname"><em>cs_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle</td><td>Pointer to critical section ID to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="acb03440c9538b561d6405a1b0610fd44" name="acb03440c9538b561d6405a1b0610fd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb03440c9538b561d6405a1b0610fd44">&#9670;&#160;</a></span>CdiOsCritSectionRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsCritSectionRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a></td>          <td class="paramname"><span class="paramname"><em>cs_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the specified critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle</td><td>Critical section ID to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a057de9e2464a5e0ae15d5969e4151936" name="a057de9e2464a5e0ae15d5969e4151936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057de9e2464a5e0ae15d5969e4151936">&#9670;&#160;</a></span>CdiOsCritSectionReserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsCritSectionReserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3ffe150a0bce0df701ef7ca559856156">CdiCsID</a></td>          <td class="paramname"><span class="paramname"><em>cs_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves the specified critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs_handle</td><td>Critical section ID to reserve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a056467cb8e0194d783940c06f1d72c09" name="a056467cb8e0194d783940c06f1d72c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056467cb8e0194d783940c06f1d72c09">&#9670;&#160;</a></span>CdiOsEnvironmentVariableSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsEnvironmentVariableSet </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an environment variable for the currently running process. NOTE: Does not set the process's shell environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_str</td><td>Pointer to string name of variable to set. Assumed to be a non-NULL value. </td></tr>
    <tr><td class="paramname">value_str</td><td>Pointer to string value to set. NOTE: Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="adda343e9cfa825313fca87c8b0589611" name="adda343e9cfa825313fca87c8b0589611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda343e9cfa825313fca87c8b0589611">&#9670;&#160;</a></span>CdiOsFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes write buffers for the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of the file to flush.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ad8e075ba4c7828c8d89dc275843c6a35" name="ad8e075ba4c7828c8d89dc275843c6a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e075ba4c7828c8d89dc275843c6a35">&#9670;&#160;</a></span>CdiOsFSeek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsFSeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>position</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current file position for the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of the file. </td></tr>
    <tr><td class="paramname">offset</td><td>Number of bytes to offset from position. </td></tr>
    <tr><td class="paramname">position</td><td>The position from where offset is added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a93138500a097d99972181942fce734c0" name="a93138500a097d99972181942fce734c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93138500a097d99972181942fce734c0">&#9670;&#160;</a></span>CdiOsFTell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsFTell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>current_position_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current file position for the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of the file. </td></tr>
    <tr><td class="paramname">current_position_ptr</td><td>Pointer to current position of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a540403682510dc95be3ecf7a5f1e85a2" name="a540403682510dc95be3ecf7a5f1e85a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540403682510dc95be3ecf7a5f1e85a2">&#9670;&#160;</a></span>CdiOsGetLocalTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsGetLocalTime </td>
          <td>(</td>
          <td class="paramtype">struct tm *</td>          <td class="paramname"><span class="paramname"><em>local_time_ret_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current local time as "tm" structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_time_ret_ptr</td><td>Pointer to returned local time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a13dd30f1bb45a6c7769260b1b9ece1" name="a4a13dd30f1bb45a6c7769260b1b9ece1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a13dd30f1bb45a6c7769260b1b9ece1">&#9670;&#160;</a></span>CdiOsGetLocalTimeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> int CdiOsGetLocalTimeString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>time_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_string_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current local time as a formatted as ISO 8601.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_str</td><td>Formatted string to represent ISO 8601 time format. </td></tr>
    <tr><td class="paramname">max_string_len</td><td>Maximum allowable characters in the time string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char_count Returns the number of characters of the formatted string. </dd></dl>

</div>
</div>
<a id="a2bb605674813adf81812173fb70731f4" name="a2bb605674813adf81812173fb70731f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb605674813adf81812173fb70731f4">&#9670;&#160;</a></span>CdiOsGetMicroseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> uint64_t CdiOsGetMicroseconds </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timers get a microsecond timestamp from CLOCK_MONOTONIC on linux or from the performance counter on Windows. </p>
<dl class="section return"><dt>Returns</dt><dd>Microsecond timestamp. </dd></dl>

</div>
</div>
<a id="ad9a2615f7fbf5ff8f73a824f94eb3d9e" name="ad9a2615f7fbf5ff8f73a824f94eb3d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a2615f7fbf5ff8f73a824f94eb3d9e">&#9670;&#160;</a></span>CdiOsGetUtcTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsGetUtcTime </td>
          <td>(</td>
          <td class="paramtype">struct timespec *</td>          <td class="paramname"><span class="paramname"><em>ret_time_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an OS call to get the current synced AWS network time in UTC format. </p>
<p>This function will be kept up to date with the best practices for getting high accuracy time from Amazon Time Sync Service as improved accuracy time is available. All EC2 instances that call this function should be using the Amazon Time Sync Service. Amazon Time Sync Service setup directions for Linux can be found at: <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html#configure-amazon-time-service">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html#configure-amazon-time-service</a></p>
<p>For Windows follow the directions at: <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-set-time.html">https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-set-time.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret_time_ptr</td><td>a pointer returned to a UTC timestamp in the format of a timespec structure as defined by time.h. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8edf4100b3c804834da4075d50a0ecd" name="ab8edf4100b3c804834da4075d50a0ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8edf4100b3c804834da4075d50a0ecd">&#9670;&#160;</a></span>CdiOsIsPathWriteable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsIsPathWriteable </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>directory_str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a directory string and verifies that the directory exists and is writeable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory_str</td><td>String containing the directory path, including any end '/' without the filename.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a8a88131b25449508dd80bb2060e269b6" name="a8a88131b25449508dd80bb2060e269b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a88131b25449508dd80bb2060e269b6">&#9670;&#160;</a></span>CdiOsMemAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void * CdiOsMemAlloc </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a block of memory and returns a pointer to the start of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_size</td><td>Number of bytes to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory block. If unable to allocate the memory block, NULL is returned. </dd></dl>

</div>
</div>
<a id="aef4f8a9b96f712a5a22029d059b0e01c" name="aef4f8a9b96f712a5a22029d059b0e01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4f8a9b96f712a5a22029d059b0e01c">&#9670;&#160;</a></span>CdiOsMemAllocHugePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void * CdiOsMemAllocHugePage </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a block of huge page memory and returns a pointer to the start of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_size</td><td>Number of bytes to allocate. Size must be a multiple of CDI_HUGE_PAGES_BYTE_SIZE. If not, NULL is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory block. If unable to allocate the memory block, NULL is returned. </dd></dl>

</div>
</div>
<a id="ab7a371d81aa8b16257cac506c739e74b" name="ab7a371d81aa8b16257cac506c739e74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a371d81aa8b16257cac506c739e74b">&#9670;&#160;</a></span>CdiOsMemAllocZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void * CdiOsMemAllocZero </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a block of memory, writes zero across its entirety, and returns a pointer to the start of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_size</td><td>Number of bytes to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory block. If unable to allocate the memory block, NULL is returned. </dd></dl>

</div>
</div>
<a id="a1c83677e3fb0a346badc0b127417814b" name="a1c83677e3fb0a346badc0b127417814b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c83677e3fb0a346badc0b127417814b">&#9670;&#160;</a></span>CdiOsMemFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsMemFree </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>mem_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a previously allocated block of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_ptr</td><td>Pointer to start address of memory block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65e895fcc0d143ad5a4b435a988b3adf" name="a65e895fcc0d143ad5a4b435a988b3adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e895fcc0d143ad5a4b435a988b3adf">&#9670;&#160;</a></span>CdiOsMemFreeHugePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsMemFreeHugePage </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>mem_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mem_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a previously allocated block of huge page memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_ptr</td><td>Pointer to start address of memory block. </td></tr>
    <tr><td class="paramname">mem_size</td><td>Number of bytes that were allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef240836ccac0f72e882ed646eb97b1d" name="aef240836ccac0f72e882ed646eb97b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef240836ccac0f72e882ed646eb97b1d">&#9670;&#160;</a></span>CdiOsOpenForRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsOpenForRead </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *</td>          <td class="paramname"><span class="paramname"><em>file_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a file (file_name_str) for read and returns a file handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name_str</td><td>Pointer to filename to open. </td></tr>
    <tr><td class="paramname">file_handle_ptr</td><td>Address where to write returned file handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a2e1c662327b13bf5fed22a0dbadc9186" name="a2e1c662327b13bf5fed22a0dbadc9186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1c662327b13bf5fed22a0dbadc9186">&#9670;&#160;</a></span>CdiOsOpenForWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsOpenForWrite </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a> *</td>          <td class="paramname"><span class="paramname"><em>file_handle_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a file (file_name_str) for writing and returns a file handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name_str</td><td>Pointer to filename to open. </td></tr>
    <tr><td class="paramname">file_handle_ptr</td><td>Address where to write returned file handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ace9f20c96abcb847b91f7327036da544" name="ace9f20c96abcb847b91f7327036da544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9f20c96abcb847b91f7327036da544">&#9670;&#160;</a></span>CdiOsRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>byte_count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>bytes_read_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of file to read from. </td></tr>
    <tr><td class="paramname">buffer_ptr</td><td>Pointer to buffer to read in to. </td></tr>
    <tr><td class="paramname">byte_count</td><td>Number of bytes to read into the buffer pointed to by buffer_ptr. </td></tr>
    <tr><td class="paramname">bytes_read_ptr</td><td>Returns the number of bytes read (NULL if you don't care).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. Check EOF using OS's EOF API function. </dd></dl>

</div>
</div>
<a id="afc03e47099e61e3f70211918adf61606" name="afc03e47099e61e3f70211918adf61606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc03e47099e61e3f70211918adf61606">&#9670;&#160;</a></span>CdiOsSemaphoreCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSemaphoreCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a> *</td>          <td class="paramname"><span class="paramname"><em>ret_sem_handle_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sem_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ret_sem_handle_ptr</td><td>Pointer to semaphore ID to return. </td></tr>
    <tr><td class="paramname">sem_count</td><td>Initial semaphore count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a6b04a1651c142ce9ccc0f75b3bd0e4a6" name="a6b04a1651c142ce9ccc0f75b3bd0e4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b04a1651c142ce9ccc0f75b3bd0e4a6">&#9670;&#160;</a></span>CdiOsSemaphoreDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSemaphoreDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Pointer to semaphore ID to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if successful, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a16234a41bac735537b7d3351b576bebf" name="a16234a41bac735537b7d3351b576bebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16234a41bac735537b7d3351b576bebf">&#9670;&#160;</a></span>CdiOsSemaphoreRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSemaphoreRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Semaphore ID to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="acbda849e60559597b673d7e9b1150377" name="acbda849e60559597b673d7e9b1150377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbda849e60559597b673d7e9b1150377">&#9670;&#160;</a></span>CdiOsSemaphoreReserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSemaphoreReserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves a semaphore and blocks if the current semaphore count is 0. If the semaphore is already reserved by the calling thread, then this call simply returns success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Semaphore ID to reserve. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>Amount of miliseconds to wait for the semaphore, CDI_INFINITE to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ae8076e3f90e57bd1bee6879a23e60dad" name="ae8076e3f90e57bd1bee6879a23e60dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8076e3f90e57bd1bee6879a23e60dad">&#9670;&#160;</a></span>CdiOsSemaphoreValueGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> int CdiOsSemaphoreValueGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac65ad531722c47e738976d8cf899590c">CdiSemID</a></td>          <td class="paramname"><span class="paramname"><em>sem_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of the given semaphore (ie. how many semaphore resources are available).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_handle</td><td>Semaphore ID to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of semaphore. </dd></dl>

</div>
</div>
<a id="a9deb011a7c12b297491598e790eb8db0" name="a9deb011a7c12b297491598e790eb8db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deb011a7c12b297491598e790eb8db0">&#9670;&#160;</a></span>CdiOsShutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsShutdown </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuts down OS specific resources used by the SDK. </p>

</div>
</div>
<a id="a3cae02af10bdf519ea34c52cf6a10113" name="a3cae02af10bdf519ea34c52cf6a10113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cae02af10bdf519ea34c52cf6a10113">&#9670;&#160;</a></span>CdiOsSignalClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function clears a signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to clear the value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a211a289a2cc87ac4e72a11a0a823b2ea" name="a211a289a2cc87ac4e72a11a0a823b2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211a289a2cc87ac4e72a11a0a823b2ea">&#9670;&#160;</a></span>CdiOsSignalCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>signal_handle_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a signal. The initial value is not signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle_ptr</td><td>Address where to write the returned signal handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ab1d4c44ed9cf5c33bcf953f4b9c2a9e2" name="ab1d4c44ed9cf5c33bcf953f4b9c2a9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d4c44ed9cf5c33bcf953f4b9c2a9e2">&#9670;&#160;</a></span>CdiOsSignalDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes a signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ac273336e3782ede9895b1e8aa24caa84" name="ac273336e3782ede9895b1e8aa24caa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac273336e3782ede9895b1e8aa24caa84">&#9670;&#160;</a></span>CdiOsSignalGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the value of the signal passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to get the value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a34162959674f22cf28be6854c96a865e" name="a34162959674f22cf28be6854c96a865e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34162959674f22cf28be6854c96a865e">&#9670;&#160;</a></span>CdiOsSignalHandlerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalHandlerSet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>signal_num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a75656dffadf2d578ae0316591674bef3">CdiSignalHandlerFunction</a></td>          <td class="paramname"><span class="paramname"><em>func_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the address to the default signal handler function shared by all threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_num</td><td>Number of the signal to set the new handler. </td></tr>
    <tr><td class="paramname">func_ptr</td><td>Address of signal handler function to set for the signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if there isn't enough storage to hold the signal or if there was an error. </dd></dl>

</div>
</div>
<a id="abb324162fa22e2b27b4cedf3bd95552e" name="abb324162fa22e2b27b4cedf3bd95552e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb324162fa22e2b27b4cedf3bd95552e">&#9670;&#160;</a></span>CdiOsSignalReadState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalReadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the value of the signal passed in without using any OS resources. It only accesses state data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to read the state value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ae2dd3a88a7e652034d6f1f0b081f3026" name="ae2dd3a88a7e652034d6f1f0b081f3026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2dd3a88a7e652034d6f1f0b081f3026">&#9670;&#160;</a></span>CdiOsSignalSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets a signal and its related state variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to set the value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a439f7c7ae192a5a5bbf2976b82b302a7" name="a439f7c7ae192a5a5bbf2976b82b302a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439f7c7ae192a5a5bbf2976b82b302a7">&#9670;&#160;</a></span>CdiOsSignalsWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalsWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a> *</td>          <td class="paramname"><span class="paramname"><em>signal_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>num_signals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait_all</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ret_signal_index_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function waits for an array of signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_array</td><td>Pointer to an array of signal handles to wait on. </td></tr>
    <tr><td class="paramname">num_signals</td><td>Number of signals in the array. </td></tr>
    <tr><td class="paramname">wait_all</td><td>Use true to wait for all signals, false to block on any signal. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">ret_signal_index_ptr</td><td>Pointer to the returned signal index that caused the thread to be signaled. if wait_all is true, then this is set to 1 when all signals are signaled. If a timeout occurred, CDI_OS_SIG_TIMEOUT is returned. This is an optional parameter, you can pass NULL if you don't care.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a09395adb02b49b2a9fc83fd55e41060f" name="a09395adb02b49b2a9fc83fd55e41060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09395adb02b49b2a9fc83fd55e41060f">&#9670;&#160;</a></span>CdiOsSignalWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSignalWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>signal_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>timed_out_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function waits for a signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handle</td><td>A signal handle to wait on. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>Timeout in mSec can be CDI_INFINITE to wait indefinitely. </td></tr>
    <tr><td class="paramname">timed_out_ptr</td><td>Pointer to boolean - set to true if timed out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="aaf41b619e308c9d7380f0d402b29bb0c" name="aaf41b619e308c9d7380f0d402b29bb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf41b619e308c9d7380f0d402b29bb0c">&#9670;&#160;</a></span>CdiOsSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsSleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>milliseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block the current thread for the specified number of milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>Block thread for this much time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a639cd6680111ab37344a16fb45a81842" name="a639cd6680111ab37344a16fb45a81842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639cd6680111ab37344a16fb45a81842">&#9670;&#160;</a></span>CdiOsSleepMicroseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsSleepMicroseconds </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>microseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block the current thread for microseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microseconds</td><td>Block thread for this much time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ec61218a957d635125cbc2d43f9b413" name="a3ec61218a957d635125cbc2d43f9b413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec61218a957d635125cbc2d43f9b413">&#9670;&#160;</a></span>CdiOsSocketClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a previously opened communications socket, freeing resources that were allocated for it including the local port if the socket was opened for receiving.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle of the socket which is to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the socket was closed cleanly, false if a problem was encountered trying to close it. </dd></dl>

</div>
</div>
<a id="af52ef666f0a782ae687d62681f419c4e" name="af52ef666f0a782ae687d62681f419c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52ef666f0a782ae687d62681f419c4e">&#9670;&#160;</a></span>CdiOsSocketGetPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketGetPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>port_number_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of the port to which the specified socket is bound. This is useful for receive sockets opened with their port number specified as 0, which makes the operating system assign a random port number. It also works on transmit sockets which are also randomly assigned a port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The socket whose port number is of interest. </td></tr>
    <tr><td class="paramname">port_number_ptr</td><td>Address of where the port number will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port number could be determined or false if a problem was encountered. </dd></dl>

</div>
</div>
<a id="af53e90ed7e80796494db57c09b155303" name="af53e90ed7e80796494db57c09b155303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53e90ed7e80796494db57c09b155303">&#9670;&#160;</a></span>CdiOsSocketGetSockAddrIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketGetSockAddrIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *</td>          <td class="paramname"><span class="paramname"><em>sockaddr_in_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the sockaddr_in structure to which the specified socket is bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The socket whose port number is of interest. </td></tr>
    <tr><td class="paramname">sockaddr_in_ptr</td><td>Address of where the sockaddr_in data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sockaddr_in data could be determined or false if a problem was encountered. </dd></dl>

</div>
</div>
<a id="a51ab467f10c926b1ad41abb02ed0934d" name="a51ab467f10c926b1ad41abb02ed0934d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ab467f10c926b1ad41abb02ed0934d">&#9670;&#160;</a></span>CdiOsSocketOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketOpen </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>host_address_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_number</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bind_address_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a> *</td>          <td class="paramname"><span class="paramname"><em>new_socket_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a unidirectional or bidirectional Internet Protocol User Datagram Protocol (IP/UDP) socket for communications. For a unidirectional socket to send on, specify the host address of the remote host. To create a unidirectional socket for receiving, specify NULL as host_address_str.</p>
<p>For a bidirectional socket, where datagrams can be sent and received through the socket, specify NULL as host_address_str for both client and server sides. For the client side, specify zero for port_number so a randomly selected port number is used. Call </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#af52ef666f0a782ae687d62681f419c4e">CdiOsSocketGetPort</a> to determine the port number that was assigned. When sending datagrams, Use </dd>
<dd>
<a class="el" href="#acbddbe739d3b8ec2ad256722a58f4944">CdiOsSocketWriteTo</a> to specify the remote destination address and port. For the server side, specify the local port number for port_number to listen for incoming datagrams. Use </dd>
<dd>
<a class="el" href="#a9ccd2528a80d9d2b78b6f9b803047a4e">CdiOsSocketReadFrom</a> so that the datagram's source host's IP address and port number are provided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_address_str</td><td>The address of the remote host (dotted IPv4 address) to which to send datagrams or NULL if the socket is to be used for receiving datagrams or is bidirectional. </td></tr>
    <tr><td class="paramname">port_number</td><td>For a unidirectional send-only socket, the numeric port number on the remote host. For a unidirectional receive only socket or server side of a bidirectional socket, the local port number to listen for incoming datagrams. For the client side of a bidirectional socket, use zero for this value so that a randomly selected port number is used. Call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af52ef666f0a782ae687d62681f419c4e">CdiOsSocketGetPort</a> to determine the port number that was assigned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bind_address_str</td><td>Optional bind address (dotted IPv4 address). If NULL, default interface is used. </td></tr>
    <tr><td class="paramname">new_socket_ptr</td><td>A pointer to the location which will get the new socket handle written to it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the socket was successfully opened and is ready for communications, otherwise false. </dd></dl>

</div>
</div>
<a id="ac59ea85ac754fcd00570947c88400245" name="ac59ea85ac754fcd00570947c88400245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59ea85ac754fcd00570947c88400245">&#9670;&#160;</a></span>CdiOsSocketRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously reads the next available datagram from the specified socket. If no datagram is available after a short timeout, true is returned but the value written to byte_count_ptr will be zero. This timeout is so that the caller can periodically check whether to shut down its polling loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket for which incoming datagrams are to be received. </td></tr>
    <tr><td class="paramname">buffer_ptr</td><td>The address in memory where the bytes of the datagram will be written. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>On entry, the value at the location pointed to must be the size of the buffer at buffer_ptr available for the datagram to be written. At exit, the address will be overwritten with the number of bytes that are actually contained in the datagram and thus written to the buffer. A value of 0 indicates that the read timed out waiting for a datagram and that the read should be retried unless the polling process should be shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the function succeeded, false if it failed. Timing out is considered to be success but zero will have been written to byte_count_ptr to disambiguate a timeout condition from data being written into the buffer. </dd></dl>

</div>
</div>
<a id="a9ccd2528a80d9d2b78b6f9b803047a4e" name="a9ccd2528a80d9d2b78b6f9b803047a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccd2528a80d9d2b78b6f9b803047a4e">&#9670;&#160;</a></span>CdiOsSocketReadFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketReadFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *</td>          <td class="paramname"><span class="paramname"><em>source_address_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously reads the next available datagram from the specified socket and provides the source IP address/port number. If no datagram is available after a short timeout, true is returned but the value written to byte_count_ptr will be zero. This timeout is so that the caller can periodically check whether to shut down its polling loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket for which incoming datagrams are to be received. </td></tr>
    <tr><td class="paramname">buffer_ptr</td><td>The address in memory where the bytes of the datagram will be written. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>On entry, the value at the location pointed to must be the size of the buffer at buffer_ptr available for the datagram to be written. At exit, the address will be overwritten with the number of bytes that are actually contained in the datagram and thus written to the buffer. A value of 0 indicates that the read timed out waiting for a datagram and that the read should be retried unless the polling process should be shut down. </td></tr>
    <tr><td class="paramname">source_address_ptr</td><td>Pointer to memory where the source address and port number from the UDP packet will be written so that the caller can determine where to send replies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the function succeeded, false if it failed. Timing out is considered to be success but zero will have been written to byte_count_ptr to disambiguate a timeout condition from data being written into the buffer. </dd></dl>

</div>
</div>
<a id="a70a3e87ac6f485f1ae44e58c307f2b8d" name="a70a3e87ac6f485f1ae44e58c307f2b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a3e87ac6f485f1ae44e58c307f2b8d">&#9670;&#160;</a></span>CdiOsSocketWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously write a datagram to a communications socket. The data is represented as an array of address pointers and sizes. This data is copied inside of the function so once it returns the buffer(s) are available for reuse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket through which the datagram will be written. </td></tr>
    <tr><td class="paramname">iov</td><td>The address of an array of iovec structures which specify the data to be sent. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of iovec structures contained in the iov array. This value is limited to CDI_OS_SOCKET_MAX_IOVCNT. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>The address of a location into which the number of bytes written to the socket will be placed if the datagram was successfully sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the datagram was successfully sent, false if not. Note that there is no guarantee that the datagram was actually received by the destination host. </dd></dl>

</div>
</div>
<a id="acbddbe739d3b8ec2ad256722a58f4944" name="acbddbe739d3b8ec2ad256722a58f4944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbddbe739d3b8ec2ad256722a58f4944">&#9670;&#160;</a></span>CdiOsSocketWriteTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSocketWriteTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a98ed48bb9368e3a457a430489e7d98aa">CdiSocket</a></td>          <td class="paramname"><span class="paramname"><em>socket_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_in *</td>          <td class="paramname"><span class="paramname"><em>destination_address_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>byte_count_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously write a datagram to a communications socket. The data is represented as an array of address pointers and sizes. This data is copied inside of the function so once it returns the buffer(s) are available for reuse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_handle</td><td>The handle for the socket through which the datagram will be written. </td></tr>
    <tr><td class="paramname">iov</td><td>The address of an array of iovec structures which specify the data to be sent. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of iovec structures contained in the iov array. This value is limited to RMT_OS_SOCKET_MAX_IOVCNT. </td></tr>
    <tr><td class="paramname">destination_address_ptr</td><td>Pointer to the destination (IP address and port number) to which to send the UDP packet. </td></tr>
    <tr><td class="paramname">byte_count_ptr</td><td>The address of a location into which the number of bytes written to the socket will be placed if the datagram was successfully sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the datagram was successfully sent, false if not. Note that there is no guarantee that the datagram was actually received by the destination host. </dd></dl>

</div>
</div>
<a id="ac27e262410a0072d672cc981b053c746" name="ac27e262410a0072d672cc981b053c746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27e262410a0072d672cc981b053c746">&#9670;&#160;</a></span>CdiOsSplitPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsSplitPath </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filepath_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>filename_buf_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>directory_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>directory_buf_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a filepath and breaks it into its component directory and filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath_str</td><td>String containing a path name and filename. </td></tr>
    <tr><td class="paramname">filename_str</td><td>String containing the filename without the path. Pass NULL for this parameter if the filename is not needed. </td></tr>
    <tr><td class="paramname">filename_buf_size</td><td>Size of the buffer sent for storing the filename string. </td></tr>
    <tr><td class="paramname">directory_str</td><td>String containing the directory path, including any end '/' without the filename. Pass NULL for this parameter if the directory path is not needed. </td></tr>
    <tr><td class="paramname">directory_buf_size</td><td>Size of the buffer sent for storing the directory path string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a7419c2c17e985dd70f789220e64aea31" name="a7419c2c17e985dd70f789220e64aea31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7419c2c17e985dd70f789220e64aea31">&#9670;&#160;</a></span>CdiOsStrCpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> int CdiOsStrCpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>max_str_len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A portable version of strcpy with range checking to replace Microsoft's strcpy_s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_str</td><td>Buffer to receive copied string. </td></tr>
    <tr><td class="paramname">max_str_len</td><td>Maximum number of characters to copy. This includes the terminating '\0'. </td></tr>
    <tr><td class="paramname">src_str</td><td>Source string to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters copied. </dd></dl>

</div>
</div>
<a id="a9c514d38203d227ebc64f6e8829d9071" name="a9c514d38203d227ebc64f6e8829d9071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c514d38203d227ebc64f6e8829d9071">&#9670;&#160;</a></span>CdiOsThreadAllocData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsThreadAllocData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a> *</td>          <td class="paramname"><span class="paramname"><em>handle_out_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a slot of thread-local storage. The slot is allocated once for the whole program, after which each thread can store and read private data from the slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_out_ptr</td><td>Returned handle for a thread data slot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a4b5f16b52a3aa133873f908ec9ae9c1d" name="a4b5f16b52a3aa133873f908ec9ae9c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5f16b52a3aa133873f908ec9ae9c1d">&#9670;&#160;</a></span>CdiOsThreadCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool CdiOsThreadCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae81e397cf8839b0315e33bcc5d662b97">CdiThreadFuncName</a></td>          <td class="paramname"><span class="paramname"><em>thread_func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_id_out_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>thread_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>thread_func_arg_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>start_signal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a thread. Note that thread pinning is inherited, so the launched thread will inherit the affinity of its parent if not explicitly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_func</td><td>Pointer to a function for the thread. </td></tr>
    <tr><td class="paramname">thread_id_out_ptr</td><td>Pointer to CdiThreadID to return. </td></tr>
    <tr><td class="paramname">thread_name_str</td><td>Optional Thread Name for debugging and logging purposes (NULL if don't care). </td></tr>
    <tr><td class="paramname">thread_func_arg_ptr</td><td>Optional pointer to user data passed to the thread delegate. </td></tr>
    <tr><td class="paramname">start_signal</td><td>Optional signal used to start the thread. If NULL, thread starts running immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="aadf0876a49820a51991452ac6e282537" name="aadf0876a49820a51991452ac6e282537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf0876a49820a51991452ac6e282537">&#9670;&#160;</a></span>CdiOsThreadCreatePinned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsThreadCreatePinned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae81e397cf8839b0315e33bcc5d662b97">CdiThreadFuncName</a></td>          <td class="paramname"><span class="paramname"><em>thread_func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a> *</td>          <td class="paramname"><span class="paramname"><em>thread_id_out_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>thread_name_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>thread_func_arg_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a22200be4dcff65ba7189ecad9939c350">CdiSignalType</a></td>          <td class="paramname"><span class="paramname"><em>start_signal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cpu_affinity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a thread which can optionally be pinned to a specific CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_func</td><td>Pointer to a function for the thread. </td></tr>
    <tr><td class="paramname">thread_id_out_ptr</td><td>Pointer to CdiThreadID to return. </td></tr>
    <tr><td class="paramname">thread_name_str</td><td>Optional Thread Name for debugging and logging purposes (NULL if don't care). </td></tr>
    <tr><td class="paramname">thread_func_arg_ptr</td><td>Optional pointer to user data passed to the thread delegate. </td></tr>
    <tr><td class="paramname">start_signal</td><td>Optional signal used to start the thread. If NULL, thread starts running immediately. </td></tr>
    <tr><td class="paramname">cpu_affinity</td><td>Zero-based CPU number to pin this thread to, -1 to not pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a4fdd7e451e2a4d2b50a8e0b63d9ab62b" name="a4fdd7e451e2a4d2b50a8e0b63d9ab62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdd7e451e2a4d2b50a8e0b63d9ab62b">&#9670;&#160;</a></span>CdiOsThreadFreeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsThreadFreeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a slot of thread-local storage. Should be called before program exit but after all threads are done using the slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle of thread data to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="af3e85c4f7d1407872a71e4fa63f344e1" name="af3e85c4f7d1407872a71e4fa63f344e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e85c4f7d1407872a71e4fa63f344e1">&#9670;&#160;</a></span>CdiOsThreadGetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsThreadGetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>content_out_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of this thread's copy of a thread-local storage slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to thread data slot. </td></tr>
    <tr><td class="paramname">content_out_ptr</td><td>Pointer to a variable which receives the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="afd364dca40b9e85b3cf856e4b51c51b5" name="afd364dca40b9e85b3cf856e4b51c51b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd364dca40b9e85b3cf856e4b51c51b5">&#9670;&#160;</a></span>CdiOsThreadGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> const char * CdiOsThreadGetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a></td>          <td class="paramname"><span class="paramname"><em>thread_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the thread that was created using <a class="el" href="#aadf0876a49820a51991452ac6e282537">CdiOsThreadCreatePinned()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Data structure for thread to get name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to name of the thread. </dd></dl>

</div>
</div>
<a id="a62483a5790e5687bcffdbcf03acbee1e" name="a62483a5790e5687bcffdbcf03acbee1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62483a5790e5687bcffdbcf03acbee1e">&#9670;&#160;</a></span>CdiOsThreadJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsThreadJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab92339de6da4ce07a2b1c061508ba51f">CdiThreadID</a></td>          <td class="paramname"><span class="paramname"><em>thread_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_in_ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>timed_out_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits/blocks until the given thread has finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Data structure for thread to wait for. </td></tr>
    <tr><td class="paramname">timeout_in_ms</td><td>How long to wait for join before timing out. </td></tr>
    <tr><td class="paramname">timed_out_ptr</td><td>Pointer to a boolean that indicates a timeout has occurred when true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a01d7ae999ef2eca07059aa20c677d5fe" name="a01d7ae999ef2eca07059aa20c677d5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d7ae999ef2eca07059aa20c677d5fe">&#9670;&#160;</a></span>CdiOsThreadSetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsThreadSetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a05504fce619e2bf1a163b97d69e02dc1">CdiThreadData</a></td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>content_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a value in this thread's copy of a thread-local storage slot. Calls to osThreadGetData from the same thread will get this value back. The slot must have been allocated by CdiOsThreadAllocData.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to thread data slot. </td></tr>
    <tr><td class="paramname">content_ptr</td><td>Pointer to be stored in the slot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a86f1238e2b904870c23f5a1b773e271a" name="a86f1238e2b904870c23f5a1b773e271a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f1238e2b904870c23f5a1b773e271a">&#9670;&#160;</a></span>CdiOsUseLogger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> void CdiOsUseLogger </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable use of the logger when generating error messages. This function is normally used internally as part of initialization of the CDI SDK. If it is not used, then output will be directed to stderr. </p>

</div>
</div>
<a id="a1ff079ac1bf667a23ec396226493025c" name="a1ff079ac1bf667a23ec396226493025c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff079ac1bf667a23ec396226493025c">&#9670;&#160;</a></span>CdiOsWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__utility__api_8h.html#a59fd7f46ded9be03f112db94c8c428f9">CDI_INTERFACE</a> bool CdiOsWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a66d356ccbabe4d7e4a83db098dce96ab">CdiFileID</a></td>          <td class="paramname"><span class="paramname"><em>file_handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>byte_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_handle</td><td>Identifier of file to write to. </td></tr>
    <tr><td class="paramname">data_ptr</td><td>Pointer to data to write. </td></tr>
    <tr><td class="paramname">byte_count</td><td>Number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
