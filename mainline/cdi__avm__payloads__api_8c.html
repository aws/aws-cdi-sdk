<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<title>CDI SDK: src/cdi/cdi_avm_payloads_api.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image_left.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDI SDK
   </div>
   <div id="projectbrief">SDK for transporting chunks of data reliably and with low latency using a polled mode network driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_440858bc2ff41f5ef15b020e90223871.html">cdi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cdi_avm_payloads_api.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file implements the AVM payloads API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cdi__avm__payloads__api_8h_source.html">cdi_avm_payloads_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cdi__os__api_8h_source.html">cdi_os_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="anc__payloads_8h_source.html">anc_payloads.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7553c0ab7eed3ea5b303a92f6c3c8ed5" id="r_a7553c0ab7eed3ea5b303a92f6c3c8ed5"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7553c0ab7eed3ea5b303a92f6c3c8ed5">CopyToLinearBuffer</a> (<a class="el" href="structCdiSgList.html">CdiSgList</a> const *sgl_ptr)</td></tr>
<tr class="separator:a7553c0ab7eed3ea5b303a92f6c3c8ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929dca44761a611b336a5a1b06c7873f" id="r_a929dca44761a611b336a5a1b06c7873f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a929dca44761a611b336a5a1b06c7873f">PrecheckAncillaryDataPayload</a> (const char *buffer_ptr, int payload_size_in_bytes)</td></tr>
<tr class="separator:a929dca44761a611b336a5a1b06c7873f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79724eb1e41f99d0e1873163c66760a" id="r_aa79724eb1e41f99d0e1873163c66760a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa79724eb1e41f99d0e1873163c66760a">CopyInternalToPublicPacket</a> (<a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *dest_packet_ptr, const struct <a class="el" href="structAncillaryDataPacket.html">AncillaryDataPacket</a> *source_packet_ptr)</td></tr>
<tr class="separator:aa79724eb1e41f99d0e1873163c66760a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b077fa3c3f527db3b38c9f472520a0" id="r_a15b077fa3c3f527db3b38c9f472520a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15b077fa3c3f527db3b38c9f472520a0">CopyPublicToInternalPacket</a> (struct <a class="el" href="structAncillaryDataPacket.html">AncillaryDataPacket</a> *dest_packet_ptr, const <a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *source_packet_ptr)</td></tr>
<tr class="separator:a15b077fa3c3f527db3b38c9f472520a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9df08d4325dad6b8243e967be85f79" id="r_a2a9df08d4325dad6b8243e967be85f79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a9df08d4325dad6b8243e967be85f79">CdiAvmCopyAncillaryDataPacket</a> (<a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *dest_packet_ptr, const <a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *source_packet_ptr)</td></tr>
<tr class="separator:a2a9df08d4325dad6b8243e967be85f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db788cd2c36912bf21f2dd7bbf43d9d" id="r_a4db788cd2c36912bf21f2dd7bbf43d9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db788cd2c36912bf21f2dd7bbf43d9d">CdiAvmGetAncillaryDataPayloadSize</a> (uint16_t num_anc_packets, uint8_t data_counts[])</td></tr>
<tr class="separator:a4db788cd2c36912bf21f2dd7bbf43d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4b2ae86dffba38e8567d62e8938ccf" id="r_abe4b2ae86dffba38e8567d62e8938ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe4b2ae86dffba38e8567d62e8938ccf">CdiAvmPacketizeAncillaryData</a> (<a class="el" href="cdi__avm__payloads__api_8h.html#aae1d1f01c2b665619fe938debd97b92a">CdiAvmPacketizeAncCallback</a> *produce_next_packet_ptr, <a class="el" href="cdi__avm__payloads__api_8h.html#add4ad41e6a5c8521ba83849b09d78afd">CdiFieldKind</a> field_kind, void *context_ptr, char *buffer_ptr, int *size_in_bytes_ptr)</td></tr>
<tr class="separator:abe4b2ae86dffba38e8567d62e8938ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f1fc35880137621ddf3164d61aa3d1" id="r_a12f1fc35880137621ddf3164d61aa3d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12f1fc35880137621ddf3164d61aa3d1">CdiAvmUnpacketizeAncillaryData</a> (const <a class="el" href="structCdiSgList.html">CdiSgList</a> *sgl_ptr, <a class="el" href="cdi__avm__payloads__api_8h.html#a4f43ef501de76d4a2fc926ede3cd4490">CdiAvmUnpacketizeAncCallback</a> *consume_next_packet_ptr, void *context_ptr)</td></tr>
<tr class="separator:a12f1fc35880137621ddf3164d61aa3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements the AVM payloads API. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2a9df08d4325dad6b8243e967be85f79" name="a2a9df08d4325dad6b8243e967be85f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9df08d4325dad6b8243e967be85f79">&#9670;&#160;</a></span>CdiAvmCopyAncillaryDataPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CdiAvmCopyAncillaryDataPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *</td>          <td class="paramname"><span class="paramname"><em>dest_packet_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *</td>          <td class="paramname"><span class="paramname"><em>source_packet_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function. Only exists for testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_packet_ptr</td><td>Destination packet to copy to. </td></tr>
    <tr><td class="paramname">source_packet_ptr</td><td>Source packet to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of parity errors (must be zero). </dd></dl>

</div>
</div>
<a id="a4db788cd2c36912bf21f2dd7bbf43d9d" name="a4db788cd2c36912bf21f2dd7bbf43d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db788cd2c36912bf21f2dd7bbf43d9d">&#9670;&#160;</a></span>CdiAvmGetAncillaryDataPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CdiAvmGetAncillaryDataPayloadSize </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>num_anc_packets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>data_counts</em>[]</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the buffer size needed to write an ancillary data payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_anc_packets</td><td>The number of ancillary data packets. </td></tr>
    <tr><td class="paramname">data_counts</td><td>Number of user data words for each prospective ancillary data packet (see <a class="el" href="structCdiAvmAncillaryDataPacket.html" title="An ancillary data packet. See https://datatracker.ietf.org/doc/html/rfc8331#section-2....">CdiAvmAncillaryDataPacket</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required buffer size in bytes. </dd></dl>

</div>
</div>
<a id="abe4b2ae86dffba38e8567d62e8938ccf" name="abe4b2ae86dffba38e8567d62e8938ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4b2ae86dffba38e8567d62e8938ccf">&#9670;&#160;</a></span>CdiAvmPacketizeAncillaryData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a> CdiAvmPacketizeAncillaryData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cdi__avm__payloads__api_8h.html#aae1d1f01c2b665619fe938debd97b92a">CdiAvmPacketizeAncCallback</a> *</td>          <td class="paramname"><span class="paramname"><em>produce_next_packet_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__avm__payloads__api_8h.html#add4ad41e6a5c8521ba83849b09d78afd">CdiFieldKind</a></td>          <td class="paramname"><span class="paramname"><em>field_kind</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>size_in_bytes_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an ancillary data payload in the provided buffer. For each ancillary data packet the application's callback returns a pointer to an <a class="el" href="structCdiAvmAncillaryDataPacket.html" title="An ancillary data packet. See https://datatracker.ietf.org/doc/html/rfc8331#section-2....">CdiAvmAncillaryDataPacket</a> object; it returns NULL when the payload is complete. The packets produced by the callback are encoded in order. The whole payload is prefixed with a two-word header. See <a href="https://cdi.elemental.com/specs/baseline-ancillary-data">https://cdi.elemental.com/specs/baseline-ancillary-data</a> for the payload format.</p>
<p>The provided buffer must be large enough to hold the encoded data. When the number of user data words of all ancillary data packets in the payload is known in advance, CdiAvmGetAncillaryDataPayloadSize may be used to compute the required buffer size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">produce_next_packet_ptr</td><td>Callback provided by the application, producing next ancillary data packet to encode. </td></tr>
    <tr><td class="paramname">field_kind</td><td>Field kind of this payload. See CdiFieldKind. </td></tr>
    <tr><td class="paramname">context_ptr</td><td>Pointer to user-defined data to keep track of state. </td></tr>
    <tr><td class="paramname">buffer_ptr</td><td>Pointer to payload buffer. </td></tr>
    <tr><td class="paramname">size_in_bytes_ptr</td><td>Points to size in bytes of payload buffer. Points to size of payload on successful return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating success or failure. </dd></dl>

</div>
</div>
<a id="a12f1fc35880137621ddf3164d61aa3d1" name="a12f1fc35880137621ddf3164d61aa3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f1fc35880137621ddf3164d61aa3d1">&#9670;&#160;</a></span>CdiAvmUnpacketizeAncillaryData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a> CdiAvmUnpacketizeAncillaryData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCdiSgList.html">CdiSgList</a> *</td>          <td class="paramname"><span class="paramname"><em>sgl_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cdi__avm__payloads__api_8h.html#a4f43ef501de76d4a2fc926ede3cd4490">CdiAvmUnpacketizeAncCallback</a> *</td>          <td class="paramname"><span class="paramname"><em>consume_next_packet_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode an ancillary data payload from the provided buffer and pass decoded ancillary data packets to the provided callback function for processing. If the payload cannot be decoded then kCdiInvalidPayload is returned. A return code of kCdiStatusRxPayloadError indicates that the payload was decoded with parity or checksum errors detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sgl_ptr</td><td>Pointer to payload buffer. </td></tr>
    <tr><td class="paramname">consume_next_packet_ptr</td><td>Callback provided by the application, consuming next decoded ancillary data packet. </td></tr>
    <tr><td class="paramname">context_ptr</td><td>Pointer to user-defined data to keep track of state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating success or failure. </dd></dl>

</div>
</div>
<a id="aa79724eb1e41f99d0e1873163c66760a" name="aa79724eb1e41f99d0e1873163c66760a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79724eb1e41f99d0e1873163c66760a">&#9670;&#160;</a></span>CopyInternalToPublicPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int CopyInternalToPublicPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *</td>          <td class="paramname"><span class="paramname"><em>dest_packet_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structAncillaryDataPacket.html">AncillaryDataPacket</a> *</td>          <td class="paramname"><span class="paramname"><em>source_packet_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy internal packet structure to public-facing API. Count number of parity errors in source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_packet_ptr</td><td>Destination packet to copy to. </td></tr>
    <tr><td class="paramname">source_packet_ptr</td><td>Source packet to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of user data parity errors detected in source packet. </dd></dl>

</div>
</div>
<a id="a15b077fa3c3f527db3b38c9f472520a0" name="a15b077fa3c3f527db3b38c9f472520a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b077fa3c3f527db3b38c9f472520a0">&#9670;&#160;</a></span>CopyPublicToInternalPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CopyPublicToInternalPacket </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAncillaryDataPacket.html">AncillaryDataPacket</a> *</td>          <td class="paramname"><span class="paramname"><em>dest_packet_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCdiAvmAncillaryDataPacket.html">CdiAvmAncillaryDataPacket</a> *</td>          <td class="paramname"><span class="paramname"><em>source_packet_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy public packet data to internal packet structure and add parity bits to 8-bit user data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_packet_ptr</td><td>Destination packet to copy to. </td></tr>
    <tr><td class="paramname">source_packet_ptr</td><td>Source packet to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7553c0ab7eed3ea5b303a92f6c3c8ed5" name="a7553c0ab7eed3ea5b303a92f6c3c8ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7553c0ab7eed3ea5b303a92f6c3c8ed5">&#9670;&#160;</a></span>CopyToLinearBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * CopyToLinearBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCdiSgList.html">CdiSgList</a> const *</td>          <td class="paramname"><span class="paramname"><em>sgl_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy SGL buffer contents to a linear buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sgl_ptr</td><td>Pointer to SGL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to linear buffer. Caller needs to free buffer. </dd></dl>

</div>
</div>
<a id="a929dca44761a611b336a5a1b06c7873f" name="a929dca44761a611b336a5a1b06c7873f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929dca44761a611b336a5a1b06c7873f">&#9670;&#160;</a></span>PrecheckAncillaryDataPayload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="cdi__core__api_8h.html#a0597f052733858ab62ea6388aa5ae54a">CdiReturnStatus</a> PrecheckAncillaryDataPayload </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buffer_ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>payload_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for CdiAvmUnpacketizeAncillaryDataPayload. Decodes the payload header and checks that the payload may be decoded without exceeding the specified payload size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_ptr</td><td>Pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size_in_bytes</td><td>Size of the payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code indicating success or failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
	<div>Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.</div>
</small></address>
</body>
</html>
